// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/payabli/sdk-go/internal"
	time "time"
)

type PayLinkDataBill struct {
	IdempotencyKey *IdempotencyKey `json:"-" url:"-"`
	// Indicates whether customer can modify the payment amount. A value of `true` means the amount isn't modifiable, a value `false` means the payor can modify the amount to pay.
	AmountFixed *bool `json:"-" url:"amountFixed,omitempty"`
	// List of recipient email addresses. When there is more than one, separate them by a semicolon (;).
	Mail2 *string                 `json:"-" url:"mail2,omitempty"`
	Body  *PaymentPageRequestBody `json:"-" url:"-"`
}

func (p *PayLinkDataBill) UnmarshalJSON(data []byte) error {
	body := new(PaymentPageRequestBody)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	p.Body = body
	return nil
}

func (p *PayLinkDataBill) MarshalJSON() ([]byte, error) {
	return json.Marshal(p.Body)
}

type PayLinkDataOut struct {
	EntryPoint Entry `json:"-" url:"entryPoint"`
	// The vendor number for the vendor being paid with this payment link.
	VendorNumber string `json:"-" url:"vendorNumber"`
	// List of recipient email addresses. When there is more than one, separate them by a semicolon (;).
	Mail2 *string `json:"-" url:"mail2,omitempty"`
	// Indicates whether customer can modify the payment amount. A value of `true` means the amount isn't modifiable, a value `false` means the payor can modify the amount to pay.
	AmountFixed *string                 `json:"-" url:"amountFixed,omitempty"`
	Body        *PaymentPageRequestBody `json:"-" url:"-"`
}

func (p *PayLinkDataOut) UnmarshalJSON(data []byte) error {
	body := new(PaymentPageRequestBody)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	p.Body = body
	return nil
}

func (p *PayLinkDataOut) MarshalJSON() ([]byte, error) {
	return json.Marshal(p.Body)
}

type PayLinkDataInvoice struct {
	IdempotencyKey *IdempotencyKey `json:"-" url:"-"`
	// Indicates whether customer can modify the payment amount. A value of `true` means the amount isn't modifiable, a value `false` means the payor can modify the amount to pay.
	AmountFixed *bool `json:"-" url:"amountFixed,omitempty"`
	// List of recipient email addresses. When there is more than one, separate them by a semicolon (;).
	Mail2 *string                 `json:"-" url:"mail2,omitempty"`
	Body  *PaymentPageRequestBody `json:"-" url:"-"`
}

func (p *PayLinkDataInvoice) UnmarshalJSON(data []byte) error {
	body := new(PaymentPageRequestBody)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	p.Body = body
	return nil
}

func (p *PayLinkDataInvoice) MarshalJSON() ([]byte, error) {
	return json.Marshal(p.Body)
}

type RefreshPayLinkFromIdRequest struct {
	// Indicates whether customer can modify the payment amount. A value of `true` means the amount isn't modifiable, a value `false` means the payor can modify the amount to pay.
	AmountFixed *bool `json:"-" url:"amountFixed,omitempty"`
}

type SendPayLinkFromIdRequest struct {
	// When `true`, attaches a PDF version of invoice to the email.
	Attachfile *bool `json:"-" url:"attachfile,omitempty"`
	// List of recipient email addresses. When there is more than one, separate them by a semicolon (;).
	Mail2 *string `json:"-" url:"mail2,omitempty"`
}

type PagelinkSetting struct {
	// An HTML color code in format #RRGGBB
	Color *string `json:"color,omitempty" url:"color,omitempty"`
	// Complete URL to a custom CSS file to be loaded with the page
	CustomCssUrl *string `json:"customCssUrl,omitempty" url:"customCssUrl,omitempty"`
	// Two-letter code following ISO 639-1
	Language *string `json:"language,omitempty" url:"language,omitempty"`
	// Object containing logo file to upload/ use in page
	PageLogo *FileContent `json:"pageLogo,omitempty" url:"pageLogo,omitempty"`
	// Flag indicating if the capability for redirection in the page will be activated
	RedirectAfterApprove *bool `json:"redirectAfterApprove,omitempty" url:"redirectAfterApprove,omitempty"`
	// Complete URL where the page will be redirected after completion
	RedirectAfterApproveUrl *string `json:"redirectAfterApproveUrl,omitempty" url:"redirectAfterApproveUrl,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PagelinkSetting) GetColor() *string {
	if p == nil {
		return nil
	}
	return p.Color
}

func (p *PagelinkSetting) GetCustomCssUrl() *string {
	if p == nil {
		return nil
	}
	return p.CustomCssUrl
}

func (p *PagelinkSetting) GetLanguage() *string {
	if p == nil {
		return nil
	}
	return p.Language
}

func (p *PagelinkSetting) GetPageLogo() *FileContent {
	if p == nil {
		return nil
	}
	return p.PageLogo
}

func (p *PagelinkSetting) GetRedirectAfterApprove() *bool {
	if p == nil {
		return nil
	}
	return p.RedirectAfterApprove
}

func (p *PagelinkSetting) GetRedirectAfterApproveUrl() *string {
	if p == nil {
		return nil
	}
	return p.RedirectAfterApproveUrl
}

func (p *PagelinkSetting) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PagelinkSetting) UnmarshalJSON(data []byte) error {
	type unmarshaler PagelinkSetting
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PagelinkSetting(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PagelinkSetting) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Request body for the push paylink operation.
type PushPayLinkRequest struct {
	Channel string
	Email   *PushPayLinkRequestEmail
	Sms     *PushPayLinkRequestSms
}

func (p *PushPayLinkRequest) GetChannel() string {
	if p == nil {
		return ""
	}
	return p.Channel
}

func (p *PushPayLinkRequest) GetEmail() *PushPayLinkRequestEmail {
	if p == nil {
		return nil
	}
	return p.Email
}

func (p *PushPayLinkRequest) GetSms() *PushPayLinkRequestSms {
	if p == nil {
		return nil
	}
	return p.Sms
}

func (p *PushPayLinkRequest) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Channel string `json:"channel"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Channel = unmarshaler.Channel
	if unmarshaler.Channel == "" {
		return fmt.Errorf("%T did not include discriminant channel", p)
	}
	switch unmarshaler.Channel {
	case "email":
		value := new(PushPayLinkRequestEmail)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Email = value
	case "sms":
		value := new(PushPayLinkRequestSms)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Sms = value
	}
	return nil
}

func (p PushPayLinkRequest) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	if p.Email != nil {
		return internal.MarshalJSONWithExtraProperty(p.Email, "channel", "email")
	}
	if p.Sms != nil {
		return internal.MarshalJSONWithExtraProperty(p.Sms, "channel", "sms")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PushPayLinkRequestVisitor interface {
	VisitEmail(*PushPayLinkRequestEmail) error
	VisitSms(*PushPayLinkRequestSms) error
}

func (p *PushPayLinkRequest) Accept(visitor PushPayLinkRequestVisitor) error {
	if p.Email != nil {
		return visitor.VisitEmail(p.Email)
	}
	if p.Sms != nil {
		return visitor.VisitSms(p.Sms)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

func (p *PushPayLinkRequest) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.Email != nil {
		fields = append(fields, "email")
	}
	if p.Sms != nil {
		fields = append(fields, "sms")
	}
	if len(fields) == 0 {
		if p.Channel != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.Channel)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.Channel != "" {
		field := fields[0]
		if p.Channel != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.Channel,
				p,
			)
		}
	}
	return nil
}

type PushPayLinkRequestEmail struct {
	// List of additional email addresses you want to send the paylink to, formatted as an array.
	// Payment links and opt-in requests are sent to the customer email address on file, and additional
	// recipients can be specified here.
	AdditionalEmails []string `json:"additionalEmails,omitempty" url:"additionalEmails,omitempty"`
	// When `true`, attaches a PDF version of the invoice to the email.
	AttachFile *bool `json:"attachFile,omitempty" url:"attachFile,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PushPayLinkRequestEmail) GetAdditionalEmails() []string {
	if p == nil {
		return nil
	}
	return p.AdditionalEmails
}

func (p *PushPayLinkRequestEmail) GetAttachFile() *bool {
	if p == nil {
		return nil
	}
	return p.AttachFile
}

func (p *PushPayLinkRequestEmail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PushPayLinkRequestEmail) UnmarshalJSON(data []byte) error {
	type unmarshaler PushPayLinkRequestEmail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PushPayLinkRequestEmail(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PushPayLinkRequestEmail) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PushPayLinkRequestSms struct {
	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PushPayLinkRequestSms) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PushPayLinkRequestSms) UnmarshalJSON(data []byte) error {
	type unmarshaler PushPayLinkRequestSms
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PushPayLinkRequestSms(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PushPayLinkRequestSms) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type GetPayLinkFromIdResponse struct {
	IsSuccess    *IsSuccess                            `json:"isSuccess,omitempty" url:"isSuccess,omitempty"`
	ResponseText *ResponseText                         `json:"responseText,omitempty" url:"responseText,omitempty"`
	ResponseData *GetPayLinkFromIdResponseResponseData `json:"responseData,omitempty" url:"responseData,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetPayLinkFromIdResponse) GetIsSuccess() *IsSuccess {
	if g == nil {
		return nil
	}
	return g.IsSuccess
}

func (g *GetPayLinkFromIdResponse) GetResponseText() *ResponseText {
	if g == nil {
		return nil
	}
	return g.ResponseText
}

func (g *GetPayLinkFromIdResponse) GetResponseData() *GetPayLinkFromIdResponseResponseData {
	if g == nil {
		return nil
	}
	return g.ResponseData
}

func (g *GetPayLinkFromIdResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetPayLinkFromIdResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetPayLinkFromIdResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetPayLinkFromIdResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetPayLinkFromIdResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetPayLinkFromIdResponseResponseData struct {
	AdditionalData *AdditionalData `json:"AdditionalData,omitempty" url:"AdditionalData,omitempty"`
	// Array of credential objects with active services for the page
	Credentials []*PayabliCredentials `json:"credentials,omitempty" url:"credentials,omitempty"`
	// Timestamp of last access to page structure
	LastAccess *time.Time `json:"lastAccess,omitempty" url:"lastAccess,omitempty"`
	// Sections of page
	PageContent    *PageContent    `json:"pageContent,omitempty" url:"pageContent,omitempty"`
	PageIdentifier *PageIdentifier `json:"pageIdentifier,omitempty" url:"pageIdentifier,omitempty"`
	// Settings of page
	PageSettings *PageSetting `json:"pageSettings,omitempty" url:"pageSettings,omitempty"`
	// Flag indicating if page is active to accept payments. `0` for false, `1` for true.
	Published *int `json:"published,omitempty" url:"published,omitempty"`
	// Sections of payment receipt
	ReceiptContent *ReceiptContent `json:"receiptContent,omitempty" url:"receiptContent,omitempty"`
	// Page identifier. Must be unique in platform.
	Subdomain *Subdomain `json:"subdomain,omitempty" url:"subdomain,omitempty"`
	// Total amount to pay in this page
	TotalAmount *float64 `json:"totalAmount,omitempty" url:"totalAmount,omitempty"`
	// Base64 encoded image of CAPTCHA associated to this page load
	ValidationCode *string `json:"validationCode,omitempty" url:"validationCode,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetPayLinkFromIdResponseResponseData) GetAdditionalData() *AdditionalData {
	if g == nil {
		return nil
	}
	return g.AdditionalData
}

func (g *GetPayLinkFromIdResponseResponseData) GetCredentials() []*PayabliCredentials {
	if g == nil {
		return nil
	}
	return g.Credentials
}

func (g *GetPayLinkFromIdResponseResponseData) GetLastAccess() *time.Time {
	if g == nil {
		return nil
	}
	return g.LastAccess
}

func (g *GetPayLinkFromIdResponseResponseData) GetPageContent() *PageContent {
	if g == nil {
		return nil
	}
	return g.PageContent
}

func (g *GetPayLinkFromIdResponseResponseData) GetPageIdentifier() *PageIdentifier {
	if g == nil {
		return nil
	}
	return g.PageIdentifier
}

func (g *GetPayLinkFromIdResponseResponseData) GetPageSettings() *PageSetting {
	if g == nil {
		return nil
	}
	return g.PageSettings
}

func (g *GetPayLinkFromIdResponseResponseData) GetPublished() *int {
	if g == nil {
		return nil
	}
	return g.Published
}

func (g *GetPayLinkFromIdResponseResponseData) GetReceiptContent() *ReceiptContent {
	if g == nil {
		return nil
	}
	return g.ReceiptContent
}

func (g *GetPayLinkFromIdResponseResponseData) GetSubdomain() *Subdomain {
	if g == nil {
		return nil
	}
	return g.Subdomain
}

func (g *GetPayLinkFromIdResponseResponseData) GetTotalAmount() *float64 {
	if g == nil {
		return nil
	}
	return g.TotalAmount
}

func (g *GetPayLinkFromIdResponseResponseData) GetValidationCode() *string {
	if g == nil {
		return nil
	}
	return g.ValidationCode
}

func (g *GetPayLinkFromIdResponseResponseData) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetPayLinkFromIdResponseResponseData) UnmarshalJSON(data []byte) error {
	type embed GetPayLinkFromIdResponseResponseData
	var unmarshaler = struct {
		embed
		LastAccess *internal.DateTime `json:"lastAccess,omitempty"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GetPayLinkFromIdResponseResponseData(unmarshaler.embed)
	g.LastAccess = unmarshaler.LastAccess.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetPayLinkFromIdResponseResponseData) MarshalJSON() ([]byte, error) {
	type embed GetPayLinkFromIdResponseResponseData
	var marshaler = struct {
		embed
		LastAccess *internal.DateTime `json:"lastAccess,omitempty"`
	}{
		embed:      embed(*g),
		LastAccess: internal.NewOptionalDateTime(g.LastAccess),
	}
	return json.Marshal(marshaler)
}

func (g *GetPayLinkFromIdResponseResponseData) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type PayabliApiResponsePaymentLinks struct {
	IsSuccess *IsSuccess `json:"isSuccess,omitempty" url:"isSuccess,omitempty"`
	// If `isSuccess` = true, this contains the payment link identifier. If `isSuccess` = false, this contains the reason of the error.
	ResponseData *string       `json:"responseData,omitempty" url:"responseData,omitempty"`
	ResponseText *ResponseText `json:"responseText,omitempty" url:"responseText,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayabliApiResponsePaymentLinks) GetIsSuccess() *IsSuccess {
	if p == nil {
		return nil
	}
	return p.IsSuccess
}

func (p *PayabliApiResponsePaymentLinks) GetResponseData() *string {
	if p == nil {
		return nil
	}
	return p.ResponseData
}

func (p *PayabliApiResponsePaymentLinks) GetResponseText() *ResponseText {
	if p == nil {
		return nil
	}
	return p.ResponseText
}

func (p *PayabliApiResponsePaymentLinks) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayabliApiResponsePaymentLinks) UnmarshalJSON(data []byte) error {
	type unmarshaler PayabliApiResponsePaymentLinks
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayabliApiResponsePaymentLinks(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayabliApiResponsePaymentLinks) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentPageRequestBody struct {
	// ContactUs section of payment link page
	ContactUs *ContactElement `json:"contactUs,omitempty" url:"contactUs,omitempty"`
	// Invoices section of payment link page
	Invoices *InvoiceElement `json:"invoices,omitempty" url:"invoices,omitempty"`
	// Logo section of payment link page
	Logo *Element `json:"logo,omitempty" url:"logo,omitempty"`
	// Message section of payment link page
	MessageBeforePaying *LabelElement `json:"messageBeforePaying,omitempty" url:"messageBeforePaying,omitempty"`
	// Notes section of payment link page
	Notes *NoteElement `json:"notes,omitempty" url:"notes,omitempty"`
	// Page header section of payment link page
	Page *PageElement `json:"page,omitempty" url:"page,omitempty"`
	// Payment button section of payment link page
	PaymentButton *LabelElement `json:"paymentButton,omitempty" url:"paymentButton,omitempty"`
	// Payment methods section of payment link page
	PaymentMethods *MethodElement `json:"paymentMethods,omitempty" url:"paymentMethods,omitempty"`
	// Customer/Payor section of payment link page
	Payor *PayorElement `json:"payor,omitempty" url:"payor,omitempty"`
	// Review section of payment link page
	Review *HeaderElement `json:"review,omitempty" url:"review,omitempty"`
	// Settings section of payment link page
	Settings *PagelinkSetting `json:"settings,omitempty" url:"settings,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentPageRequestBody) GetContactUs() *ContactElement {
	if p == nil {
		return nil
	}
	return p.ContactUs
}

func (p *PaymentPageRequestBody) GetInvoices() *InvoiceElement {
	if p == nil {
		return nil
	}
	return p.Invoices
}

func (p *PaymentPageRequestBody) GetLogo() *Element {
	if p == nil {
		return nil
	}
	return p.Logo
}

func (p *PaymentPageRequestBody) GetMessageBeforePaying() *LabelElement {
	if p == nil {
		return nil
	}
	return p.MessageBeforePaying
}

func (p *PaymentPageRequestBody) GetNotes() *NoteElement {
	if p == nil {
		return nil
	}
	return p.Notes
}

func (p *PaymentPageRequestBody) GetPage() *PageElement {
	if p == nil {
		return nil
	}
	return p.Page
}

func (p *PaymentPageRequestBody) GetPaymentButton() *LabelElement {
	if p == nil {
		return nil
	}
	return p.PaymentButton
}

func (p *PaymentPageRequestBody) GetPaymentMethods() *MethodElement {
	if p == nil {
		return nil
	}
	return p.PaymentMethods
}

func (p *PaymentPageRequestBody) GetPayor() *PayorElement {
	if p == nil {
		return nil
	}
	return p.Payor
}

func (p *PaymentPageRequestBody) GetReview() *HeaderElement {
	if p == nil {
		return nil
	}
	return p.Review
}

func (p *PaymentPageRequestBody) GetSettings() *PagelinkSetting {
	if p == nil {
		return nil
	}
	return p.Settings
}

func (p *PaymentPageRequestBody) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentPageRequestBody) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentPageRequestBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentPageRequestBody(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentPageRequestBody) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayLinkUpdateData struct {
	// ContactUs section of payment link page
	ContactUs *ContactElement `json:"contactUs,omitempty" url:"-"`
	// Logo section of payment link page
	Logo *Element `json:"logo,omitempty" url:"-"`
	// Message section of payment link page
	MessageBeforePaying *LabelElement `json:"messageBeforePaying,omitempty" url:"-"`
	// Notes section of payment link page
	Notes *NoteElement `json:"notes,omitempty" url:"-"`
	// Page header section of payment link page
	Page *PageElement `json:"page,omitempty" url:"-"`
	// Payment button section of payment link page
	PaymentButton *LabelElement `json:"paymentButton,omitempty" url:"-"`
	// Payment methods section of payment link page
	PaymentMethods *MethodElement `json:"paymentMethods,omitempty" url:"-"`
	// Review section of payment link page
	Review *HeaderElement `json:"review,omitempty" url:"-"`
	// Settings section of payment link page
	Settings *PagelinkSetting `json:"settings,omitempty" url:"-"`
}
