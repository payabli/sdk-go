// Code generated by Fern. DO NOT EDIT.

package payabli

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/payabli/sdk-go/internal"
)

type RequestSchedule struct {
	IdempotencyKey        *IdempotencyKey          `json:"-" url:"-"`
	ForceCustomerCreation *ForceCustomerCreation   `json:"-" url:"forceCustomerCreation,omitempty"`
	Body                  *SubscriptionRequestBody `json:"-" url:"-"`
}

func (r *RequestSchedule) UnmarshalJSON(data []byte) error {
	body := new(SubscriptionRequestBody)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	r.Body = body
	return nil
}

func (r *RequestSchedule) MarshalJSON() ([]byte, error) {
	return json.Marshal(r.Body)
}

type RequestUpdateSchedule struct {
	// Object describing details of the payment. To skip the payment, set the `totalAmount` to 0. Payments will be paused until the amount is updated to a non-zero value. When `totalAmount` is set to 0, the `serviceFee` must also be set to 0.
	PaymentDetails *PaymentDetail `json:"paymentDetails,omitempty" url:"-"`
	// Object describing the schedule for subscription
	ScheduleDetails *ScheduleDetail `json:"scheduleDetails,omitempty" url:"-"`
	SetPause        *SetPause       `json:"setPause,omitempty" url:"-"`
}

type ScheduleDetail struct {
	// Subscription end date in any of the accepted formats: YYYY-MM-DD, MM/DD/YYYY or the value `untilcancelled` to indicate a scheduled payment with infinite cycle.
	EndDate *string `json:"endDate,omitempty" url:"endDate,omitempty"`
	// Frequency of the subscription.
	Frequency *Frequency `json:"frequency,omitempty" url:"frequency,omitempty"`
	// This field is for future development, leave null. Identifier of subscription plan applied in the scheduled payment/subscription.
	PlanId *int `json:"planId,omitempty" url:"planId,omitempty"`
	// Subscription start date in any of the accepted formats: YYYY-MM-DD, MM/DD/YYYY. This must be a future date.
	StartDate *string `json:"startDate,omitempty" url:"startDate,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ScheduleDetail) GetEndDate() *string {
	if s == nil {
		return nil
	}
	return s.EndDate
}

func (s *ScheduleDetail) GetFrequency() *Frequency {
	if s == nil {
		return nil
	}
	return s.Frequency
}

func (s *ScheduleDetail) GetPlanId() *int {
	if s == nil {
		return nil
	}
	return s.PlanId
}

func (s *ScheduleDetail) GetStartDate() *string {
	if s == nil {
		return nil
	}
	return s.StartDate
}

func (s *ScheduleDetail) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScheduleDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler ScheduleDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScheduleDetail(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScheduleDetail) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Success response
type AddSubscriptionResponse struct {
	CustomerId   *CustomerId   `json:"customerId,omitempty" url:"customerId,omitempty"`
	ResponseText *ResponseText `json:"responseText,omitempty" url:"responseText,omitempty"`
	IsSuccess    *IsSuccess    `json:"isSuccess,omitempty" url:"isSuccess,omitempty"`
	// The identifier of the newly created subscription.
	ResponseData int `json:"responseData" url:"responseData"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AddSubscriptionResponse) GetCustomerId() *CustomerId {
	if a == nil {
		return nil
	}
	return a.CustomerId
}

func (a *AddSubscriptionResponse) GetResponseText() *ResponseText {
	if a == nil {
		return nil
	}
	return a.ResponseText
}

func (a *AddSubscriptionResponse) GetIsSuccess() *IsSuccess {
	if a == nil {
		return nil
	}
	return a.IsSuccess
}

func (a *AddSubscriptionResponse) GetResponseData() int {
	if a == nil {
		return 0
	}
	return a.ResponseData
}

func (a *AddSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AddSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AddSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AddSubscriptionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AddSubscriptionResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Success response
type RemoveSubscriptionResponse struct {
	IsSuccess *IsSuccess `json:"isSuccess,omitempty" url:"isSuccess,omitempty"`
	// If `isSuccess` = true, this contains the identifier of the subscription.
	//
	// If `isSuccess` = false, this contains the reason for the failure.
	ResponseData *string       `json:"responseData,omitempty" url:"responseData,omitempty"`
	ResponseText *ResponseText `json:"responseText,omitempty" url:"responseText,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RemoveSubscriptionResponse) GetIsSuccess() *IsSuccess {
	if r == nil {
		return nil
	}
	return r.IsSuccess
}

func (r *RemoveSubscriptionResponse) GetResponseData() *string {
	if r == nil {
		return nil
	}
	return r.ResponseData
}

func (r *RemoveSubscriptionResponse) GetResponseText() *ResponseText {
	if r == nil {
		return nil
	}
	return r.ResponseText
}

func (r *RemoveSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoveSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoveSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoveSubscriptionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoveSubscriptionResponse) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Information about the payment method for the transaction. Required and recommended fields for each payment method type are described in each schema below.
type RequestSchedulePaymentMethod struct {
	PayMethodCredit *PayMethodCredit
	PayMethodAch    *PayMethodAch
	// The required and recommended fields for a payment made with a stored payment method.
	RequestSchedulePaymentMethodInitiator *RequestSchedulePaymentMethodInitiator

	typ string
}

func (r *RequestSchedulePaymentMethod) GetPayMethodCredit() *PayMethodCredit {
	if r == nil {
		return nil
	}
	return r.PayMethodCredit
}

func (r *RequestSchedulePaymentMethod) GetPayMethodAch() *PayMethodAch {
	if r == nil {
		return nil
	}
	return r.PayMethodAch
}

func (r *RequestSchedulePaymentMethod) GetRequestSchedulePaymentMethodInitiator() *RequestSchedulePaymentMethodInitiator {
	if r == nil {
		return nil
	}
	return r.RequestSchedulePaymentMethodInitiator
}

func (r *RequestSchedulePaymentMethod) UnmarshalJSON(data []byte) error {
	valuePayMethodCredit := new(PayMethodCredit)
	if err := json.Unmarshal(data, &valuePayMethodCredit); err == nil {
		r.typ = "PayMethodCredit"
		r.PayMethodCredit = valuePayMethodCredit
		return nil
	}
	valuePayMethodAch := new(PayMethodAch)
	if err := json.Unmarshal(data, &valuePayMethodAch); err == nil {
		r.typ = "PayMethodAch"
		r.PayMethodAch = valuePayMethodAch
		return nil
	}
	valueRequestSchedulePaymentMethodInitiator := new(RequestSchedulePaymentMethodInitiator)
	if err := json.Unmarshal(data, &valueRequestSchedulePaymentMethodInitiator); err == nil {
		r.typ = "RequestSchedulePaymentMethodInitiator"
		r.RequestSchedulePaymentMethodInitiator = valueRequestSchedulePaymentMethodInitiator
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestSchedulePaymentMethod) MarshalJSON() ([]byte, error) {
	if r.typ == "PayMethodCredit" || r.PayMethodCredit != nil {
		return json.Marshal(r.PayMethodCredit)
	}
	if r.typ == "PayMethodAch" || r.PayMethodAch != nil {
		return json.Marshal(r.PayMethodAch)
	}
	if r.typ == "RequestSchedulePaymentMethodInitiator" || r.RequestSchedulePaymentMethodInitiator != nil {
		return json.Marshal(r.RequestSchedulePaymentMethodInitiator)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", r)
}

type RequestSchedulePaymentMethodVisitor interface {
	VisitPayMethodCredit(*PayMethodCredit) error
	VisitPayMethodAch(*PayMethodAch) error
	VisitRequestSchedulePaymentMethodInitiator(*RequestSchedulePaymentMethodInitiator) error
}

func (r *RequestSchedulePaymentMethod) Accept(visitor RequestSchedulePaymentMethodVisitor) error {
	if r.typ == "PayMethodCredit" || r.PayMethodCredit != nil {
		return visitor.VisitPayMethodCredit(r.PayMethodCredit)
	}
	if r.typ == "PayMethodAch" || r.PayMethodAch != nil {
		return visitor.VisitPayMethodAch(r.PayMethodAch)
	}
	if r.typ == "RequestSchedulePaymentMethodInitiator" || r.RequestSchedulePaymentMethodInitiator != nil {
		return visitor.VisitRequestSchedulePaymentMethodInitiator(r.RequestSchedulePaymentMethodInitiator)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", r)
}

// The required and recommended fields for a payment made with a stored payment method.
type RequestSchedulePaymentMethodInitiator struct {
	Initiator *Initiator `json:"initiator,omitempty" url:"initiator,omitempty"`
	// Payabli identifier of a tokenized payment method.
	StoredMethodId        *Storedmethodid        `json:"storedMethodId,omitempty" url:"storedMethodId,omitempty"`
	StoredMethodUsageType *StoredMethodUsageType `json:"storedMethodUsageType,omitempty" url:"storedMethodUsageType,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RequestSchedulePaymentMethodInitiator) GetInitiator() *Initiator {
	if r == nil {
		return nil
	}
	return r.Initiator
}

func (r *RequestSchedulePaymentMethodInitiator) GetStoredMethodId() *Storedmethodid {
	if r == nil {
		return nil
	}
	return r.StoredMethodId
}

func (r *RequestSchedulePaymentMethodInitiator) GetStoredMethodUsageType() *StoredMethodUsageType {
	if r == nil {
		return nil
	}
	return r.StoredMethodUsageType
}

func (r *RequestSchedulePaymentMethodInitiator) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RequestSchedulePaymentMethodInitiator) UnmarshalJSON(data []byte) error {
	type unmarshaler RequestSchedulePaymentMethodInitiator
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RequestSchedulePaymentMethodInitiator(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RequestSchedulePaymentMethodInitiator) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Flag indicating if subscription is paused. When a subscription is paused, no payments are processed until the subscription is unpaused, and the next payment date isn't calculated automatically. If you want to skip a payment instead, set the `totalAmount` to 0 in the `paymentDetails` object.
type SetPause = bool

type SubscriptionRequestBody struct {
	// Object describing the customer/payor.
	CustomerData *PayorDataRequest `json:"customerData,omitempty" url:"customerData,omitempty"`
	EntryPoint   *Entrypointfield  `json:"entryPoint,omitempty" url:"entryPoint,omitempty"`
	// Object describing an Invoice linked to the subscription.
	InvoiceData *BillData `json:"invoiceData,omitempty" url:"invoiceData,omitempty"`
	// Object describing details of the payment. To skip the payment, set the `totalAmount` to 0. Payments will be paused until the amount is updated to a non-zero value. When `totalAmount` is set to 0, the `serviceFee` must also be set to 0.
	PaymentDetails *PaymentDetail `json:"paymentDetails,omitempty" url:"paymentDetails,omitempty"`
	// Information about the payment method for the transaction. Required and recommended fields for each payment method type are described in each schema below.
	PaymentMethod *RequestSchedulePaymentMethod `json:"paymentMethod,omitempty" url:"paymentMethod,omitempty"`
	// Object describing the schedule for subscription.
	ScheduleDetails *ScheduleDetail `json:"scheduleDetails,omitempty" url:"scheduleDetails,omitempty"`
	SetPause        *SetPause       `json:"setPause,omitempty" url:"setPause,omitempty"`
	Source          *Source         `json:"source,omitempty" url:"source,omitempty"`
	Subdomain       *Subdomain      `json:"subdomain,omitempty" url:"subdomain,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubscriptionRequestBody) GetCustomerData() *PayorDataRequest {
	if s == nil {
		return nil
	}
	return s.CustomerData
}

func (s *SubscriptionRequestBody) GetEntryPoint() *Entrypointfield {
	if s == nil {
		return nil
	}
	return s.EntryPoint
}

func (s *SubscriptionRequestBody) GetInvoiceData() *BillData {
	if s == nil {
		return nil
	}
	return s.InvoiceData
}

func (s *SubscriptionRequestBody) GetPaymentDetails() *PaymentDetail {
	if s == nil {
		return nil
	}
	return s.PaymentDetails
}

func (s *SubscriptionRequestBody) GetPaymentMethod() *RequestSchedulePaymentMethod {
	if s == nil {
		return nil
	}
	return s.PaymentMethod
}

func (s *SubscriptionRequestBody) GetScheduleDetails() *ScheduleDetail {
	if s == nil {
		return nil
	}
	return s.ScheduleDetails
}

func (s *SubscriptionRequestBody) GetSetPause() *SetPause {
	if s == nil {
		return nil
	}
	return s.SetPause
}

func (s *SubscriptionRequestBody) GetSource() *Source {
	if s == nil {
		return nil
	}
	return s.Source
}

func (s *SubscriptionRequestBody) GetSubdomain() *Subdomain {
	if s == nil {
		return nil
	}
	return s.Subdomain
}

func (s *SubscriptionRequestBody) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionRequestBody) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionRequestBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionRequestBody(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionRequestBody) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Success response
type UpdateSubscriptionResponse struct {
	IsSuccess *IsSuccess `json:"isSuccess,omitempty" url:"isSuccess,omitempty"`
	// If `isSuccess` = true, this contains the identifier of the subscription, and sometimes extra information, depending on what was updated.
	//
	// If `isSuccess` = false, this contains the reason for the failure.
	ResponseData *string       `json:"responseData,omitempty" url:"responseData,omitempty"`
	ResponseText *ResponseText `json:"responseText,omitempty" url:"responseText,omitempty"`
	CustomerId   *CustomerId   `json:"customerId,omitempty" url:"customerId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateSubscriptionResponse) GetIsSuccess() *IsSuccess {
	if u == nil {
		return nil
	}
	return u.IsSuccess
}

func (u *UpdateSubscriptionResponse) GetResponseData() *string {
	if u == nil {
		return nil
	}
	return u.ResponseData
}

func (u *UpdateSubscriptionResponse) GetResponseText() *ResponseText {
	if u == nil {
		return nil
	}
	return u.ResponseText
}

func (u *UpdateSubscriptionResponse) GetCustomerId() *CustomerId {
	if u == nil {
		return nil
	}
	return u.CustomerId
}

func (u *UpdateSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateSubscriptionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateSubscriptionResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}
