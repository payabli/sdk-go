// Code generated by Fern. DO NOT EDIT.

package payabli

import (
	json "encoding/json"
	fmt "fmt"
	uuid "github.com/google/uuid"
	internal "github.com/payabli/sdk-go/internal"
	time "time"
)

type SearchNotificationLogsRequest struct {
	PageSize *Pagesize `json:"-" url:"PageSize,omitempty"`
	// The number of records to skip before starting to collect the result set.
	Skip *int                          `json:"-" url:"Skip,omitempty"`
	Body *NotificationLogSearchRequest `json:"-" url:"-"`
}

func (s *SearchNotificationLogsRequest) UnmarshalJSON(data []byte) error {
	body := new(NotificationLogSearchRequest)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	s.Body = body
	return nil
}

func (s *SearchNotificationLogsRequest) MarshalJSON() ([]byte, error) {
	return json.Marshal(s.Body)
}

// A list of notification log IDs to retry. The maximum number of IDs that can be retried in a single request is 50.
type BulkRetryRequest = []uuid.UUID

type KeyValueArray struct {
	Key   *string  `json:"key,omitempty" url:"key,omitempty"`
	Value []string `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KeyValueArray) GetKey() *string {
	if k == nil {
		return nil
	}
	return k.Key
}

func (k *KeyValueArray) GetValue() []string {
	if k == nil {
		return nil
	}
	return k.Value
}

func (k *KeyValueArray) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KeyValueArray) UnmarshalJSON(data []byte) error {
	type unmarshaler KeyValueArray
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*k = KeyValueArray(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KeyValueArray) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

type NotificationLog struct {
	// The unique identifier for the notification.
	Id uuid.UUID `json:"id" url:"id"`
	// The ID of the organization that the notification belongs to.
	OrgId *int64 `json:"orgId,omitempty" url:"orgId,omitempty"`
	// The ID of the paypoint that the notification is related to.
	PaypointId *int64 `json:"paypointId,omitempty" url:"paypointId,omitempty"`
	// The event that triggered the notification.
	NotificationEvent *string `json:"notificationEvent,omitempty" url:"notificationEvent,omitempty"`
	// The target URL for the notification.
	Target *string `json:"target,omitempty" url:"target,omitempty"`
	// The HTTP response status of the notification.
	ResponseStatus *string `json:"responseStatus,omitempty" url:"responseStatus,omitempty"`
	// Indicates whether the notification was successful.
	Success bool `json:"success" url:"success"`
	// Contains the body of the notification.
	JobData *string `json:"jobData,omitempty" url:"jobData,omitempty"`
	// The date and time when the notification was created.
	CreatedDate time.Time `json:"createdDate" url:"createdDate"`
	// The date and time when the notification was successfully delivered.
	SuccessDate *time.Time `json:"successDate,omitempty" url:"successDate,omitempty"`
	// The date and time when the notification last failed.
	LastFailedDate *time.Time `json:"lastFailedDate,omitempty" url:"lastFailedDate,omitempty"`
	// Indicates whether the notification is currently in progress.
	IsInProgress bool `json:"isInProgress" url:"isInProgress"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NotificationLog) GetId() uuid.UUID {
	if n == nil {
		return uuid.Nil
	}
	return n.Id
}

func (n *NotificationLog) GetOrgId() *int64 {
	if n == nil {
		return nil
	}
	return n.OrgId
}

func (n *NotificationLog) GetPaypointId() *int64 {
	if n == nil {
		return nil
	}
	return n.PaypointId
}

func (n *NotificationLog) GetNotificationEvent() *string {
	if n == nil {
		return nil
	}
	return n.NotificationEvent
}

func (n *NotificationLog) GetTarget() *string {
	if n == nil {
		return nil
	}
	return n.Target
}

func (n *NotificationLog) GetResponseStatus() *string {
	if n == nil {
		return nil
	}
	return n.ResponseStatus
}

func (n *NotificationLog) GetSuccess() bool {
	if n == nil {
		return false
	}
	return n.Success
}

func (n *NotificationLog) GetJobData() *string {
	if n == nil {
		return nil
	}
	return n.JobData
}

func (n *NotificationLog) GetCreatedDate() time.Time {
	if n == nil {
		return time.Time{}
	}
	return n.CreatedDate
}

func (n *NotificationLog) GetSuccessDate() *time.Time {
	if n == nil {
		return nil
	}
	return n.SuccessDate
}

func (n *NotificationLog) GetLastFailedDate() *time.Time {
	if n == nil {
		return nil
	}
	return n.LastFailedDate
}

func (n *NotificationLog) GetIsInProgress() bool {
	if n == nil {
		return false
	}
	return n.IsInProgress
}

func (n *NotificationLog) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NotificationLog) UnmarshalJSON(data []byte) error {
	type embed NotificationLog
	var unmarshaler = struct {
		embed
		CreatedDate    *internal.DateTime `json:"createdDate"`
		SuccessDate    *internal.DateTime `json:"successDate,omitempty"`
		LastFailedDate *internal.DateTime `json:"lastFailedDate,omitempty"`
	}{
		embed: embed(*n),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*n = NotificationLog(unmarshaler.embed)
	n.CreatedDate = unmarshaler.CreatedDate.Time()
	n.SuccessDate = unmarshaler.SuccessDate.TimePtr()
	n.LastFailedDate = unmarshaler.LastFailedDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NotificationLog) MarshalJSON() ([]byte, error) {
	type embed NotificationLog
	var marshaler = struct {
		embed
		CreatedDate    *internal.DateTime `json:"createdDate"`
		SuccessDate    *internal.DateTime `json:"successDate,omitempty"`
		LastFailedDate *internal.DateTime `json:"lastFailedDate,omitempty"`
	}{
		embed:          embed(*n),
		CreatedDate:    internal.NewDateTime(n.CreatedDate),
		SuccessDate:    internal.NewOptionalDateTime(n.SuccessDate),
		LastFailedDate: internal.NewOptionalDateTime(n.LastFailedDate),
	}
	return json.Marshal(marshaler)
}

func (n *NotificationLog) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NotificationLogDetail struct {
	// The unique identifier for the notification.
	Id uuid.UUID `json:"id" url:"id"`
	// The ID of the organization that the notification belongs to.
	OrgId *int64 `json:"orgId,omitempty" url:"orgId,omitempty"`
	// The ID of the paypoint that the notification is related to.
	PaypointId *int64 `json:"paypointId,omitempty" url:"paypointId,omitempty"`
	// The event that triggered the notification.
	NotificationEvent *string `json:"notificationEvent,omitempty" url:"notificationEvent,omitempty"`
	// The target URL for the notification.
	Target *string `json:"target,omitempty" url:"target,omitempty"`
	// The HTTP response status of the notification.
	ResponseStatus *string `json:"responseStatus,omitempty" url:"responseStatus,omitempty"`
	// Indicates whether the notification was successful.
	Success bool `json:"success" url:"success"`
	// Contains the body of the notification.
	JobData *string `json:"jobData,omitempty" url:"jobData,omitempty"`
	// The date and time when the notification was created.
	CreatedDate time.Time `json:"createdDate" url:"createdDate"`
	// The date and time when the notification was successfully delivered.
	SuccessDate *time.Time `json:"successDate,omitempty" url:"successDate,omitempty"`
	// The date and time when the notification last failed.
	LastFailedDate *time.Time `json:"lastFailedDate,omitempty" url:"lastFailedDate,omitempty"`
	// Indicates whether the notification is currently in progress.
	IsInProgress    bool                        `json:"isInProgress" url:"isInProgress"`
	WebHeaders      []*StringStringKeyValuePair `json:"webHeaders,omitempty" url:"webHeaders,omitempty"`
	ResponseHeaders []*KeyValueArray            `json:"responseHeaders,omitempty" url:"responseHeaders,omitempty"`
	ResponseContent *string                     `json:"responseContent,omitempty" url:"responseContent,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NotificationLogDetail) GetId() uuid.UUID {
	if n == nil {
		return uuid.Nil
	}
	return n.Id
}

func (n *NotificationLogDetail) GetOrgId() *int64 {
	if n == nil {
		return nil
	}
	return n.OrgId
}

func (n *NotificationLogDetail) GetPaypointId() *int64 {
	if n == nil {
		return nil
	}
	return n.PaypointId
}

func (n *NotificationLogDetail) GetNotificationEvent() *string {
	if n == nil {
		return nil
	}
	return n.NotificationEvent
}

func (n *NotificationLogDetail) GetTarget() *string {
	if n == nil {
		return nil
	}
	return n.Target
}

func (n *NotificationLogDetail) GetResponseStatus() *string {
	if n == nil {
		return nil
	}
	return n.ResponseStatus
}

func (n *NotificationLogDetail) GetSuccess() bool {
	if n == nil {
		return false
	}
	return n.Success
}

func (n *NotificationLogDetail) GetJobData() *string {
	if n == nil {
		return nil
	}
	return n.JobData
}

func (n *NotificationLogDetail) GetCreatedDate() time.Time {
	if n == nil {
		return time.Time{}
	}
	return n.CreatedDate
}

func (n *NotificationLogDetail) GetSuccessDate() *time.Time {
	if n == nil {
		return nil
	}
	return n.SuccessDate
}

func (n *NotificationLogDetail) GetLastFailedDate() *time.Time {
	if n == nil {
		return nil
	}
	return n.LastFailedDate
}

func (n *NotificationLogDetail) GetIsInProgress() bool {
	if n == nil {
		return false
	}
	return n.IsInProgress
}

func (n *NotificationLogDetail) GetWebHeaders() []*StringStringKeyValuePair {
	if n == nil {
		return nil
	}
	return n.WebHeaders
}

func (n *NotificationLogDetail) GetResponseHeaders() []*KeyValueArray {
	if n == nil {
		return nil
	}
	return n.ResponseHeaders
}

func (n *NotificationLogDetail) GetResponseContent() *string {
	if n == nil {
		return nil
	}
	return n.ResponseContent
}

func (n *NotificationLogDetail) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NotificationLogDetail) UnmarshalJSON(data []byte) error {
	type embed NotificationLogDetail
	var unmarshaler = struct {
		embed
		CreatedDate    *internal.DateTime `json:"createdDate"`
		SuccessDate    *internal.DateTime `json:"successDate,omitempty"`
		LastFailedDate *internal.DateTime `json:"lastFailedDate,omitempty"`
	}{
		embed: embed(*n),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*n = NotificationLogDetail(unmarshaler.embed)
	n.CreatedDate = unmarshaler.CreatedDate.Time()
	n.SuccessDate = unmarshaler.SuccessDate.TimePtr()
	n.LastFailedDate = unmarshaler.LastFailedDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NotificationLogDetail) MarshalJSON() ([]byte, error) {
	type embed NotificationLogDetail
	var marshaler = struct {
		embed
		CreatedDate    *internal.DateTime `json:"createdDate"`
		SuccessDate    *internal.DateTime `json:"successDate,omitempty"`
		LastFailedDate *internal.DateTime `json:"lastFailedDate,omitempty"`
	}{
		embed:          embed(*n),
		CreatedDate:    internal.NewDateTime(n.CreatedDate),
		SuccessDate:    internal.NewOptionalDateTime(n.SuccessDate),
		LastFailedDate: internal.NewOptionalDateTime(n.LastFailedDate),
	}
	return json.Marshal(marshaler)
}

func (n *NotificationLogDetail) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NotificationLogSearchRequest struct {
	// The start date for the search.
	StartDate time.Time `json:"startDate" url:"startDate"`
	// The end date for the search.
	EndDate time.Time `json:"endDate" url:"endDate"`
	// The type of notification event to filter by.
	NotificationEvent *string `json:"notificationEvent,omitempty" url:"notificationEvent,omitempty"`
	// Indicates whether the notification was successful.
	Succeeded *bool `json:"succeeded,omitempty" url:"succeeded,omitempty"`
	// The ID of the organization to filter by.
	OrgId *int64 `json:"orgId,omitempty" url:"orgId,omitempty"`
	// The ID of the paypoint to filter by.
	PaypointId *int64 `json:"paypointId,omitempty" url:"paypointId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NotificationLogSearchRequest) GetStartDate() time.Time {
	if n == nil {
		return time.Time{}
	}
	return n.StartDate
}

func (n *NotificationLogSearchRequest) GetEndDate() time.Time {
	if n == nil {
		return time.Time{}
	}
	return n.EndDate
}

func (n *NotificationLogSearchRequest) GetNotificationEvent() *string {
	if n == nil {
		return nil
	}
	return n.NotificationEvent
}

func (n *NotificationLogSearchRequest) GetSucceeded() *bool {
	if n == nil {
		return nil
	}
	return n.Succeeded
}

func (n *NotificationLogSearchRequest) GetOrgId() *int64 {
	if n == nil {
		return nil
	}
	return n.OrgId
}

func (n *NotificationLogSearchRequest) GetPaypointId() *int64 {
	if n == nil {
		return nil
	}
	return n.PaypointId
}

func (n *NotificationLogSearchRequest) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NotificationLogSearchRequest) UnmarshalJSON(data []byte) error {
	type embed NotificationLogSearchRequest
	var unmarshaler = struct {
		embed
		StartDate *internal.DateTime `json:"startDate"`
		EndDate   *internal.DateTime `json:"endDate"`
	}{
		embed: embed(*n),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*n = NotificationLogSearchRequest(unmarshaler.embed)
	n.StartDate = unmarshaler.StartDate.Time()
	n.EndDate = unmarshaler.EndDate.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NotificationLogSearchRequest) MarshalJSON() ([]byte, error) {
	type embed NotificationLogSearchRequest
	var marshaler = struct {
		embed
		StartDate *internal.DateTime `json:"startDate"`
		EndDate   *internal.DateTime `json:"endDate"`
	}{
		embed:     embed(*n),
		StartDate: internal.NewDateTime(n.StartDate),
		EndDate:   internal.NewDateTime(n.EndDate),
	}
	return json.Marshal(marshaler)
}

func (n *NotificationLogSearchRequest) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type StringStringKeyValuePair struct {
	Key   *string `json:"key,omitempty" url:"key,omitempty"`
	Value *string `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *StringStringKeyValuePair) GetKey() *string {
	if s == nil {
		return nil
	}
	return s.Key
}

func (s *StringStringKeyValuePair) GetValue() *string {
	if s == nil {
		return nil
	}
	return s.Value
}

func (s *StringStringKeyValuePair) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StringStringKeyValuePair) UnmarshalJSON(data []byte) error {
	type unmarshaler StringStringKeyValuePair
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StringStringKeyValuePair(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *StringStringKeyValuePair) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}
