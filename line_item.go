// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/payabli/sdk-go/internal"
)

type AddItemRequest struct {
	// A unique ID you can include to prevent duplicating objects or transactions if a request is sent more than once. This key isn't generated in Payabli, you must generate it yourself.
	IdempotencyKey *string   `json:"-" url:"-"`
	Body           *LineItem `json:"-" url:"-"`
}

func (a *AddItemRequest) UnmarshalJSON(data []byte) error {
	body := new(LineItem)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	a.Body = body
	return nil
}

func (a *AddItemRequest) MarshalJSON() ([]byte, error) {
	return json.Marshal(a.Body)
}

type ListLineItemsRequest struct {
	// The number of records to skip before starting to collect the result set.
	FromRecord *int `json:"-" url:"fromRecord,omitempty"`
	// Max number of records to return for the query. Use `0` or negative value to return all records.
	LimitRecord *int `json:"-" url:"limitRecord,omitempty"`
	// Collection of field names, conditions, and values used to filter the query
	// <Info>
	//
	//	**You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**
	//
	//	Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.
	//
	//	For example:
	//
	//	--url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20
	//
	//	should become:
	//
	//	--url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
	//
	// </Info>
	// See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for help.
	//
	// List of field names accepted:
	//
	//   - `categories` (ct, nct)
	//   - `code` (ne, eq, ct, nct)
	//   - `commodityCode` (ne, eq, ct, nct)
	//   - `createdDate` (gt, ge, lt, le, eq, ne)
	//   - `description` (ne, eq, ct, nct)
	//   - `externalPaypointID` (ct, nct, ne, eq)
	//   - `mode` (eq, ne)
	//   - `name` (ne, eq, ct, nct)
	//   - `orgName` (ne, eq, ct, nct)
	//   - `paypointDba` (ne, eq, ct, nct)
	//   - `paypointId` (ne, eq)
	//   - `paypointLegal` (ne, eq, ct, nct)
	//   - `quantity` (gt, ge, lt, le, eq, ne)
	//   - `uom` (ne, eq, ct, nct)
	//   - `updatedDate` (gt, ge, lt, le, eq, ne)
	//   - `value` (gt, ge, lt, le, eq, ne)
	//
	// List of comparison accepted - enclosed between parentheses:
	//
	// - eq or empty => equal
	// - gt => greater than
	// - ge => greater or equal
	// - lt => less than
	// - le => less or equal
	// - ne => not equal
	// - ct => contains
	// - nct => not contains
	// - in => inside array separated by "|"
	// - nin => not inside array separated by "|"
	//
	// List of parameters accepted:
	// - limitRecord : max number of records for query (default="20", "0" or negative value for all)
	// - fromRecord : initial record in query
	//
	// Example: name(ct)=john return all records with name containing john
	Parameters map[string]*string `json:"-" url:"parameters,omitempty"`
	// The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.
	SortBy *string `json:"-" url:"sortBy,omitempty"`
}

type LineItem struct {
	// Array of tags classifying item or product.
	ItemCategories    []*string          `json:"itemCategories,omitempty" url:"itemCategories,omitempty"`
	ItemCommodityCode *ItemCommodityCode `json:"itemCommodityCode,omitempty" url:"itemCommodityCode,omitempty"`
	// Item or product price per unit.
	ItemCost        float64          `json:"itemCost" url:"itemCost"`
	ItemDescription *ItemDescription `json:"itemDescription,omitempty" url:"itemDescription,omitempty"`
	// Internal class of item or product: value '0' is only for invoices, '1' for bills, and '2' is common for both.
	ItemMode        *int             `json:"itemMode,omitempty" url:"itemMode,omitempty"`
	ItemProductCode *ItemProductCode `json:"itemProductCode,omitempty" url:"itemProductCode,omitempty"`
	ItemProductName *ItemProductName `json:"itemProductName,omitempty" url:"itemProductName,omitempty"`
	// Quantity of item or product.
	ItemQty           int                `json:"itemQty" url:"itemQty"`
	ItemUnitOfMeasure *ItemUnitofMeasure `json:"itemUnitOfMeasure,omitempty" url:"itemUnitOfMeasure,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LineItem) GetItemCategories() []*string {
	if l == nil {
		return nil
	}
	return l.ItemCategories
}

func (l *LineItem) GetItemCommodityCode() *ItemCommodityCode {
	if l == nil {
		return nil
	}
	return l.ItemCommodityCode
}

func (l *LineItem) GetItemCost() float64 {
	if l == nil {
		return 0
	}
	return l.ItemCost
}

func (l *LineItem) GetItemDescription() *ItemDescription {
	if l == nil {
		return nil
	}
	return l.ItemDescription
}

func (l *LineItem) GetItemMode() *int {
	if l == nil {
		return nil
	}
	return l.ItemMode
}

func (l *LineItem) GetItemProductCode() *ItemProductCode {
	if l == nil {
		return nil
	}
	return l.ItemProductCode
}

func (l *LineItem) GetItemProductName() *ItemProductName {
	if l == nil {
		return nil
	}
	return l.ItemProductName
}

func (l *LineItem) GetItemQty() int {
	if l == nil {
		return 0
	}
	return l.ItemQty
}

func (l *LineItem) GetItemUnitOfMeasure() *ItemUnitofMeasure {
	if l == nil {
		return nil
	}
	return l.ItemUnitOfMeasure
}

func (l *LineItem) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LineItem) UnmarshalJSON(data []byte) error {
	type unmarshaler LineItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LineItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LineItem) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LineItemQueryRecord struct {
	// Timestamp of when line item was created, in UTC.
	CreatedAt *CreatedAt `json:"createdAt,omitempty" url:"createdAt,omitempty"`
	// Identifier of line item.
	Id *int64 `json:"id,omitempty" url:"id,omitempty"`
	// Array of tags classifying item or product.
	ItemCategories    []*string          `json:"itemCategories,omitempty" url:"itemCategories,omitempty"`
	ItemCommodityCode *ItemCommodityCode `json:"itemCommodityCode,omitempty" url:"itemCommodityCode,omitempty"`
	// Item or product price per unit.
	ItemCost        float64          `json:"itemCost" url:"itemCost"`
	ItemDescription *ItemDescription `json:"itemDescription,omitempty" url:"itemDescription,omitempty"`
	// Internal class of item or product: value '0' is only for invoices , '1' for bills, and '2' common for both.
	ItemMode        *int             `json:"itemMode,omitempty" url:"itemMode,omitempty"`
	ItemProductCode *ItemProductCode `json:"itemProductCode,omitempty" url:"itemProductCode,omitempty"`
	ItemProductName *ItemProductName `json:"itemProductName,omitempty" url:"itemProductName,omitempty"`
	// Quantity of item or product.
	ItemQty           int                `json:"itemQty" url:"itemQty"`
	ItemUnitOfMeasure *ItemUnitofMeasure `json:"itemUnitOfMeasure,omitempty" url:"itemUnitOfMeasure,omitempty"`
	// Timestamp of when the line item was updated, in UTC.
	LastUpdated    *LastModified   `json:"lastUpdated,omitempty" url:"lastUpdated,omitempty"`
	Pageidentifier *PageIdentifier `json:"pageidentifier,omitempty" url:"pageidentifier,omitempty"`
	// The name of the paypoint's parent organization.
	ParentOrgName *OrgParentName `json:"ParentOrgName,omitempty" url:"ParentOrgName,omitempty"`
	// The paypoint's DBA name.
	PaypointDbaname *Dbaname `json:"PaypointDbaname,omitempty" url:"PaypointDbaname,omitempty"`
	// The paypoint's entryname (entrypoint) value.
	PaypointEntryname *Entrypointfield `json:"PaypointEntryname,omitempty" url:"PaypointEntryname,omitempty"`
	// The paypoint's legal name.
	PaypointLegalname *Legalname `json:"PaypointLegalname,omitempty" url:"PaypointLegalname,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LineItemQueryRecord) GetCreatedAt() *CreatedAt {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LineItemQueryRecord) GetId() *int64 {
	if l == nil {
		return nil
	}
	return l.Id
}

func (l *LineItemQueryRecord) GetItemCategories() []*string {
	if l == nil {
		return nil
	}
	return l.ItemCategories
}

func (l *LineItemQueryRecord) GetItemCommodityCode() *ItemCommodityCode {
	if l == nil {
		return nil
	}
	return l.ItemCommodityCode
}

func (l *LineItemQueryRecord) GetItemCost() float64 {
	if l == nil {
		return 0
	}
	return l.ItemCost
}

func (l *LineItemQueryRecord) GetItemDescription() *ItemDescription {
	if l == nil {
		return nil
	}
	return l.ItemDescription
}

func (l *LineItemQueryRecord) GetItemMode() *int {
	if l == nil {
		return nil
	}
	return l.ItemMode
}

func (l *LineItemQueryRecord) GetItemProductCode() *ItemProductCode {
	if l == nil {
		return nil
	}
	return l.ItemProductCode
}

func (l *LineItemQueryRecord) GetItemProductName() *ItemProductName {
	if l == nil {
		return nil
	}
	return l.ItemProductName
}

func (l *LineItemQueryRecord) GetItemQty() int {
	if l == nil {
		return 0
	}
	return l.ItemQty
}

func (l *LineItemQueryRecord) GetItemUnitOfMeasure() *ItemUnitofMeasure {
	if l == nil {
		return nil
	}
	return l.ItemUnitOfMeasure
}

func (l *LineItemQueryRecord) GetLastUpdated() *LastModified {
	if l == nil {
		return nil
	}
	return l.LastUpdated
}

func (l *LineItemQueryRecord) GetPageidentifier() *PageIdentifier {
	if l == nil {
		return nil
	}
	return l.Pageidentifier
}

func (l *LineItemQueryRecord) GetParentOrgName() *OrgParentName {
	if l == nil {
		return nil
	}
	return l.ParentOrgName
}

func (l *LineItemQueryRecord) GetPaypointDbaname() *Dbaname {
	if l == nil {
		return nil
	}
	return l.PaypointDbaname
}

func (l *LineItemQueryRecord) GetPaypointEntryname() *Entrypointfield {
	if l == nil {
		return nil
	}
	return l.PaypointEntryname
}

func (l *LineItemQueryRecord) GetPaypointLegalname() *Legalname {
	if l == nil {
		return nil
	}
	return l.PaypointLegalname
}

func (l *LineItemQueryRecord) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LineItemQueryRecord) UnmarshalJSON(data []byte) error {
	type unmarshaler LineItemQueryRecord
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LineItemQueryRecord(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LineItemQueryRecord) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Response schema for line item operations.
type PayabliApiResponse6 struct {
	IsSuccess      *IsSuccess      `json:"isSuccess,omitempty" url:"isSuccess,omitempty"`
	PageIdentifier *PageIdentifier `json:"pageIdentifier,omitempty" url:"pageIdentifier,omitempty"`
	// If `isSuccess` = true, this contains the line item identifier. If `isSuccess` = false, this contains the reason of the error.
	ResponseData *Responsedatanonobject `json:"responseData,omitempty" url:"responseData,omitempty"`
	ResponseText *ResponseText          `json:"responseText,omitempty" url:"responseText,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayabliApiResponse6) GetIsSuccess() *IsSuccess {
	if p == nil {
		return nil
	}
	return p.IsSuccess
}

func (p *PayabliApiResponse6) GetPageIdentifier() *PageIdentifier {
	if p == nil {
		return nil
	}
	return p.PageIdentifier
}

func (p *PayabliApiResponse6) GetResponseData() *Responsedatanonobject {
	if p == nil {
		return nil
	}
	return p.ResponseData
}

func (p *PayabliApiResponse6) GetResponseText() *ResponseText {
	if p == nil {
		return nil
	}
	return p.ResponseText
}

func (p *PayabliApiResponse6) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayabliApiResponse6) UnmarshalJSON(data []byte) error {
	type unmarshaler PayabliApiResponse6
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayabliApiResponse6(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayabliApiResponse6) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Response for line item queries
type QueryResponseItems struct {
	Records []*QueryResponseItemsRecordsItem `json:"Records,omitempty" url:"Records,omitempty"`
	Summary *QuerySummary                    `json:"Summary,omitempty" url:"Summary,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (q *QueryResponseItems) GetRecords() []*QueryResponseItemsRecordsItem {
	if q == nil {
		return nil
	}
	return q.Records
}

func (q *QueryResponseItems) GetSummary() *QuerySummary {
	if q == nil {
		return nil
	}
	return q.Summary
}

func (q *QueryResponseItems) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryResponseItems) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryResponseItems
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QueryResponseItems(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties
	q.rawJSON = json.RawMessage(data)
	return nil
}

func (q *QueryResponseItems) String() string {
	if len(q.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(q.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type QueryResponseItemsRecordsItem struct {
	LineItem      *LineItem      `json:"LineItem,omitempty" url:"LineItem,omitempty"`
	ParentOrgName *OrgParentName `json:"ParentOrgName,omitempty" url:"ParentOrgName,omitempty"`
	// The paypoint's DBA name.
	PaypointDbaname *Dbaname `json:"PaypointDbaname,omitempty" url:"PaypointDbaname,omitempty"`
	// The paypoint's entry name (entrypoint).
	PaypointEntryname *Entrypointfield `json:"PaypointEntryname,omitempty" url:"PaypointEntryname,omitempty"`
	// the Paypoint's legal name.
	PaypointLegalname *Legalname `json:"PaypointLegalname,omitempty" url:"PaypointLegalname,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (q *QueryResponseItemsRecordsItem) GetLineItem() *LineItem {
	if q == nil {
		return nil
	}
	return q.LineItem
}

func (q *QueryResponseItemsRecordsItem) GetParentOrgName() *OrgParentName {
	if q == nil {
		return nil
	}
	return q.ParentOrgName
}

func (q *QueryResponseItemsRecordsItem) GetPaypointDbaname() *Dbaname {
	if q == nil {
		return nil
	}
	return q.PaypointDbaname
}

func (q *QueryResponseItemsRecordsItem) GetPaypointEntryname() *Entrypointfield {
	if q == nil {
		return nil
	}
	return q.PaypointEntryname
}

func (q *QueryResponseItemsRecordsItem) GetPaypointLegalname() *Legalname {
	if q == nil {
		return nil
	}
	return q.PaypointLegalname
}

func (q *QueryResponseItemsRecordsItem) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryResponseItemsRecordsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryResponseItemsRecordsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QueryResponseItemsRecordsItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties
	q.rawJSON = json.RawMessage(data)
	return nil
}

func (q *QueryResponseItemsRecordsItem) String() string {
	if len(q.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(q.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type DeleteItemResponse struct {
	IsSuccess    *IsSuccess    `json:"isSuccess,omitempty" url:"isSuccess,omitempty"`
	ResponseText *ResponseText `json:"responseText,omitempty" url:"responseText,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteItemResponse) GetIsSuccess() *IsSuccess {
	if d == nil {
		return nil
	}
	return d.IsSuccess
}

func (d *DeleteItemResponse) GetResponseText() *ResponseText {
	if d == nil {
		return nil
	}
	return d.ResponseText
}

func (d *DeleteItemResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteItemResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteItemResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteItemResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteItemResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}
