// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/payabli/sdk-go/internal"
	time "time"
)

type Ach struct {
	// Bank account number. This field is **required** when method = `ach`.
	AchAccount Achaccount `json:"achAccount" url:"achAccount"`
	// Bank account type. This field is **required** when method = `ach`.
	AchAccountType *Achaccounttype `json:"achAccountType,omitempty" url:"achAccountType,omitempty"`
	AchCode        *AchSecCode     `json:"achCode,omitempty" url:"achCode,omitempty"`
	AchHolder      AchHolder       `json:"achHolder" url:"achHolder"`
	AchHolderType  *AchHolderType  `json:"achHolderType,omitempty" url:"achHolderType,omitempty"`
	// ABA/routing number of bank account. This field is **required** when method is `ach`.
	AchRouting Achrouting `json:"achRouting" url:"achRouting"`
	Device     *Device    `json:"device,omitempty" url:"device,omitempty"`
	method     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *Ach) GetAchAccount() Achaccount {
	if a == nil {
		return ""
	}
	return a.AchAccount
}

func (a *Ach) GetAchAccountType() *Achaccounttype {
	if a == nil {
		return nil
	}
	return a.AchAccountType
}

func (a *Ach) GetAchCode() *AchSecCode {
	if a == nil {
		return nil
	}
	return a.AchCode
}

func (a *Ach) GetAchHolder() AchHolder {
	if a == nil {
		return ""
	}
	return a.AchHolder
}

func (a *Ach) GetAchHolderType() *AchHolderType {
	if a == nil {
		return nil
	}
	return a.AchHolderType
}

func (a *Ach) GetAchRouting() Achrouting {
	if a == nil {
		return ""
	}
	return a.AchRouting
}

func (a *Ach) GetDevice() *Device {
	if a == nil {
		return nil
	}
	return a.Device
}

func (a *Ach) Method() string {
	return a.method
}

func (a *Ach) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Ach) UnmarshalJSON(data []byte) error {
	type embed Ach
	var unmarshaler = struct {
		embed
		Method string `json:"method"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = Ach(unmarshaler.embed)
	if unmarshaler.Method != "ach" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "ach", unmarshaler.Method)
	}
	a.method = unmarshaler.Method
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "method")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *Ach) MarshalJSON() ([]byte, error) {
	type embed Ach
	var marshaler = struct {
		embed
		Method string `json:"method"`
	}{
		embed:  embed(*a),
		Method: "ach",
	}
	return json.Marshal(marshaler)
}

func (a *Ach) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AcceptOauth = *bool

type AcceptRegister = *bool

// Account number for bank account. This value is returned masked in responses.
type AccountNumber = string

// Expiration date of card used in transaction.
type Accountexp = string

// Custom identifier for payment connector.
type Accountid = string

// Optional custom field.
type AccountingField = string

// Bank account type or card brand.
type Accounttype = string

// ZIP code for card used in transaction.
type Accountzip = string

// Bank account holder. This field is **required** when `method` is `ach` or `check`.
type AchHolder = string

// The bank's accountholder type: personal or business.
type AchHolderType string

const (
	AchHolderTypePersonal AchHolderType = "personal"
	AchHolderTypeBusiness AchHolderType = "business"
)

func NewAchHolderTypeFromString(s string) (AchHolderType, error) {
	switch s {
	case "personal":
		return AchHolderTypePersonal, nil
	case "business":
		return AchHolderTypeBusiness, nil
	}
	var t AchHolderType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AchHolderType) Ptr() *AchHolderType {
	return &a
}

// ACH payment method.
type AchPaymentMethod struct {
	// Payment method type
	// ID of the stored ACH payment method. Required when using a previously saved ACH method when the vendor has more than one saved method. See the [Payouts with saved ACH payment methods](/developers/developer-guides/pay-out-manage-payouts) section for more details.
	StoredMethodId *string `json:"storedMethodId,omitempty" url:"storedMethodId,omitempty"`
	method         string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AchPaymentMethod) GetStoredMethodId() *string {
	if a == nil {
		return nil
	}
	return a.StoredMethodId
}

func (a *AchPaymentMethod) Method() string {
	return a.method
}

func (a *AchPaymentMethod) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AchPaymentMethod) UnmarshalJSON(data []byte) error {
	type embed AchPaymentMethod
	var unmarshaler = struct {
		embed
		Method string `json:"method"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AchPaymentMethod(unmarshaler.embed)
	if unmarshaler.Method != "ach" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "ach", unmarshaler.Method)
	}
	a.method = unmarshaler.Method
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "method")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AchPaymentMethod) MarshalJSON() ([]byte, error) {
	type embed AchPaymentMethod
	var marshaler = struct {
		embed
		Method string `json:"method"`
	}{
		embed:  embed(*a),
		Method: "ach",
	}
	return json.Marshal(marshaler)
}

func (a *AchPaymentMethod) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Standard Entry Class (SEC) code is a three letter code that describes how an ACH payment was authorized. Supported values are:
//   - PPD (Prearranged Payment and Deposit) - Used for credits or debits where an accountholder authorizes a company to initiate either a single or recurring transaction to their personal bank account. Common examples include direct deposit of payroll, mortgage payments, or utility bills. This is the default value for subscription payments.
//   - WEB (Internet-Initiated/Mobile Entry) - Used for debit entries when authorization is obtained from an accountholder via the internet or a wireless network. Common examples are online bill payments, ecommerce purchases, and mobile app payments where the consumer enters their banking information online.
//   - TEL (Telephone-Initiated Entry) - Used for one-time debit entries where authorization is obtained from a consumer via telephone. Common examples are phone-based purchases or bill payments where the consumer provides their banking information over the phone.
//   - CCD (Corporate Credit or Debit) - Used for fund transfers between business accounts. This code is specifically for business-to-business transactions. Common examples include vendor payments and other business-to-business payments.
type AchSecCode = string

type AchSetup struct {
	// CCD is an ACH SEC Code that can be used in ACH transactions by the user that indicates the transaction is a Corporate Credit or Debit Entry. Options are: `true` and `false`
	AcceptCcd *bool `json:"acceptCCD,omitempty" url:"acceptCCD,omitempty"`
	// PPD is an ACH SEC Code that can be used in ACH transactions by the user that indicates the transaction is a Prearranged Payment and Deposit.
	AcceptPpd *bool `json:"acceptPPD,omitempty" url:"acceptPPD,omitempty"`
	// Web is an ACH SEC Code that can be used in ACH transactions by the user that indicates the transaction is a Internet Initiated/Mobile Entry Options are `true` and `false`.
	AcceptWeb *bool `json:"acceptWeb,omitempty" url:"acceptWeb,omitempty"`

	ExtraProperties map[string]interface{} `json:"-" url:"-"`

	rawJSON json.RawMessage
}

func (a *AchSetup) GetAcceptCcd() *bool {
	if a == nil {
		return nil
	}
	return a.AcceptCcd
}

func (a *AchSetup) GetAcceptPpd() *bool {
	if a == nil {
		return nil
	}
	return a.AcceptPpd
}

func (a *AchSetup) GetAcceptWeb() *bool {
	if a == nil {
		return nil
	}
	return a.AcceptWeb
}

func (a *AchSetup) GetExtraProperties() map[string]interface{} {
	return a.ExtraProperties
}

func (a *AchSetup) UnmarshalJSON(data []byte) error {
	type embed AchSetup
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AchSetup(unmarshaler.embed)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.ExtraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AchSetup) MarshalJSON() ([]byte, error) {
	type embed AchSetup
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	return internal.MarshalJSONWithExtraProperties(marshaler, a.ExtraProperties)
}

func (a *AchSetup) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// When `true`, enables real-time validation of ACH account and routing numbers. This is an add-on feature, contact Payabli for more information.
type AchValidation = *bool

// Bank account number.
type Achaccount = string

// Bank account type: Checking or Savings.
type Achaccounttype string

const (
	AchaccounttypeChecking Achaccounttype = "Checking"
	AchaccounttypeSavings  Achaccounttype = "Savings"
)

func NewAchaccounttypeFromString(s string) (Achaccounttype, error) {
	switch s {
	case "Checking":
		return AchaccounttypeChecking, nil
	case "Savings":
		return AchaccounttypeSavings, nil
	}
	var t Achaccounttype
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a Achaccounttype) Ptr() *Achaccounttype {
	return &a
}

// ABA/routing number of Bank account.
type Achrouting = string

// Custom dictionary of key:value pairs. You can use this field to store any data related to the object or for your system. If you are using [custom identifiers](/developers/developer-guides/entities-customers), pass those in this object. Example usage:
//
// ```json
//
//	{
//	  "additionalData": {
//	    "key1": "value1",
//	    "key2": "value2",
//	    "key3": "value3"
//	  }
//	}
//
// ```
type AdditionalData = map[string]map[string]interface{}

// Custom dictionary of key:value pairs. You can use this field to store any data related to the object or for your system. Example usage:
//
// ```json
//
//	{
//	  "additionalData": {
//	    "key1": "value1",
//	    "key2": "value2",
//	    "key3": "value3"
//	  }
//	}
//
// ```
type AdditionalDataString = string

// Additional line for the address.
type AddressAddtlNullable = string

// The address.
type AddressNullable = string

type AmountElement struct {
	Categories []*PayCategory `json:"categories,omitempty" url:"categories,omitempty"`
	Enabled    *Enabled       `json:"enabled,omitempty" url:"enabled,omitempty"`
	Order      *Order         `json:"order,omitempty" url:"order,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AmountElement) GetCategories() []*PayCategory {
	if a == nil {
		return nil
	}
	return a.Categories
}

func (a *AmountElement) GetEnabled() *Enabled {
	if a == nil {
		return nil
	}
	return a.Enabled
}

func (a *AmountElement) GetOrder() *Order {
	if a == nil {
		return nil
	}
	return a.Order
}

func (a *AmountElement) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AmountElement) UnmarshalJSON(data []byte) error {
	type unmarshaler AmountElement
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AmountElement(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AmountElement) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Array of `fileContent` objects with attached documents. Max upload size is 30 MB.
type Attachments = []*FileContent

// Authorization code for the transaction.
type Authcode = string

type AutoElement struct {
	Enabled *Enabled `json:"enabled,omitempty" url:"enabled,omitempty"`
	// Type of end date
	Finish *Finishtype `json:"finish,omitempty" url:"finish,omitempty"`
	// accepted frequencies for autopay
	Frequency *FrequencyList `json:"frequency,omitempty" url:"frequency,omitempty"`
	// Value of pre-selected frequency
	FrequencySelected *string `json:"frequencySelected,omitempty" url:"frequencySelected,omitempty"`
	// Header text for section
	Header *string `json:"header,omitempty" url:"header,omitempty"`
	Order  *Order  `json:"order,omitempty" url:"order,omitempty"`
	// Range of days enabled in calendar. Leave empty to enable all days.
	StartDate *string `json:"startDate,omitempty" url:"startDate,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AutoElement) GetEnabled() *Enabled {
	if a == nil {
		return nil
	}
	return a.Enabled
}

func (a *AutoElement) GetFinish() *Finishtype {
	if a == nil {
		return nil
	}
	return a.Finish
}

func (a *AutoElement) GetFrequency() *FrequencyList {
	if a == nil {
		return nil
	}
	return a.Frequency
}

func (a *AutoElement) GetFrequencySelected() *string {
	if a == nil {
		return nil
	}
	return a.FrequencySelected
}

func (a *AutoElement) GetHeader() *string {
	if a == nil {
		return nil
	}
	return a.Header
}

func (a *AutoElement) GetOrder() *Order {
	if a == nil {
		return nil
	}
	return a.Order
}

func (a *AutoElement) GetStartDate() *string {
	if a == nil {
		return nil
	}
	return a.StartDate
}

func (a *AutoElement) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AutoElement) UnmarshalJSON(data []byte) error {
	type unmarshaler AutoElement
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AutoElement(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AutoElement) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Average total amount of transactions in your local currency that are processed each month.
type Avgmonthly = *float64

// Text code describing the result for address validation (applies only for card transactions).
type Avsresponsetext = string

// Business address. This must be a physical address, not a P.O. box.
type Baddress1 = string

// Business address additional line. If used, this must be the physical address of the business, not a P.O. box.
type Baddress2 = string

// Object that contains bank account details.
type Bank struct {
	// The Payabli-assigned internal identifier for the bank account.
	Id *int `json:"id,omitempty" url:"id,omitempty"`
	// A user-defined internal identifier for the bank account. This allows you to specify which bank account should be used for payments in cases where multiple accounts are configured.
	AccountId             *string                `json:"accountId,omitempty" url:"accountId,omitempty"`
	Nickname              *BankNickname          `json:"nickname,omitempty" url:"nickname,omitempty"`
	BankName              *BankName              `json:"bankName,omitempty" url:"bankName,omitempty"`
	RoutingAccount        *RoutingAccount        `json:"routingAccount,omitempty" url:"routingAccount,omitempty"`
	AccountNumber         *AccountNumber         `json:"accountNumber,omitempty" url:"accountNumber,omitempty"`
	TypeAccount           *TypeAccount           `json:"typeAccount,omitempty" url:"typeAccount,omitempty"`
	BankAccountHolderName *BankAccountHolderName `json:"bankAccountHolderName,omitempty" url:"bankAccountHolderName,omitempty"`
	BankAccountHolderType *BankAccountHolderType `json:"bankAccountHolderType,omitempty" url:"bankAccountHolderType,omitempty"`
	BankAccountFunction   *BankAccountFunction   `json:"bankAccountFunction,omitempty" url:"bankAccountFunction,omitempty"`
	// Bank account verification status. When `true`, the account has been verified to exist and be in good standing based on vendor checks or previous processing histories.
	Verified *bool `json:"verified,omitempty" url:"verified,omitempty"`
	// Bank account status
	Status *int `json:"status,omitempty" url:"status,omitempty"`
	// Array of services associated with this bank account
	Services []string `json:"services,omitempty" url:"services,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *Bank) GetId() *int {
	if b == nil {
		return nil
	}
	return b.Id
}

func (b *Bank) GetAccountId() *string {
	if b == nil {
		return nil
	}
	return b.AccountId
}

func (b *Bank) GetNickname() *BankNickname {
	if b == nil {
		return nil
	}
	return b.Nickname
}

func (b *Bank) GetBankName() *BankName {
	if b == nil {
		return nil
	}
	return b.BankName
}

func (b *Bank) GetRoutingAccount() *RoutingAccount {
	if b == nil {
		return nil
	}
	return b.RoutingAccount
}

func (b *Bank) GetAccountNumber() *AccountNumber {
	if b == nil {
		return nil
	}
	return b.AccountNumber
}

func (b *Bank) GetTypeAccount() *TypeAccount {
	if b == nil {
		return nil
	}
	return b.TypeAccount
}

func (b *Bank) GetBankAccountHolderName() *BankAccountHolderName {
	if b == nil {
		return nil
	}
	return b.BankAccountHolderName
}

func (b *Bank) GetBankAccountHolderType() *BankAccountHolderType {
	if b == nil {
		return nil
	}
	return b.BankAccountHolderType
}

func (b *Bank) GetBankAccountFunction() *BankAccountFunction {
	if b == nil {
		return nil
	}
	return b.BankAccountFunction
}

func (b *Bank) GetVerified() *bool {
	if b == nil {
		return nil
	}
	return b.Verified
}

func (b *Bank) GetStatus() *int {
	if b == nil {
		return nil
	}
	return b.Status
}

func (b *Bank) GetServices() []string {
	if b == nil {
		return nil
	}
	return b.Services
}

func (b *Bank) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *Bank) UnmarshalJSON(data []byte) error {
	type unmarshaler Bank
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = Bank(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *Bank) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Indicates the function of the bank account:
// * 0 - Deposits
// * 1 - Withdrawals
// * 2 - Deposits & Withdrawals
// * 3 - Remittances
// * 4 - Remittances & Deposits
// * 5 - Remittances & Withdrawals
// * 6 - Remittances & Withdrawals & Deposits
//
// A paypoint is required to have a single deposit and withdrawal account. A Paypoint can have as many remittance accounts as needed for pay outs (remittances).
type BankAccountFunction = int

// The accountholder's name.
type BankAccountHolderName = string

// Describes whether the bank is a personal or business account.
type BankAccountHolderType string

const (
	BankAccountHolderTypePersonal BankAccountHolderType = "Personal"
	BankAccountHolderTypeBusiness BankAccountHolderType = "Business"
)

func NewBankAccountHolderTypeFromString(s string) (BankAccountHolderType, error) {
	switch s {
	case "Personal":
		return BankAccountHolderTypePersonal, nil
	case "Business":
		return BankAccountHolderTypeBusiness, nil
	}
	var t BankAccountHolderType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BankAccountHolderType) Ptr() *BankAccountHolderType {
	return &b
}

// Information about associated bank accounts.
type BankData = []*Bank

// Name of bank for account.
type BankName = string

// User-defined name for the bank account.
type BankNickname = string

// The batch number.
type BatchNumber = string

// Business city
type Bcity = string

// Business country in ISO-3166-1 alpha 2 format. See: https://en.wikipedia.org/wiki/ISO_3166-1 for more information.
type Bcountry = string

type BillData struct {
	AdditionalData *AdditionalDataString `json:"AdditionalData,omitempty" url:"AdditionalData,omitempty"`
	Attachments    *Attachments          `json:"attachments,omitempty" url:"attachments,omitempty"`
	// Company name of the recipient of the invoice.
	Company    *string     `json:"company,omitempty" url:"company,omitempty"`
	Discount   *Discount   `json:"discount,omitempty" url:"discount,omitempty"`
	DutyAmount *DutyAmount `json:"dutyAmount,omitempty" url:"dutyAmount,omitempty"`
	// First name of the recipient of the invoice.
	FirstName     *string        `json:"firstName,omitempty" url:"firstName,omitempty"`
	FreightAmount *FreightAmount `json:"freightAmount,omitempty" url:"freightAmount,omitempty"`
	// Frequency of scheduled invoice.
	Frequency     *Frequency     `json:"frequency,omitempty" url:"frequency,omitempty"`
	InvoiceAmount *InvoiceAmount `json:"invoiceAmount,omitempty" url:"invoiceAmount,omitempty"`
	// Invoice date in any of the accepted formats: YYYY-MM-DD, MM/DD/YYYY.
	InvoiceDate *Datenullable `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Invoice due date in one of the accepted formats: YYYY-MM-DD, MM/DD/YYYY.
	InvoiceDueDate *Datenullable `json:"invoiceDueDate,omitempty" url:"invoiceDueDate,omitempty"`
	// Indicate the date to finish a scheduled invoice cycle (`invoiceTypeâ€œ = 1) in any of the accepted formats: YYYY-MM-DD, MM/DD/YYYY.
	InvoiceEndDate *Datenullable `json:"invoiceEndDate,omitempty" url:"invoiceEndDate,omitempty"`
	// Invoice number. Identifies the invoice under a paypoint.
	InvoiceNumber *InvoiceNumber `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	InvoiceStatus *Invoicestatus `json:"invoiceStatus,omitempty" url:"invoiceStatus,omitempty"`
	InvoiceType   *InvoiceType   `json:"invoiceType,omitempty" url:"invoiceType,omitempty"`
	// Array of line items included in the invoice.
	Items []*BillItem `json:"items,omitempty" url:"items,omitempty"`
	// Last name of the recipient of the invoice.
	LastName *string `json:"lastName,omitempty" url:"lastName,omitempty"`
	// Notes included in the invoice.
	Notes            *string                    `json:"notes,omitempty" url:"notes,omitempty"`
	PaymentTerms     *BillDataPaymentTerms      `json:"paymentTerms,omitempty" url:"paymentTerms,omitempty"`
	PurchaseOrder    *PurchaseOrder             `json:"purchaseOrder,omitempty" url:"purchaseOrder,omitempty"`
	ShippingAddress1 *Shippingaddress           `json:"shippingAddress1,omitempty" url:"shippingAddress1,omitempty"`
	ShippingAddress2 *Shippingaddressadditional `json:"shippingAddress2,omitempty" url:"shippingAddress2,omitempty"`
	ShippingCity     *Shippingcity              `json:"shippingCity,omitempty" url:"shippingCity,omitempty"`
	ShippingCountry  *Shippingcountry           `json:"shippingCountry,omitempty" url:"shippingCountry,omitempty"`
	// Shipping recipient's contact email address.
	ShippingEmail   *Email           `json:"shippingEmail,omitempty" url:"shippingEmail,omitempty"`
	ShippingFromZip *ShippingFromZip `json:"shippingFromZip,omitempty" url:"shippingFromZip,omitempty"`
	// Recipient phone number.
	ShippingPhone        *string               `json:"shippingPhone,omitempty" url:"shippingPhone,omitempty"`
	ShippingState        *Shippingstate        `json:"shippingState,omitempty" url:"shippingState,omitempty"`
	ShippingZip          *Shippingzip          `json:"shippingZip,omitempty" url:"shippingZip,omitempty"`
	SummaryCommodityCode *SummaryCommodityCode `json:"summaryCommodityCode,omitempty" url:"summaryCommodityCode,omitempty"`
	Tax                  *Tax                  `json:"tax,omitempty" url:"tax,omitempty"`
	TermsConditions      *TermsConditions      `json:"termsConditions,omitempty" url:"termsConditions,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BillData) GetAdditionalData() *AdditionalDataString {
	if b == nil {
		return nil
	}
	return b.AdditionalData
}

func (b *BillData) GetAttachments() *Attachments {
	if b == nil {
		return nil
	}
	return b.Attachments
}

func (b *BillData) GetCompany() *string {
	if b == nil {
		return nil
	}
	return b.Company
}

func (b *BillData) GetDiscount() *Discount {
	if b == nil {
		return nil
	}
	return b.Discount
}

func (b *BillData) GetDutyAmount() *DutyAmount {
	if b == nil {
		return nil
	}
	return b.DutyAmount
}

func (b *BillData) GetFirstName() *string {
	if b == nil {
		return nil
	}
	return b.FirstName
}

func (b *BillData) GetFreightAmount() *FreightAmount {
	if b == nil {
		return nil
	}
	return b.FreightAmount
}

func (b *BillData) GetFrequency() *Frequency {
	if b == nil {
		return nil
	}
	return b.Frequency
}

func (b *BillData) GetInvoiceAmount() *InvoiceAmount {
	if b == nil {
		return nil
	}
	return b.InvoiceAmount
}

func (b *BillData) GetInvoiceDate() *Datenullable {
	if b == nil {
		return nil
	}
	return b.InvoiceDate
}

func (b *BillData) GetInvoiceDueDate() *Datenullable {
	if b == nil {
		return nil
	}
	return b.InvoiceDueDate
}

func (b *BillData) GetInvoiceEndDate() *Datenullable {
	if b == nil {
		return nil
	}
	return b.InvoiceEndDate
}

func (b *BillData) GetInvoiceNumber() *InvoiceNumber {
	if b == nil {
		return nil
	}
	return b.InvoiceNumber
}

func (b *BillData) GetInvoiceStatus() *Invoicestatus {
	if b == nil {
		return nil
	}
	return b.InvoiceStatus
}

func (b *BillData) GetInvoiceType() *InvoiceType {
	if b == nil {
		return nil
	}
	return b.InvoiceType
}

func (b *BillData) GetItems() []*BillItem {
	if b == nil {
		return nil
	}
	return b.Items
}

func (b *BillData) GetLastName() *string {
	if b == nil {
		return nil
	}
	return b.LastName
}

func (b *BillData) GetNotes() *string {
	if b == nil {
		return nil
	}
	return b.Notes
}

func (b *BillData) GetPaymentTerms() *BillDataPaymentTerms {
	if b == nil {
		return nil
	}
	return b.PaymentTerms
}

func (b *BillData) GetPurchaseOrder() *PurchaseOrder {
	if b == nil {
		return nil
	}
	return b.PurchaseOrder
}

func (b *BillData) GetShippingAddress1() *Shippingaddress {
	if b == nil {
		return nil
	}
	return b.ShippingAddress1
}

func (b *BillData) GetShippingAddress2() *Shippingaddressadditional {
	if b == nil {
		return nil
	}
	return b.ShippingAddress2
}

func (b *BillData) GetShippingCity() *Shippingcity {
	if b == nil {
		return nil
	}
	return b.ShippingCity
}

func (b *BillData) GetShippingCountry() *Shippingcountry {
	if b == nil {
		return nil
	}
	return b.ShippingCountry
}

func (b *BillData) GetShippingEmail() *Email {
	if b == nil {
		return nil
	}
	return b.ShippingEmail
}

func (b *BillData) GetShippingFromZip() *ShippingFromZip {
	if b == nil {
		return nil
	}
	return b.ShippingFromZip
}

func (b *BillData) GetShippingPhone() *string {
	if b == nil {
		return nil
	}
	return b.ShippingPhone
}

func (b *BillData) GetShippingState() *Shippingstate {
	if b == nil {
		return nil
	}
	return b.ShippingState
}

func (b *BillData) GetShippingZip() *Shippingzip {
	if b == nil {
		return nil
	}
	return b.ShippingZip
}

func (b *BillData) GetSummaryCommodityCode() *SummaryCommodityCode {
	if b == nil {
		return nil
	}
	return b.SummaryCommodityCode
}

func (b *BillData) GetTax() *Tax {
	if b == nil {
		return nil
	}
	return b.Tax
}

func (b *BillData) GetTermsConditions() *TermsConditions {
	if b == nil {
		return nil
	}
	return b.TermsConditions
}

func (b *BillData) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BillData) UnmarshalJSON(data []byte) error {
	type unmarshaler BillData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BillData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BillData) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Payment terms for invoice. If no terms are defined, then response data for this field defaults to `NET30`.
//
// **Available Values:**
//
// - `PIA`: Payment in advance
//
// - `CIA`: Cash in advance
//
// - `UR`: Upon receipt
//
// - `NET10`: 10 days after invoice date
//
// - `NET20`: 20 days after invoice date
//
// - `NET30`: 30 days after invoice date
//
// - `NET45`: 45 days after invoice date
//
// - `NET60`: 60 days after invoice date
//
// - `NET90`: 90 days after invoice date
//
// - `EOM`: Due end of this month
//
// - `MFI`: 1st of the month following the invoice date
//
// - `5MFI`: 5th of the month following the invoice date
//
// - `10MFI`: 10th of the month following the invoice date
//
// - `15MFI`: 15th of the month following the invoice date
//
// - `20MFI`: 20th of the month following the invoice date
//
// - `2/10NET30`: 2% discount if paid within 10 days, otherwise net 30 days
//
// - `UF`: Until further notice
//
// - `10UF`: 10 days until further notice
//
// - `20UF`: 20 days until further notice
//
// - `25UF`: 25 days until further notice
//
// - `50UF`: 50 days until further notice
type BillDataPaymentTerms string

const (
	BillDataPaymentTermsPia          BillDataPaymentTerms = "PIA"
	BillDataPaymentTermsCia          BillDataPaymentTerms = "CIA"
	BillDataPaymentTermsUr           BillDataPaymentTerms = "UR"
	BillDataPaymentTermsNet10        BillDataPaymentTerms = "NET10"
	BillDataPaymentTermsNet20        BillDataPaymentTerms = "NET20"
	BillDataPaymentTermsNet30        BillDataPaymentTerms = "NET30"
	BillDataPaymentTermsNet45        BillDataPaymentTerms = "NET45"
	BillDataPaymentTermsNet60        BillDataPaymentTerms = "NET60"
	BillDataPaymentTermsNet90        BillDataPaymentTerms = "NET90"
	BillDataPaymentTermsEom          BillDataPaymentTerms = "EOM"
	BillDataPaymentTermsMfi          BillDataPaymentTerms = "MFI"
	BillDataPaymentTermsFiveMfi      BillDataPaymentTerms = "5MFI"
	BillDataPaymentTermsTenMfi       BillDataPaymentTerms = "10MFI"
	BillDataPaymentTermsFifteenMfi   BillDataPaymentTerms = "15MFI"
	BillDataPaymentTermsTwentyMfi    BillDataPaymentTerms = "20MFI"
	BillDataPaymentTermsTwo10Net30   BillDataPaymentTerms = "2/10NET30"
	BillDataPaymentTermsUf           BillDataPaymentTerms = "UF"
	BillDataPaymentTermsTenUf        BillDataPaymentTerms = "10UF"
	BillDataPaymentTermsTwentyUf     BillDataPaymentTerms = "20UF"
	BillDataPaymentTermsTwentyFiveUf BillDataPaymentTerms = "25UF"
	BillDataPaymentTermsFiftyUf      BillDataPaymentTerms = "50UF"
)

func NewBillDataPaymentTermsFromString(s string) (BillDataPaymentTerms, error) {
	switch s {
	case "PIA":
		return BillDataPaymentTermsPia, nil
	case "CIA":
		return BillDataPaymentTermsCia, nil
	case "UR":
		return BillDataPaymentTermsUr, nil
	case "NET10":
		return BillDataPaymentTermsNet10, nil
	case "NET20":
		return BillDataPaymentTermsNet20, nil
	case "NET30":
		return BillDataPaymentTermsNet30, nil
	case "NET45":
		return BillDataPaymentTermsNet45, nil
	case "NET60":
		return BillDataPaymentTermsNet60, nil
	case "NET90":
		return BillDataPaymentTermsNet90, nil
	case "EOM":
		return BillDataPaymentTermsEom, nil
	case "MFI":
		return BillDataPaymentTermsMfi, nil
	case "5MFI":
		return BillDataPaymentTermsFiveMfi, nil
	case "10MFI":
		return BillDataPaymentTermsTenMfi, nil
	case "15MFI":
		return BillDataPaymentTermsFifteenMfi, nil
	case "20MFI":
		return BillDataPaymentTermsTwentyMfi, nil
	case "2/10NET30":
		return BillDataPaymentTermsTwo10Net30, nil
	case "UF":
		return BillDataPaymentTermsUf, nil
	case "10UF":
		return BillDataPaymentTermsTenUf, nil
	case "20UF":
		return BillDataPaymentTermsTwentyUf, nil
	case "25UF":
		return BillDataPaymentTermsTwentyFiveUf, nil
	case "50UF":
		return BillDataPaymentTermsFiftyUf, nil
	}
	var t BillDataPaymentTerms
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BillDataPaymentTerms) Ptr() *BillDataPaymentTerms {
	return &b
}

// Array of event objects with information related to events associated to the invoice.
type BillEvents = []*GeneralEvents

// The bill's ID in Payabli. This value is automatically generated by Payabli when the bill is created.
type BillId = int64

type BillItem struct {
	// Array of tags classifying item or product.
	ItemCategories    []*string          `json:"itemCategories,omitempty" url:"itemCategories,omitempty"`
	ItemCommodityCode *ItemCommodityCode `json:"itemCommodityCode,omitempty" url:"itemCommodityCode,omitempty"`
	// Item or product price per unit.
	ItemCost        float64          `json:"itemCost" url:"itemCost"`
	ItemDescription *ItemDescription `json:"itemDescription,omitempty" url:"itemDescription,omitempty"`
	// Internal class of item or product: value '0' is only for invoices , '1' for bills and, '2' common for both.
	ItemMode        *int             `json:"itemMode,omitempty" url:"itemMode,omitempty"`
	ItemProductCode *ItemProductCode `json:"itemProductCode,omitempty" url:"itemProductCode,omitempty"`
	ItemProductName *ItemProductName `json:"itemProductName,omitempty" url:"itemProductName,omitempty"`
	// Quantity of item or product.
	ItemQty *int `json:"itemQty,omitempty" url:"itemQty,omitempty"`
	// Tax amount applied to item or product.
	ItemTaxAmount *float64 `json:"itemTaxAmount,omitempty" url:"itemTaxAmount,omitempty"`
	// Tax rate applied to item or product.
	ItemTaxRate *float64 `json:"itemTaxRate,omitempty" url:"itemTaxRate,omitempty"`
	// Total amount in item or product.
	ItemTotalAmount   *float64           `json:"itemTotalAmount,omitempty" url:"itemTotalAmount,omitempty"`
	ItemUnitOfMeasure *ItemUnitofMeasure `json:"itemUnitOfMeasure,omitempty" url:"itemUnitOfMeasure,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BillItem) GetItemCategories() []*string {
	if b == nil {
		return nil
	}
	return b.ItemCategories
}

func (b *BillItem) GetItemCommodityCode() *ItemCommodityCode {
	if b == nil {
		return nil
	}
	return b.ItemCommodityCode
}

func (b *BillItem) GetItemCost() float64 {
	if b == nil {
		return 0
	}
	return b.ItemCost
}

func (b *BillItem) GetItemDescription() *ItemDescription {
	if b == nil {
		return nil
	}
	return b.ItemDescription
}

func (b *BillItem) GetItemMode() *int {
	if b == nil {
		return nil
	}
	return b.ItemMode
}

func (b *BillItem) GetItemProductCode() *ItemProductCode {
	if b == nil {
		return nil
	}
	return b.ItemProductCode
}

func (b *BillItem) GetItemProductName() *ItemProductName {
	if b == nil {
		return nil
	}
	return b.ItemProductName
}

func (b *BillItem) GetItemQty() *int {
	if b == nil {
		return nil
	}
	return b.ItemQty
}

func (b *BillItem) GetItemTaxAmount() *float64 {
	if b == nil {
		return nil
	}
	return b.ItemTaxAmount
}

func (b *BillItem) GetItemTaxRate() *float64 {
	if b == nil {
		return nil
	}
	return b.ItemTaxRate
}

func (b *BillItem) GetItemTotalAmount() *float64 {
	if b == nil {
		return nil
	}
	return b.ItemTotalAmount
}

func (b *BillItem) GetItemUnitOfMeasure() *ItemUnitofMeasure {
	if b == nil {
		return nil
	}
	return b.ItemUnitOfMeasure
}

func (b *BillItem) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BillItem) UnmarshalJSON(data []byte) error {
	type unmarshaler BillItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BillItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BillItem) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BillPayOutData struct {
	// Bill ID in Payabli.
	BillId *int64 `json:"billId,omitempty" url:"billId,omitempty"`
	// Any comments about bill. **For managed payouts, this field has a limit of 100 characters**.
	Comments *Comments `json:"comments,omitempty" url:"comments,omitempty"`
	// Bill due date in format YYYY-MM-DD or MM/DD/YYYY.
	DueDate *Datenullable `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	// Bill date in format YYYY-MM-DD or MM/DD/YYYY.
	InvoiceDate *Datenullable `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Custom number identifying the bill. Must be unique in paypoint. **Required** for new bill and when `billId` isn't provided.
	InvoiceNumber *InvoiceNumber `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	// Net Amount owed in bill. Required when adding a bill.
	NetAmount *NetAmountstring `json:"netAmount,omitempty" url:"netAmount,omitempty"`
	// Bill discount amount.
	Discount *string `json:"discount,omitempty" url:"discount,omitempty"`
	// Description of payment terms.
	Terms            *Terms                `json:"Terms,omitempty" url:"Terms,omitempty"`
	AccountingField1 *AccountingField      `json:"AccountingField1,omitempty" url:"AccountingField1,omitempty"`
	AccountingField2 *AccountingField      `json:"AccountingField2,omitempty" url:"AccountingField2,omitempty"`
	AdditionalData   *AdditionalDataString `json:"AdditionalData,omitempty" url:"AdditionalData,omitempty"`
	// Bill image attachment. Send the bill image as Base64-encoded string, or as a publicly accessible link. For full details on using this field with a payout authorization, see [the documentation](/developers/developer-guides/pay-out-manage-payouts).
	Attachments *Attachments `json:"attachments,omitempty" url:"attachments,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BillPayOutData) GetBillId() *int64 {
	if b == nil {
		return nil
	}
	return b.BillId
}

func (b *BillPayOutData) GetComments() *Comments {
	if b == nil {
		return nil
	}
	return b.Comments
}

func (b *BillPayOutData) GetDueDate() *Datenullable {
	if b == nil {
		return nil
	}
	return b.DueDate
}

func (b *BillPayOutData) GetInvoiceDate() *Datenullable {
	if b == nil {
		return nil
	}
	return b.InvoiceDate
}

func (b *BillPayOutData) GetInvoiceNumber() *InvoiceNumber {
	if b == nil {
		return nil
	}
	return b.InvoiceNumber
}

func (b *BillPayOutData) GetNetAmount() *NetAmountstring {
	if b == nil {
		return nil
	}
	return b.NetAmount
}

func (b *BillPayOutData) GetDiscount() *string {
	if b == nil {
		return nil
	}
	return b.Discount
}

func (b *BillPayOutData) GetTerms() *Terms {
	if b == nil {
		return nil
	}
	return b.Terms
}

func (b *BillPayOutData) GetAccountingField1() *AccountingField {
	if b == nil {
		return nil
	}
	return b.AccountingField1
}

func (b *BillPayOutData) GetAccountingField2() *AccountingField {
	if b == nil {
		return nil
	}
	return b.AccountingField2
}

func (b *BillPayOutData) GetAdditionalData() *AdditionalDataString {
	if b == nil {
		return nil
	}
	return b.AdditionalData
}

func (b *BillPayOutData) GetAttachments() *Attachments {
	if b == nil {
		return nil
	}
	return b.Attachments
}

func (b *BillPayOutData) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BillPayOutData) UnmarshalJSON(data []byte) error {
	type unmarshaler BillPayOutData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BillPayOutData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BillPayOutData) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BillPayOutDataRequest struct {
	// Bill ID in Payabli.
	BillId *int64 `json:"billId,omitempty" url:"billId,omitempty"`
	// Any comments about bill. **For managed payouts, this field has a limit of 100 characters**.
	Comments *Comments `json:"comments,omitempty" url:"comments,omitempty"`
	// Bill due date in format YYYY-MM-DD or MM/DD/YYYY.
	DueDate *Datenullable `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	// Bill date in format YYYY-MM-DD or MM/DD/YYYY.
	InvoiceDate *Datenullable `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Custom number identifying the bill. Must be unique in paypoint. **Required** for new bill and when `billId` isn't provided.
	InvoiceNumber *InvoiceNumber `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	// Net Amount owed in bill. Required when adding a bill.
	NetAmount *NetAmountstring `json:"netAmount,omitempty" url:"netAmount,omitempty"`
	// Bill discount amount.
	Discount *string `json:"discount,omitempty" url:"discount,omitempty"`
	// Description of payment terms.
	Terms            *Terms                `json:"terms,omitempty" url:"terms,omitempty"`
	AccountingField1 *AccountingField      `json:"accountingField1,omitempty" url:"accountingField1,omitempty"`
	AccountingField2 *AccountingField      `json:"accountingField2,omitempty" url:"accountingField2,omitempty"`
	AdditionalData   *AdditionalDataString `json:"additionalData,omitempty" url:"additionalData,omitempty"`
	// Bill image attachment. Send the bill image as Base64-encoded string, or as a publicly accessible link. For full details on using this field with a payout authorization, see [the documentation](/developers/developer-guides/pay-out-manage-payouts).
	Attachments *Attachments `json:"attachments,omitempty" url:"attachments,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BillPayOutDataRequest) GetBillId() *int64 {
	if b == nil {
		return nil
	}
	return b.BillId
}

func (b *BillPayOutDataRequest) GetComments() *Comments {
	if b == nil {
		return nil
	}
	return b.Comments
}

func (b *BillPayOutDataRequest) GetDueDate() *Datenullable {
	if b == nil {
		return nil
	}
	return b.DueDate
}

func (b *BillPayOutDataRequest) GetInvoiceDate() *Datenullable {
	if b == nil {
		return nil
	}
	return b.InvoiceDate
}

func (b *BillPayOutDataRequest) GetInvoiceNumber() *InvoiceNumber {
	if b == nil {
		return nil
	}
	return b.InvoiceNumber
}

func (b *BillPayOutDataRequest) GetNetAmount() *NetAmountstring {
	if b == nil {
		return nil
	}
	return b.NetAmount
}

func (b *BillPayOutDataRequest) GetDiscount() *string {
	if b == nil {
		return nil
	}
	return b.Discount
}

func (b *BillPayOutDataRequest) GetTerms() *Terms {
	if b == nil {
		return nil
	}
	return b.Terms
}

func (b *BillPayOutDataRequest) GetAccountingField1() *AccountingField {
	if b == nil {
		return nil
	}
	return b.AccountingField1
}

func (b *BillPayOutDataRequest) GetAccountingField2() *AccountingField {
	if b == nil {
		return nil
	}
	return b.AccountingField2
}

func (b *BillPayOutDataRequest) GetAdditionalData() *AdditionalDataString {
	if b == nil {
		return nil
	}
	return b.AdditionalData
}

func (b *BillPayOutDataRequest) GetAttachments() *Attachments {
	if b == nil {
		return nil
	}
	return b.Attachments
}

func (b *BillPayOutDataRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BillPayOutDataRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BillPayOutDataRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BillPayOutDataRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BillPayOutDataRequest) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Additional line for the billing address.
type BillingAddressAddtlNullable = string

// Billing address.
type BillingAddressNullable = string

// Billing city.
type BillingCityNullable = string

// Billing address country.
type BillingCountryNullable = string

type BillingData struct {
	// Account number for bank account.
	AccountNumber *string `json:"accountNumber,omitempty" url:"accountNumber,omitempty"`
	// Describes whether the bank account is used for deposits or withdrawals in Payabli:
	//   - `0`: Deposit
	//   - `1`: Withdrawal
	//   - `2`: Deposit and withdrawal
	BankAccountFunction   *int                   `json:"bankAccountFunction,omitempty" url:"bankAccountFunction,omitempty"`
	BankAccountHolderName *BankAccountHolderName `json:"bankAccountHolderName,omitempty" url:"bankAccountHolderName,omitempty"`
	BankAccountHolderType *BankAccountHolderType `json:"bankAccountHolderType,omitempty" url:"bankAccountHolderType,omitempty"`
	BankName              *BankName              `json:"bankName,omitempty" url:"bankName,omitempty"`
	// The bank's ID in Payabli.
	Id             *int            `json:"id,omitempty" url:"id,omitempty"`
	RoutingAccount *RoutingAccount `json:"routingAccount,omitempty" url:"routingAccount,omitempty"`
	TypeAccount    *TypeAccount    `json:"typeAccount,omitempty" url:"typeAccount,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BillingData) GetAccountNumber() *string {
	if b == nil {
		return nil
	}
	return b.AccountNumber
}

func (b *BillingData) GetBankAccountFunction() *int {
	if b == nil {
		return nil
	}
	return b.BankAccountFunction
}

func (b *BillingData) GetBankAccountHolderName() *BankAccountHolderName {
	if b == nil {
		return nil
	}
	return b.BankAccountHolderName
}

func (b *BillingData) GetBankAccountHolderType() *BankAccountHolderType {
	if b == nil {
		return nil
	}
	return b.BankAccountHolderType
}

func (b *BillingData) GetBankName() *BankName {
	if b == nil {
		return nil
	}
	return b.BankName
}

func (b *BillingData) GetId() *int {
	if b == nil {
		return nil
	}
	return b.Id
}

func (b *BillingData) GetRoutingAccount() *RoutingAccount {
	if b == nil {
		return nil
	}
	return b.RoutingAccount
}

func (b *BillingData) GetTypeAccount() *TypeAccount {
	if b == nil {
		return nil
	}
	return b.TypeAccount
}

func (b *BillingData) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BillingData) UnmarshalJSON(data []byte) error {
	type unmarshaler BillingData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BillingData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BillingData) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BillingDataResponse struct {
	// The bank's ID in Payabli.
	Id                    int                   `json:"id" url:"id"`
	AccountId             interface{}           `json:"accountId,omitempty" url:"accountId,omitempty"`
	Nickname              string                `json:"nickname" url:"nickname"`
	BankName              BankName              `json:"bankName" url:"bankName"`
	RoutingAccount        RoutingAccount        `json:"routingAccount" url:"routingAccount"`
	AccountNumber         AccountNumber         `json:"accountNumber" url:"accountNumber"`
	TypeAccount           TypeAccount           `json:"typeAccount" url:"typeAccount"`
	BankAccountHolderName BankAccountHolderName `json:"bankAccountHolderName" url:"bankAccountHolderName"`
	BankAccountHolderType BankAccountHolderType `json:"bankAccountHolderType" url:"bankAccountHolderType"`
	// Describes whether the bank account is used for deposits or withdrawals in Payabli:
	//   - `0`: Deposit
	//   - `1`: Withdrawal
	//   - `2`: Deposit and withdrawal
	BankAccountFunction int           `json:"bankAccountFunction" url:"bankAccountFunction"`
	Verified            bool          `json:"verified" url:"verified"`
	Status              int           `json:"status" url:"status"`
	Services            []interface{} `json:"services" url:"services"`
	Default             bool          `json:"default" url:"default"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BillingDataResponse) GetId() int {
	if b == nil {
		return 0
	}
	return b.Id
}

func (b *BillingDataResponse) GetAccountId() interface{} {
	if b == nil {
		return nil
	}
	return b.AccountId
}

func (b *BillingDataResponse) GetNickname() string {
	if b == nil {
		return ""
	}
	return b.Nickname
}

func (b *BillingDataResponse) GetBankName() BankName {
	if b == nil {
		return ""
	}
	return b.BankName
}

func (b *BillingDataResponse) GetRoutingAccount() RoutingAccount {
	if b == nil {
		return ""
	}
	return b.RoutingAccount
}

func (b *BillingDataResponse) GetAccountNumber() AccountNumber {
	if b == nil {
		return ""
	}
	return b.AccountNumber
}

func (b *BillingDataResponse) GetTypeAccount() TypeAccount {
	if b == nil {
		return ""
	}
	return b.TypeAccount
}

func (b *BillingDataResponse) GetBankAccountHolderName() BankAccountHolderName {
	if b == nil {
		return ""
	}
	return b.BankAccountHolderName
}

func (b *BillingDataResponse) GetBankAccountHolderType() BankAccountHolderType {
	if b == nil {
		return ""
	}
	return b.BankAccountHolderType
}

func (b *BillingDataResponse) GetBankAccountFunction() int {
	if b == nil {
		return 0
	}
	return b.BankAccountFunction
}

func (b *BillingDataResponse) GetVerified() bool {
	if b == nil {
		return false
	}
	return b.Verified
}

func (b *BillingDataResponse) GetStatus() int {
	if b == nil {
		return 0
	}
	return b.Status
}

func (b *BillingDataResponse) GetServices() []interface{} {
	if b == nil {
		return nil
	}
	return b.Services
}

func (b *BillingDataResponse) GetDefault() bool {
	if b == nil {
		return false
	}
	return b.Default
}

func (b *BillingDataResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BillingDataResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BillingDataResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BillingDataResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BillingDataResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Billing state. Must be 2-letter state code for address in US.
type BillingStateNullable = string

// Billing address ZIP code.
type BillingZip = string

// Object containing information related to the card. This object is `null`
// unless the payment method is card. If the payment method is Apple Pay, the
// binData will be related to the DPAN (device primary account number), not
// the card connected to Apple Pay.
type BinData struct {
	// The number of characters from the beginning of the card number that
	// were matched against a Bank Identification Number (BIN) or the Card
	// Range table.
	BinMatchedLength *string `json:"binMatchedLength,omitempty" url:"binMatchedLength,omitempty"`
	// The card brand. For example, Visa, Mastercard, American Express,
	// Discover.
	BinCardBrand *string `json:"binCardBrand,omitempty" url:"binCardBrand,omitempty"`
	// The type of card: Credit or Debit.
	BinCardType *string `json:"binCardType,omitempty" url:"binCardType,omitempty"`
	// The category of the card, which indicates the card product. For example: Standard, Gold, Platinum, etc. The binCardCategory for prepaid cards is marked `PREPAID`.
	BinCardCategory *string `json:"binCardCategory,omitempty" url:"binCardCategory,omitempty"`
	// The name of the financial institution that issued the card.
	BinCardIssuer *string `json:"binCardIssuer,omitempty" url:"binCardIssuer,omitempty"`
	// The issuing financial institution's country name.
	BinCardIssuerCountry *string `json:"binCardIssuerCountry,omitempty" url:"binCardIssuerCountry,omitempty"`
	// The issuing financial institution's two-character ISO country code. See [this resource](https://www.iso.org/obp/ui/#search) for a list of codes.
	BinCardIssuerCountryCodeA2 *string `json:"binCardIssuerCountryCodeA2,omitempty" url:"binCardIssuerCountryCodeA2,omitempty"`
	// The issuing financial institution's ISO standard numeric country code. See [this resource](https://www.iso.org/obp/ui/#search) for a list of codes.
	BinCardIssuerCountryNumber *string `json:"binCardIssuerCountryNumber,omitempty" url:"binCardIssuerCountryNumber,omitempty"`
	// Indicates whether the card is regulated.
	BinCardIsRegulated *string `json:"binCardIsRegulated,omitempty" url:"binCardIsRegulated,omitempty"`
	// The use category classification for the card.
	BinCardUseCategory *string `json:"binCardUseCategory,omitempty" url:"binCardUseCategory,omitempty"`
	// The issuing financial institution's three-character ISO country code.
	// See [this resource](https://www.iso.org/obp/ui/#search) for a list of
	// codes.
	BinCardIssuerCountryCodeA3 *string `json:"binCardIssuerCountryCodeA3,omitempty" url:"binCardIssuerCountryCodeA3,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BinData) GetBinMatchedLength() *string {
	if b == nil {
		return nil
	}
	return b.BinMatchedLength
}

func (b *BinData) GetBinCardBrand() *string {
	if b == nil {
		return nil
	}
	return b.BinCardBrand
}

func (b *BinData) GetBinCardType() *string {
	if b == nil {
		return nil
	}
	return b.BinCardType
}

func (b *BinData) GetBinCardCategory() *string {
	if b == nil {
		return nil
	}
	return b.BinCardCategory
}

func (b *BinData) GetBinCardIssuer() *string {
	if b == nil {
		return nil
	}
	return b.BinCardIssuer
}

func (b *BinData) GetBinCardIssuerCountry() *string {
	if b == nil {
		return nil
	}
	return b.BinCardIssuerCountry
}

func (b *BinData) GetBinCardIssuerCountryCodeA2() *string {
	if b == nil {
		return nil
	}
	return b.BinCardIssuerCountryCodeA2
}

func (b *BinData) GetBinCardIssuerCountryNumber() *string {
	if b == nil {
		return nil
	}
	return b.BinCardIssuerCountryNumber
}

func (b *BinData) GetBinCardIsRegulated() *string {
	if b == nil {
		return nil
	}
	return b.BinCardIsRegulated
}

func (b *BinData) GetBinCardUseCategory() *string {
	if b == nil {
		return nil
	}
	return b.BinCardUseCategory
}

func (b *BinData) GetBinCardIssuerCountryCodeA3() *string {
	if b == nil {
		return nil
	}
	return b.BinCardIssuerCountryCodeA3
}

func (b *BinData) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BinData) UnmarshalJSON(data []byte) error {
	type unmarshaler BinData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BinData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BinData) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Numeric percent of volume processed in person. To pass validation, `binperson`, `binweb`, and `binphone` must total 100 together.
type Binperson = int

// Numeric percent of volume processed by phone. To pass validation, `binperson`, `binweb`, and `binphone` must total 100 together.
type Binphone = int

// Numeric percent of volume processed on web. To pass validation, `binperson`, `binweb`, and `binphone` must total 100 together.
type Binweb = int

type BoardingApplicationAttachments struct {
	// Array of objects describing files contained in the ZIP file.
	Filelist []*PairFiles `json:"filelist,omitempty" url:"filelist,omitempty"`
	// Zip file containing attachments.
	Zipfile *string `json:"zipfile,omitempty" url:"zipfile,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BoardingApplicationAttachments) GetFilelist() []*PairFiles {
	if b == nil {
		return nil
	}
	return b.Filelist
}

func (b *BoardingApplicationAttachments) GetZipfile() *string {
	if b == nil {
		return nil
	}
	return b.Zipfile
}

func (b *BoardingApplicationAttachments) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BoardingApplicationAttachments) UnmarshalJSON(data []byte) error {
	type unmarshaler BoardingApplicationAttachments
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BoardingApplicationAttachments(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BoardingApplicationAttachments) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// The Payabli-assigned ID of the boarding application linked to this paypoint.
type BoardingId = int64

// The boarding link ID. This is found at the end of the boarding link reference name. For example: `https://boarding.payabli.com/boarding/app/myorgaccountname-00091`. The ID is `91`.
type BoardingLinkId = int

// Business phone number.
type Bphone = string

// Business state.
type Bstate = string

// A summary of what the business sells in terms of goods or services.
type Bsummary = string

// Business start date. Accepted formats:
//
//   - YYYY-MM-DD
//
//   - MM/DD/YYYY
type Busstartdate = string

type ButtonElement struct {
	// Label for custom payment button
	Label string `json:"label" url:"label"`
	// Specify size of custom payment button
	Size *ButtonElementSize `json:"size,omitempty" url:"size,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *ButtonElement) GetLabel() string {
	if b == nil {
		return ""
	}
	return b.Label
}

func (b *ButtonElement) GetSize() *ButtonElementSize {
	if b == nil {
		return nil
	}
	return b.Size
}

func (b *ButtonElement) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *ButtonElement) UnmarshalJSON(data []byte) error {
	type unmarshaler ButtonElement
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = ButtonElement(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *ButtonElement) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Specify size of custom payment button
type ButtonElementSize string

const (
	ButtonElementSizeSm ButtonElementSize = "sm"
	ButtonElementSizeMd ButtonElementSize = "md"
	ButtonElementSizeLg ButtonElementSize = "lg"
)

func NewButtonElementSizeFromString(s string) (ButtonElementSize, error) {
	switch s {
	case "sm":
		return ButtonElementSizeSm, nil
	case "md":
		return ButtonElementSizeMd, nil
	case "lg":
		return ButtonElementSizeLg, nil
	}
	var t ButtonElementSize
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b ButtonElementSize) Ptr() *ButtonElementSize {
	return &b
}

// Business ZIP.
type Bzip = string

type CardSetup struct {
	// Determines whether American Express is accepted.
	AcceptAmex *bool `json:"acceptAmex,omitempty" url:"acceptAmex,omitempty"`
	// Determines whether Discover is accepted.
	AcceptDiscover *bool `json:"acceptDiscover,omitempty" url:"acceptDiscover,omitempty"`
	// Determines whether Mastercard is accepted.
	AcceptMastercard *bool `json:"acceptMastercard,omitempty" url:"acceptMastercard,omitempty"`
	// Determines whether Visa is accepted.
	AcceptVisa *bool `json:"acceptVisa,omitempty" url:"acceptVisa,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CardSetup) GetAcceptAmex() *bool {
	if c == nil {
		return nil
	}
	return c.AcceptAmex
}

func (c *CardSetup) GetAcceptDiscover() *bool {
	if c == nil {
		return nil
	}
	return c.AcceptDiscover
}

func (c *CardSetup) GetAcceptMastercard() *bool {
	if c == nil {
		return nil
	}
	return c.AcceptMastercard
}

func (c *CardSetup) GetAcceptVisa() *bool {
	if c == nil {
		return nil
	}
	return c.AcceptVisa
}

func (c *CardSetup) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardSetup) UnmarshalJSON(data []byte) error {
	type unmarshaler CardSetup
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardSetup(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardSetup) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Card Verification Value (CVV) associated with the card number. We **strongly recommend** that you include this field when using `card` as a method.
type Cardcvv = string

// Card expiration date in format MMYY or MM/YY. Required for card transactions.
type Cardexp = string

// Cardholder name.
type Cardholder = string

// The card number. Required when method is `card` and a `storedMethodId` isn't included.
type Cardnumber = string

// ZIP or postal code for the billing address of cardholder. We **strongly recommend** that you include this field when using `card` as a method.
type Cardzip = string

// The city.
type CityNullable = string

// Any comment or description.
type Comments = string

type ContactElement struct {
	// Custom content for email
	EmailLabel *string  `json:"emailLabel,omitempty" url:"emailLabel,omitempty"`
	Enabled    *Enabled `json:"enabled,omitempty" url:"enabled,omitempty"`
	// Header text for section
	Header *string `json:"header,omitempty" url:"header,omitempty"`
	Order  *Order  `json:"order,omitempty" url:"order,omitempty"`
	// Flag indicating if icons for accepted card brands will be shown
	PaymentIcons *bool `json:"paymentIcons,omitempty" url:"paymentIcons,omitempty"`
	// Custom content for phone number
	PhoneLabel *string `json:"phoneLabel,omitempty" url:"phoneLabel,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContactElement) GetEmailLabel() *string {
	if c == nil {
		return nil
	}
	return c.EmailLabel
}

func (c *ContactElement) GetEnabled() *Enabled {
	if c == nil {
		return nil
	}
	return c.Enabled
}

func (c *ContactElement) GetHeader() *string {
	if c == nil {
		return nil
	}
	return c.Header
}

func (c *ContactElement) GetOrder() *Order {
	if c == nil {
		return nil
	}
	return c.Order
}

func (c *ContactElement) GetPaymentIcons() *bool {
	if c == nil {
		return nil
	}
	return c.PaymentIcons
}

func (c *ContactElement) GetPhoneLabel() *string {
	if c == nil {
		return nil
	}
	return c.PhoneLabel
}

func (c *ContactElement) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContactElement) UnmarshalJSON(data []byte) error {
	type unmarshaler ContactElement
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContactElement(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContactElement) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Contacts struct {
	// Contact email address.
	ContactEmail *Email `json:"contactEmail,omitempty" url:"contactEmail,omitempty"`
	// Contact name.
	ContactName *string `json:"contactName,omitempty" url:"contactName,omitempty"`
	// Contact phone number.
	ContactPhone *string `json:"contactPhone,omitempty" url:"contactPhone,omitempty"`
	// Contact title.
	ContactTitle   *string               `json:"contactTitle,omitempty" url:"contactTitle,omitempty"`
	AdditionalData *AdditionalDataString `json:"additionalData,omitempty" url:"additionalData,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *Contacts) GetContactEmail() *Email {
	if c == nil {
		return nil
	}
	return c.ContactEmail
}

func (c *Contacts) GetContactName() *string {
	if c == nil {
		return nil
	}
	return c.ContactName
}

func (c *Contacts) GetContactPhone() *string {
	if c == nil {
		return nil
	}
	return c.ContactPhone
}

func (c *Contacts) GetContactTitle() *string {
	if c == nil {
		return nil
	}
	return c.ContactTitle
}

func (c *Contacts) GetAdditionalData() *AdditionalDataString {
	if c == nil {
		return nil
	}
	return c.AdditionalData
}

func (c *Contacts) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Contacts) UnmarshalJSON(data []byte) error {
	type unmarshaler Contacts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Contacts(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *Contacts) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// List of contacts.
type ContactsField = []*Contacts

type ContactsResponse struct {
	// Contact email address.
	ContactEmail *Email `json:"ContactEmail,omitempty" url:"ContactEmail,omitempty"`
	// Contact name.
	ContactName *string `json:"ContactName,omitempty" url:"ContactName,omitempty"`
	// Contact phone number.
	ContactPhone *string `json:"ContactPhone,omitempty" url:"ContactPhone,omitempty"`
	// Contact title.
	ContactTitle *string `json:"ContactTitle,omitempty" url:"ContactTitle,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContactsResponse) GetContactEmail() *Email {
	if c == nil {
		return nil
	}
	return c.ContactEmail
}

func (c *ContactsResponse) GetContactName() *string {
	if c == nil {
		return nil
	}
	return c.ContactName
}

func (c *ContactsResponse) GetContactPhone() *string {
	if c == nil {
		return nil
	}
	return c.ContactPhone
}

func (c *ContactsResponse) GetContactTitle() *string {
	if c == nil {
		return nil
	}
	return c.ContactTitle
}

func (c *ContactsResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContactsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ContactsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContactsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContactsResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The country in ISO-3166-1 alpha 2 format. See https://en.wikipedia.org/wiki/ISO_3166-1 for reference.
type CountryNullable = string

// Timestamp of when record was created, in UTC.
type CreatedAt = time.Time

// Data about a single customer.
type CustomerData struct {
	CustomerNumber *CustomerNumberNullable `json:"customerNumber,omitempty" url:"customerNumber,omitempty"`
	// Customer username for customer portal
	CustomerUsername *string `json:"customerUsername,omitempty" url:"customerUsername,omitempty"`
	// Customer password for customer portal
	CustomerPsw    *string         `json:"customerPsw,omitempty" url:"customerPsw,omitempty"`
	CustomerStatus *CustomerStatus `json:"customerStatus,omitempty" url:"customerStatus,omitempty"`
	// Company name
	Company *string `json:"company,omitempty" url:"company,omitempty"`
	// Customer first name
	Firstname *string `json:"firstname,omitempty" url:"firstname,omitempty"`
	// Customer last name
	Lastname *string `json:"lastname,omitempty" url:"lastname,omitempty"`
	// Customer phone number
	Phone *string `json:"phone,omitempty" url:"phone,omitempty"`
	// Customer email address.
	Email *Email `json:"email,omitempty" url:"email,omitempty"`
	// Customer address
	Address *string `json:"address,omitempty" url:"address,omitempty"`
	// Additional customer address
	Address1 *string `json:"address1,omitempty" url:"address1,omitempty"`
	// Customer city
	City *string `json:"city,omitempty" url:"city,omitempty"`
	// Customer State
	State *string `json:"state,omitempty" url:"state,omitempty"`
	// Customer postal code
	Zip *string `json:"zip,omitempty" url:"zip,omitempty"`
	// Customer country in ISO-3166-1 alpha 2 format. See https://en.wikipedia.org/wiki/ISO_3166-1 for reference.
	Country          *string                    `json:"country,omitempty" url:"country,omitempty"`
	ShippingAddress  *Shippingaddress           `json:"shippingAddress,omitempty" url:"shippingAddress,omitempty"`
	ShippingAddress1 *Shippingaddressadditional `json:"shippingAddress1,omitempty" url:"shippingAddress1,omitempty"`
	ShippingCity     *Shippingcity              `json:"shippingCity,omitempty" url:"shippingCity,omitempty"`
	ShippingState    *Shippingstate             `json:"shippingState,omitempty" url:"shippingState,omitempty"`
	ShippingZip      *Shippingzip               `json:"shippingZip,omitempty" url:"shippingZip,omitempty"`
	ShippingCountry  *Shippingcountry           `json:"shippingCountry,omitempty" url:"shippingCountry,omitempty"`
	// Customer balance.
	Balance  *float64  `json:"balance,omitempty" url:"balance,omitempty"`
	TimeZone *Timezone `json:"timeZone,omitempty" url:"timeZone,omitempty"`
	// Additional Custom fields in format "key":"value".
	AdditionalFields map[string]*string `json:"additionalFields,omitempty" url:"additionalFields,omitempty"`
	IdentifierFields *Identifierfields  `json:"identifierFields,omitempty" url:"identifierFields,omitempty"`
	CreatedAt        *CreatedAt         `json:"createdAt,omitempty" url:"createdAt,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerData) GetCustomerNumber() *CustomerNumberNullable {
	if c == nil {
		return nil
	}
	return c.CustomerNumber
}

func (c *CustomerData) GetCustomerUsername() *string {
	if c == nil {
		return nil
	}
	return c.CustomerUsername
}

func (c *CustomerData) GetCustomerPsw() *string {
	if c == nil {
		return nil
	}
	return c.CustomerPsw
}

func (c *CustomerData) GetCustomerStatus() *CustomerStatus {
	if c == nil {
		return nil
	}
	return c.CustomerStatus
}

func (c *CustomerData) GetCompany() *string {
	if c == nil {
		return nil
	}
	return c.Company
}

func (c *CustomerData) GetFirstname() *string {
	if c == nil {
		return nil
	}
	return c.Firstname
}

func (c *CustomerData) GetLastname() *string {
	if c == nil {
		return nil
	}
	return c.Lastname
}

func (c *CustomerData) GetPhone() *string {
	if c == nil {
		return nil
	}
	return c.Phone
}

func (c *CustomerData) GetEmail() *Email {
	if c == nil {
		return nil
	}
	return c.Email
}

func (c *CustomerData) GetAddress() *string {
	if c == nil {
		return nil
	}
	return c.Address
}

func (c *CustomerData) GetAddress1() *string {
	if c == nil {
		return nil
	}
	return c.Address1
}

func (c *CustomerData) GetCity() *string {
	if c == nil {
		return nil
	}
	return c.City
}

func (c *CustomerData) GetState() *string {
	if c == nil {
		return nil
	}
	return c.State
}

func (c *CustomerData) GetZip() *string {
	if c == nil {
		return nil
	}
	return c.Zip
}

func (c *CustomerData) GetCountry() *string {
	if c == nil {
		return nil
	}
	return c.Country
}

func (c *CustomerData) GetShippingAddress() *Shippingaddress {
	if c == nil {
		return nil
	}
	return c.ShippingAddress
}

func (c *CustomerData) GetShippingAddress1() *Shippingaddressadditional {
	if c == nil {
		return nil
	}
	return c.ShippingAddress1
}

func (c *CustomerData) GetShippingCity() *Shippingcity {
	if c == nil {
		return nil
	}
	return c.ShippingCity
}

func (c *CustomerData) GetShippingState() *Shippingstate {
	if c == nil {
		return nil
	}
	return c.ShippingState
}

func (c *CustomerData) GetShippingZip() *Shippingzip {
	if c == nil {
		return nil
	}
	return c.ShippingZip
}

func (c *CustomerData) GetShippingCountry() *Shippingcountry {
	if c == nil {
		return nil
	}
	return c.ShippingCountry
}

func (c *CustomerData) GetBalance() *float64 {
	if c == nil {
		return nil
	}
	return c.Balance
}

func (c *CustomerData) GetTimeZone() *Timezone {
	if c == nil {
		return nil
	}
	return c.TimeZone
}

func (c *CustomerData) GetAdditionalFields() map[string]*string {
	if c == nil {
		return nil
	}
	return c.AdditionalFields
}

func (c *CustomerData) GetIdentifierFields() *Identifierfields {
	if c == nil {
		return nil
	}
	return c.IdentifierFields
}

func (c *CustomerData) GetCreatedAt() *CreatedAt {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CustomerData) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerData) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerData) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The Payabli-generated unique ID for the customer.
type CustomerId = int64

// User-provided unique identifier for the customer. This is typically the customer ID from your own system.
type CustomerNumberNullable = string

type CustomerQueryRecords struct {
	CustomerId     *CustomerId             `json:"customerId,omitempty" url:"customerId,omitempty"`
	CustomerNumber *CustomerNumberNullable `json:"customerNumber,omitempty" url:"customerNumber,omitempty"`
	// Username for customer.
	CustomerUsername *string         `json:"customerUsername,omitempty" url:"customerUsername,omitempty"`
	CustomerStatus   *CustomerStatus `json:"customerStatus,omitempty" url:"customerStatus,omitempty"`
	// Company name.
	Company *string `json:"Company,omitempty" url:"Company,omitempty"`
	// Customer first name.
	Firstname *string `json:"Firstname,omitempty" url:"Firstname,omitempty"`
	// Customer last name.
	Lastname *string `json:"Lastname,omitempty" url:"Lastname,omitempty"`
	// Customer phone number.
	Phone *string `json:"Phone,omitempty" url:"Phone,omitempty"`
	// Customer email address.
	Email *Email `json:"Email,omitempty" url:"Email,omitempty"`
	// Customer address.
	Address *string `json:"Address,omitempty" url:"Address,omitempty"`
	// Additional line for customer address.
	Address1 *string `json:"Address1,omitempty" url:"Address1,omitempty"`
	// Customer city.
	City *string `json:"City,omitempty" url:"City,omitempty"`
	// Customer state.
	State *string `json:"State,omitempty" url:"State,omitempty"`
	// Customer postal code.
	Zip *string `json:"Zip,omitempty" url:"Zip,omitempty"`
	// Customer country.
	Country          *string                    `json:"Country,omitempty" url:"Country,omitempty"`
	ShippingAddress  *Shippingaddress           `json:"ShippingAddress,omitempty" url:"ShippingAddress,omitempty"`
	ShippingAddress1 *Shippingaddressadditional `json:"ShippingAddress1,omitempty" url:"ShippingAddress1,omitempty"`
	ShippingCity     *Shippingcity              `json:"ShippingCity,omitempty" url:"ShippingCity,omitempty"`
	ShippingState    *Shippingstate             `json:"ShippingState,omitempty" url:"ShippingState,omitempty"`
	ShippingZip      *Shippingzip               `json:"ShippingZip,omitempty" url:"ShippingZip,omitempty"`
	ShippingCountry  *Shippingcountry           `json:"ShippingCountry,omitempty" url:"ShippingCountry,omitempty"`
	// Customer balance.
	Balance  *float64  `json:"Balance,omitempty" url:"Balance,omitempty"`
	TimeZone *Timezone `json:"TimeZone,omitempty" url:"TimeZone,omitempty"`
	Mfa      *Mfa      `json:"MFA,omitempty" url:"MFA,omitempty"`
	MfaMode  *MfaMode  `json:"MFAMode,omitempty" url:"MFAMode,omitempty"`
	// Social network linked to customer. Possible values:
	//
	// - `facebook`
	//
	// - `google`
	//
	// - `twitter`
	//
	// - `microsoft`
	SnProvider *string `json:"snProvider,omitempty" url:"snProvider,omitempty"`
	// Identifier or token for customer in linked social network.
	SnIdentifier *string `json:"snIdentifier,omitempty" url:"snIdentifier,omitempty"`
	// Additional data provided by the social network related to the customer.
	SnData *string `json:"snData,omitempty" url:"snData,omitempty"`
	// Date and time of last update.
	LastUpdated *time.Time `json:"LastUpdated,omitempty" url:"LastUpdated,omitempty"`
	// Date and time created.
	Created *time.Time `json:"Created,omitempty" url:"Created,omitempty"`
	// List of additional custom fields in format key:value.
	AdditionalFields map[string]*string `json:"AdditionalFields,omitempty" url:"AdditionalFields,omitempty"`
	IdentifierFields *Identifierfields  `json:"IdentifierFields,omitempty" url:"IdentifierFields,omitempty"`
	// List of subscriptions associated to the customer.
	Subscriptions []*SubscriptionQueryRecords `json:"Subscriptions,omitempty" url:"Subscriptions,omitempty"`
	// List of payment methods associated to the customer.
	StoredMethods   []*MethodQueryRecords  `json:"StoredMethods,omitempty" url:"StoredMethods,omitempty"`
	CustomerSummary *CustomerSummaryRecord `json:"customerSummary,omitempty" url:"customerSummary,omitempty"`
	// Paypoint legal name.
	PaypointLegalname *Legalname `json:"PaypointLegalname,omitempty" url:"PaypointLegalname,omitempty"`
	// Paypoint DBA name.
	PaypointDbaname    *Dbaname                             `json:"PaypointDbaname,omitempty" url:"PaypointDbaname,omitempty"`
	ParentOrgName      *OrgParentName                       `json:"ParentOrgName,omitempty" url:"ParentOrgName,omitempty"`
	ParentOrgId        *OrgParentId                         `json:"ParentOrgId,omitempty" url:"ParentOrgId,omitempty"`
	PaypointEntryname  *Entrypointfield                     `json:"PaypointEntryname,omitempty" url:"PaypointEntryname,omitempty"`
	Pageidentifier     *PageIdentifier                      `json:"pageidentifier,omitempty" url:"pageidentifier,omitempty"`
	ExternalPaypointId *ExternalPaypointId                  `json:"externalPaypointID,omitempty" url:"externalPaypointID,omitempty"`
	CustomerConsent    *CustomerQueryRecordsCustomerConsent `json:"customerConsent,omitempty" url:"customerConsent,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerQueryRecords) GetCustomerId() *CustomerId {
	if c == nil {
		return nil
	}
	return c.CustomerId
}

func (c *CustomerQueryRecords) GetCustomerNumber() *CustomerNumberNullable {
	if c == nil {
		return nil
	}
	return c.CustomerNumber
}

func (c *CustomerQueryRecords) GetCustomerUsername() *string {
	if c == nil {
		return nil
	}
	return c.CustomerUsername
}

func (c *CustomerQueryRecords) GetCustomerStatus() *CustomerStatus {
	if c == nil {
		return nil
	}
	return c.CustomerStatus
}

func (c *CustomerQueryRecords) GetCompany() *string {
	if c == nil {
		return nil
	}
	return c.Company
}

func (c *CustomerQueryRecords) GetFirstname() *string {
	if c == nil {
		return nil
	}
	return c.Firstname
}

func (c *CustomerQueryRecords) GetLastname() *string {
	if c == nil {
		return nil
	}
	return c.Lastname
}

func (c *CustomerQueryRecords) GetPhone() *string {
	if c == nil {
		return nil
	}
	return c.Phone
}

func (c *CustomerQueryRecords) GetEmail() *Email {
	if c == nil {
		return nil
	}
	return c.Email
}

func (c *CustomerQueryRecords) GetAddress() *string {
	if c == nil {
		return nil
	}
	return c.Address
}

func (c *CustomerQueryRecords) GetAddress1() *string {
	if c == nil {
		return nil
	}
	return c.Address1
}

func (c *CustomerQueryRecords) GetCity() *string {
	if c == nil {
		return nil
	}
	return c.City
}

func (c *CustomerQueryRecords) GetState() *string {
	if c == nil {
		return nil
	}
	return c.State
}

func (c *CustomerQueryRecords) GetZip() *string {
	if c == nil {
		return nil
	}
	return c.Zip
}

func (c *CustomerQueryRecords) GetCountry() *string {
	if c == nil {
		return nil
	}
	return c.Country
}

func (c *CustomerQueryRecords) GetShippingAddress() *Shippingaddress {
	if c == nil {
		return nil
	}
	return c.ShippingAddress
}

func (c *CustomerQueryRecords) GetShippingAddress1() *Shippingaddressadditional {
	if c == nil {
		return nil
	}
	return c.ShippingAddress1
}

func (c *CustomerQueryRecords) GetShippingCity() *Shippingcity {
	if c == nil {
		return nil
	}
	return c.ShippingCity
}

func (c *CustomerQueryRecords) GetShippingState() *Shippingstate {
	if c == nil {
		return nil
	}
	return c.ShippingState
}

func (c *CustomerQueryRecords) GetShippingZip() *Shippingzip {
	if c == nil {
		return nil
	}
	return c.ShippingZip
}

func (c *CustomerQueryRecords) GetShippingCountry() *Shippingcountry {
	if c == nil {
		return nil
	}
	return c.ShippingCountry
}

func (c *CustomerQueryRecords) GetBalance() *float64 {
	if c == nil {
		return nil
	}
	return c.Balance
}

func (c *CustomerQueryRecords) GetTimeZone() *Timezone {
	if c == nil {
		return nil
	}
	return c.TimeZone
}

func (c *CustomerQueryRecords) GetMfa() *Mfa {
	if c == nil {
		return nil
	}
	return c.Mfa
}

func (c *CustomerQueryRecords) GetMfaMode() *MfaMode {
	if c == nil {
		return nil
	}
	return c.MfaMode
}

func (c *CustomerQueryRecords) GetSnProvider() *string {
	if c == nil {
		return nil
	}
	return c.SnProvider
}

func (c *CustomerQueryRecords) GetSnIdentifier() *string {
	if c == nil {
		return nil
	}
	return c.SnIdentifier
}

func (c *CustomerQueryRecords) GetSnData() *string {
	if c == nil {
		return nil
	}
	return c.SnData
}

func (c *CustomerQueryRecords) GetLastUpdated() *time.Time {
	if c == nil {
		return nil
	}
	return c.LastUpdated
}

func (c *CustomerQueryRecords) GetCreated() *time.Time {
	if c == nil {
		return nil
	}
	return c.Created
}

func (c *CustomerQueryRecords) GetAdditionalFields() map[string]*string {
	if c == nil {
		return nil
	}
	return c.AdditionalFields
}

func (c *CustomerQueryRecords) GetIdentifierFields() *Identifierfields {
	if c == nil {
		return nil
	}
	return c.IdentifierFields
}

func (c *CustomerQueryRecords) GetSubscriptions() []*SubscriptionQueryRecords {
	if c == nil {
		return nil
	}
	return c.Subscriptions
}

func (c *CustomerQueryRecords) GetStoredMethods() []*MethodQueryRecords {
	if c == nil {
		return nil
	}
	return c.StoredMethods
}

func (c *CustomerQueryRecords) GetCustomerSummary() *CustomerSummaryRecord {
	if c == nil {
		return nil
	}
	return c.CustomerSummary
}

func (c *CustomerQueryRecords) GetPaypointLegalname() *Legalname {
	if c == nil {
		return nil
	}
	return c.PaypointLegalname
}

func (c *CustomerQueryRecords) GetPaypointDbaname() *Dbaname {
	if c == nil {
		return nil
	}
	return c.PaypointDbaname
}

func (c *CustomerQueryRecords) GetParentOrgName() *OrgParentName {
	if c == nil {
		return nil
	}
	return c.ParentOrgName
}

func (c *CustomerQueryRecords) GetParentOrgId() *OrgParentId {
	if c == nil {
		return nil
	}
	return c.ParentOrgId
}

func (c *CustomerQueryRecords) GetPaypointEntryname() *Entrypointfield {
	if c == nil {
		return nil
	}
	return c.PaypointEntryname
}

func (c *CustomerQueryRecords) GetPageidentifier() *PageIdentifier {
	if c == nil {
		return nil
	}
	return c.Pageidentifier
}

func (c *CustomerQueryRecords) GetExternalPaypointId() *ExternalPaypointId {
	if c == nil {
		return nil
	}
	return c.ExternalPaypointId
}

func (c *CustomerQueryRecords) GetCustomerConsent() *CustomerQueryRecordsCustomerConsent {
	if c == nil {
		return nil
	}
	return c.CustomerConsent
}

func (c *CustomerQueryRecords) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerQueryRecords) UnmarshalJSON(data []byte) error {
	type embed CustomerQueryRecords
	var unmarshaler = struct {
		embed
		LastUpdated *internal.DateTime `json:"LastUpdated,omitempty"`
		Created     *internal.DateTime `json:"Created,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CustomerQueryRecords(unmarshaler.embed)
	c.LastUpdated = unmarshaler.LastUpdated.TimePtr()
	c.Created = unmarshaler.Created.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerQueryRecords) MarshalJSON() ([]byte, error) {
	type embed CustomerQueryRecords
	var marshaler = struct {
		embed
		LastUpdated *internal.DateTime `json:"LastUpdated,omitempty"`
		Created     *internal.DateTime `json:"Created,omitempty"`
	}{
		embed:       embed(*c),
		LastUpdated: internal.NewOptionalDateTime(c.LastUpdated),
		Created:     internal.NewOptionalDateTime(c.Created),
	}
	return json.Marshal(marshaler)
}

func (c *CustomerQueryRecords) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomerQueryRecordsCustomerConsent struct {
	// Describes the customer's email communications consent status.
	ECommunication *CustomerQueryRecordsCustomerConsentECommunication `json:"eCommunication,omitempty" url:"eCommunication,omitempty"`
	// Describes the customer's SMS communications consent status.
	Sms *CustomerQueryRecordsCustomerConsentSms `json:"sms,omitempty" url:"sms,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerQueryRecordsCustomerConsent) GetECommunication() *CustomerQueryRecordsCustomerConsentECommunication {
	if c == nil {
		return nil
	}
	return c.ECommunication
}

func (c *CustomerQueryRecordsCustomerConsent) GetSms() *CustomerQueryRecordsCustomerConsentSms {
	if c == nil {
		return nil
	}
	return c.Sms
}

func (c *CustomerQueryRecordsCustomerConsent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerQueryRecordsCustomerConsent) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerQueryRecordsCustomerConsent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerQueryRecordsCustomerConsent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerQueryRecordsCustomerConsent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Describes the customer's email communications consent status.
type CustomerQueryRecordsCustomerConsentECommunication struct {
	Status    *OptinStatus  `json:"status,omitempty" url:"status,omitempty"`
	UpdatedAt *LastModified `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerQueryRecordsCustomerConsentECommunication) GetStatus() *OptinStatus {
	if c == nil {
		return nil
	}
	return c.Status
}

func (c *CustomerQueryRecordsCustomerConsentECommunication) GetUpdatedAt() *LastModified {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *CustomerQueryRecordsCustomerConsentECommunication) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerQueryRecordsCustomerConsentECommunication) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerQueryRecordsCustomerConsentECommunication
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerQueryRecordsCustomerConsentECommunication(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerQueryRecordsCustomerConsentECommunication) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Describes the customer's SMS communications consent status.
type CustomerQueryRecordsCustomerConsentSms struct {
	Status    *OptinStatus  `json:"status,omitempty" url:"status,omitempty"`
	UpdatedAt *LastModified `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerQueryRecordsCustomerConsentSms) GetStatus() *OptinStatus {
	if c == nil {
		return nil
	}
	return c.Status
}

func (c *CustomerQueryRecordsCustomerConsentSms) GetUpdatedAt() *LastModified {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *CustomerQueryRecordsCustomerConsentSms) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerQueryRecordsCustomerConsentSms) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerQueryRecordsCustomerConsentSms
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerQueryRecordsCustomerConsentSms(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerQueryRecordsCustomerConsentSms) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Customer Status.
// Possible values:
// - `-99` Deleted
// - `0` Inactive
// - `1` Active
// - `85` Locked (typically due to multiple failed login attempts)
type CustomerStatus = int

type CustomerSummaryRecord struct {
	// Number total of transactions or payments
	NumberofTransactions *int `json:"numberofTransactions,omitempty" url:"numberofTransactions,omitempty"`
	// List of more recent 5 transactions belonging to the customer
	RecentTransactions []*TransactionQueryRecords `json:"recentTransactions,omitempty" url:"recentTransactions,omitempty"`
	// Total amount in transactions
	TotalAmountTransactions *float64 `json:"totalAmountTransactions,omitempty" url:"totalAmountTransactions,omitempty"`
	// Total net amount in transactions
	TotalNetAmountTransactions *float64 `json:"totalNetAmountTransactions,omitempty" url:"totalNetAmountTransactions,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerSummaryRecord) GetNumberofTransactions() *int {
	if c == nil {
		return nil
	}
	return c.NumberofTransactions
}

func (c *CustomerSummaryRecord) GetRecentTransactions() []*TransactionQueryRecords {
	if c == nil {
		return nil
	}
	return c.RecentTransactions
}

func (c *CustomerSummaryRecord) GetTotalAmountTransactions() *float64 {
	if c == nil {
		return nil
	}
	return c.TotalAmountTransactions
}

func (c *CustomerSummaryRecord) GetTotalNetAmountTransactions() *float64 {
	if c == nil {
		return nil
	}
	return c.TotalNetAmountTransactions
}

func (c *CustomerSummaryRecord) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerSummaryRecord) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerSummaryRecord
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerSummaryRecord(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerSummaryRecord) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Payabli-generated unique ID of customer owner of transaction. Returns `0` if the transaction wasn't assigned to an existing customer or no customer was created.
type Customeridtrans = int64

// Text code describing the result for CVV validation (applies only for card transactions).
type Cvvresponsetext = string

// Date in YYYY-MM-DD format.
type Datenullable = *time.Time

// Timestamp for operation, in UTC.
type DatetimeNullable = *time.Time

// The alternate or common name that this business is doing business under usually referred to as a DBA name.
type Dbaname = string

// When the method is a card, this field displays card brand. When the method is ACH, this field displays the account type for ACH (checking or savings).
type Descriptor = string

// Identifier of registered cloud device used in the transaction.
type Device = string

// Discount applied to the invoice.
type Discount = *float64

type DisplayProperty struct {
	// When `true`, the field is displayed on the receipt.
	Display *bool `json:"display,omitempty" url:"display,omitempty"`
	// This field is unused.
	Fixed *bool `json:"Fixed,omitempty" url:"Fixed,omitempty"`
	// The field's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DisplayProperty) GetDisplay() *bool {
	if d == nil {
		return nil
	}
	return d.Display
}

func (d *DisplayProperty) GetFixed() *bool {
	if d == nil {
		return nil
	}
	return d.Fixed
}

func (d *DisplayProperty) GetName() *string {
	if d == nil {
		return nil
	}
	return d.Name
}

func (d *DisplayProperty) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisplayProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler DisplayProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisplayProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisplayProperty) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DocumentsRef struct {
	// Array of objects describing files contained in the ZIP file.
	Filelist []*PairFiles `json:"filelist,omitempty" url:"filelist,omitempty"`
	// Zip file containing attachments.
	Zipfile *string `json:"zipfile,omitempty" url:"zipfile,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DocumentsRef) GetFilelist() []*PairFiles {
	if d == nil {
		return nil
	}
	return d.Filelist
}

func (d *DocumentsRef) GetZipfile() *string {
	if d == nil {
		return nil
	}
	return d.Zipfile
}

func (d *DocumentsRef) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DocumentsRef) UnmarshalJSON(data []byte) error {
	type unmarshaler DocumentsRef
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DocumentsRef(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DocumentsRef) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The domain. For example: `subdomain.domain.com` or `domain.com`. Must be  public. Can't be `localhost`, hidden by a VPN, or protected by a password.
type DomainName = string

// Duty amount.
type DutyAmount = *float64

// Business EIN or tax ID. This value is masked in API responses, for example `XXXX6789`.
type Ein = string

type Element struct {
	Enabled *Enabled `json:"enabled,omitempty" url:"enabled,omitempty"`
	Order   *Order   `json:"order,omitempty" url:"order,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *Element) GetEnabled() *Enabled {
	if e == nil {
		return nil
	}
	return e.Enabled
}

func (e *Element) GetOrder() *Order {
	if e == nil {
		return nil
	}
	return e.Order
}

func (e *Element) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Element) UnmarshalJSON(data []byte) error {
	type unmarshaler Element
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Element(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *Element) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Email address.
type Email = string

// Toggles whether the section or element is enabled.
type Enabled = bool

// Enrollment status of vendor in payables program.
type EnrollmentStatus = *string

// The entity's ID in Payabli. If the entity is a paypoint, this is the
// paypoint ID. If the entity is an organization, this is the organization
// ID.
type EntityId = int64

// The entity's entrypoint identifier. [Learn more](/api-reference/api-overview#entrypoint-vs-entry)
type Entry = string

type EntryAttributes = string

// If applicable, the internal reference ID to the payment page capturing the payment.
type EntrypageId = int64

// The entrypoint identifier.
type Entrypointfield = string

// Export format for file downloads. When specified, returns data as a file instead of JSON.
type ExportFormat string

const (
	// Comma-separated values file
	ExportFormatCsv ExportFormat = "csv"
	// Excel spreadsheet file
	ExportFormatXlsx ExportFormat = "xlsx"
)

func NewExportFormatFromString(s string) (ExportFormat, error) {
	switch s {
	case "csv":
		return ExportFormatCsv, nil
	case "xlsx":
		return ExportFormatXlsx, nil
	}
	var t ExportFormat
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e ExportFormat) Ptr() *ExportFormat {
	return &e
}

// A custom identifier for the paypoint, if applicable. Like `entrypoint` is the Payabli identifier for the merchant, `externalPaypointId` is a custom field you can use to include the merchant's ID from your own systems.
type ExternalPaypointId = string

// Processor information, used for troubleshooting and reporting. This field contains a value when the API key used to make the request has management permissions.
type ExternalProcessorInformation = string

// Service fee or sub-charge applied.
type FeeAmount = float64

// A file containing the response data, in the format specified in the request.
type File = map[string]interface{}

// Contains details about a file. Max upload size is 30 MB.
type FileContent struct {
	// Content of file, Base64-encoded. Ignored if furl is specified. Max upload size is 30 MB.
	FContent *string `json:"fContent,omitempty" url:"fContent,omitempty"`
	// The name of the attached file.
	Filename *string `json:"filename,omitempty" url:"filename,omitempty"`
	// The MIME type of the file (if content is provided)
	Ftype *FileContentFtype `json:"ftype,omitempty" url:"ftype,omitempty"`
	// Optional URL provided to show or download the file remotely
	Furl *string `json:"furl,omitempty" url:"furl,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FileContent) GetFContent() *string {
	if f == nil {
		return nil
	}
	return f.FContent
}

func (f *FileContent) GetFilename() *string {
	if f == nil {
		return nil
	}
	return f.Filename
}

func (f *FileContent) GetFtype() *FileContentFtype {
	if f == nil {
		return nil
	}
	return f.Ftype
}

func (f *FileContent) GetFurl() *string {
	if f == nil {
		return nil
	}
	return f.Furl
}

func (f *FileContent) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileContent) UnmarshalJSON(data []byte) error {
	type unmarshaler FileContent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileContent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileContent) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The MIME type of the file (if content is provided)
type FileContentFtype string

const (
	FileContentFtypePdf  FileContentFtype = "pdf"
	FileContentFtypeDoc  FileContentFtype = "doc"
	FileContentFtypeDocx FileContentFtype = "docx"
	FileContentFtypeJpg  FileContentFtype = "jpg"
	FileContentFtypeJpeg FileContentFtype = "jpeg"
	FileContentFtypePng  FileContentFtype = "png"
	FileContentFtypeGif  FileContentFtype = "gif"
	FileContentFtypeTxt  FileContentFtype = "txt"
)

func NewFileContentFtypeFromString(s string) (FileContentFtype, error) {
	switch s {
	case "pdf":
		return FileContentFtypePdf, nil
	case "doc":
		return FileContentFtypeDoc, nil
	case "docx":
		return FileContentFtypeDocx, nil
	case "jpg":
		return FileContentFtypeJpg, nil
	case "jpeg":
		return FileContentFtypeJpeg, nil
	case "png":
		return FileContentFtypePng, nil
	case "gif":
		return FileContentFtypeGif, nil
	case "txt":
		return FileContentFtypeTxt, nil
	}
	var t FileContentFtype
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FileContentFtype) Ptr() *FileContentFtype {
	return &f
}

type Finishtype struct {
	// Flag to enable 'calendar' option
	Calendar *bool `json:"calendar,omitempty" url:"calendar,omitempty"`
	// Flag to enable 'untilCancelled' option
	UntilCancelled *bool `json:"untilCancelled,omitempty" url:"untilCancelled,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *Finishtype) GetCalendar() *bool {
	if f == nil {
		return nil
	}
	return f.Calendar
}

func (f *Finishtype) GetUntilCancelled() *bool {
	if f == nil {
		return nil
	}
	return f.UntilCancelled
}

func (f *Finishtype) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *Finishtype) UnmarshalJSON(data []byte) error {
	type unmarshaler Finishtype
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = Finishtype(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *Finishtype) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// When `true`, the request creates a new customer record, regardless of whether customer identifiers match an existing customer. Defaults to `false`.
type ForceCustomerCreation = *bool

// Freight/shipping amount.
type FreightAmount = *float64

// Frequency for operation.
type Frequency string

const (
	FrequencyOneTime      Frequency = "one-time"
	FrequencyWeekly       Frequency = "weekly"
	FrequencyEvery2Weeks  Frequency = "every2weeks"
	FrequencyEvery6Months Frequency = "every6months"
	FrequencyMonthly      Frequency = "monthly"
	FrequencyEvery3Months Frequency = "every3months"
	FrequencyAnnually     Frequency = "annually"
)

func NewFrequencyFromString(s string) (Frequency, error) {
	switch s {
	case "one-time":
		return FrequencyOneTime, nil
	case "weekly":
		return FrequencyWeekly, nil
	case "every2weeks":
		return FrequencyEvery2Weeks, nil
	case "every6months":
		return FrequencyEvery6Months, nil
	case "monthly":
		return FrequencyMonthly, nil
	case "every3months":
		return FrequencyEvery3Months, nil
	case "annually":
		return FrequencyAnnually, nil
	}
	var t Frequency
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f Frequency) Ptr() *Frequency {
	return &f
}

type FrequencyList struct {
	// Enable or disable frequency
	Annually *bool `json:"annually,omitempty" url:"annually,omitempty"`
	// Enable or disable frequency
	Every2Weeks *bool `json:"every2Weeks,omitempty" url:"every2Weeks,omitempty"`
	// Enable or disable frequency
	Every3Months *bool `json:"every3Months,omitempty" url:"every3Months,omitempty"`
	// Enable or disable frequency
	Every6Months *bool `json:"every6Months,omitempty" url:"every6Months,omitempty"`
	// Enable or disable frequency
	Monthly *bool `json:"monthly,omitempty" url:"monthly,omitempty"`
	// Enable or disable frequency
	OneTime *bool `json:"one-time,omitempty" url:"one-time,omitempty"`
	// Enable or disable frequency
	Weekly *bool `json:"weekly,omitempty" url:"weekly,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FrequencyList) GetAnnually() *bool {
	if f == nil {
		return nil
	}
	return f.Annually
}

func (f *FrequencyList) GetEvery2Weeks() *bool {
	if f == nil {
		return nil
	}
	return f.Every2Weeks
}

func (f *FrequencyList) GetEvery3Months() *bool {
	if f == nil {
		return nil
	}
	return f.Every3Months
}

func (f *FrequencyList) GetEvery6Months() *bool {
	if f == nil {
		return nil
	}
	return f.Every6Months
}

func (f *FrequencyList) GetMonthly() *bool {
	if f == nil {
		return nil
	}
	return f.Monthly
}

func (f *FrequencyList) GetOneTime() *bool {
	if f == nil {
		return nil
	}
	return f.OneTime
}

func (f *FrequencyList) GetWeekly() *bool {
	if f == nil {
		return nil
	}
	return f.Weekly
}

func (f *FrequencyList) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FrequencyList) UnmarshalJSON(data []byte) error {
	type unmarshaler FrequencyList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FrequencyList(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FrequencyList) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Frequency for notification.
// For notifications using the *email* ,*sms*, or *web* `method`, the allowed values are:
//   - `untilcancelled`
//   - `one-time`
//
// For notifications using the *report-email* or *report-web* `method`, the allowed values are:
//   - `one-time`
//   - `daily`
//   - `weekly`
//   - `biweekly`
//   - `monthly`
//   - `quarterly`
//   - `semiannually`
//   - `annually`
type Frequencynotification string

const (
	FrequencynotificationOneTime        Frequencynotification = "one-time"
	FrequencynotificationDaily          Frequencynotification = "daily"
	FrequencynotificationWeekly         Frequencynotification = "weekly"
	FrequencynotificationBiweekly       Frequencynotification = "biweekly"
	FrequencynotificationMonthly        Frequencynotification = "monthly"
	FrequencynotificationQuarterly      Frequencynotification = "quarterly"
	FrequencynotificationSemiannually   Frequencynotification = "semiannually"
	FrequencynotificationAnnually       Frequencynotification = "annually"
	FrequencynotificationUntilcancelled Frequencynotification = "untilcancelled"
)

func NewFrequencynotificationFromString(s string) (Frequencynotification, error) {
	switch s {
	case "one-time":
		return FrequencynotificationOneTime, nil
	case "daily":
		return FrequencynotificationDaily, nil
	case "weekly":
		return FrequencynotificationWeekly, nil
	case "biweekly":
		return FrequencynotificationBiweekly, nil
	case "monthly":
		return FrequencynotificationMonthly, nil
	case "quarterly":
		return FrequencynotificationQuarterly, nil
	case "semiannually":
		return FrequencynotificationSemiannually, nil
	case "annually":
		return FrequencynotificationAnnually, nil
	case "untilcancelled":
		return FrequencynotificationUntilcancelled, nil
	}
	var t Frequencynotification
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f Frequencynotification) Ptr() *Frequencynotification {
	return &f
}

// Gateway used to process the transaction.
type Gatewayfield = string

type GeneralEvents struct {
	// Event description.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Event timestamp, in UTC.
	EventTime *time.Time `json:"eventTime,omitempty" url:"eventTime,omitempty"`
	// Extra data.
	ExtraData map[string]interface{} `json:"extraData,omitempty" url:"extraData,omitempty"`
	// Reference data.
	RefData *string `json:"refData,omitempty" url:"refData,omitempty"`
	// The event source.
	Source *Source `json:"source,omitempty" url:"source,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GeneralEvents) GetDescription() *string {
	if g == nil {
		return nil
	}
	return g.Description
}

func (g *GeneralEvents) GetEventTime() *time.Time {
	if g == nil {
		return nil
	}
	return g.EventTime
}

func (g *GeneralEvents) GetExtraData() map[string]interface{} {
	if g == nil {
		return nil
	}
	return g.ExtraData
}

func (g *GeneralEvents) GetRefData() *string {
	if g == nil {
		return nil
	}
	return g.RefData
}

func (g *GeneralEvents) GetSource() *Source {
	if g == nil {
		return nil
	}
	return g.Source
}

func (g *GeneralEvents) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeneralEvents) UnmarshalJSON(data []byte) error {
	type embed GeneralEvents
	var unmarshaler = struct {
		embed
		EventTime *internal.DateTime `json:"eventTime,omitempty"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GeneralEvents(unmarshaler.embed)
	g.EventTime = unmarshaler.EventTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GeneralEvents) MarshalJSON() ([]byte, error) {
	type embed GeneralEvents
	var marshaler = struct {
		embed
		EventTime *internal.DateTime `json:"eventTime,omitempty"`
	}{
		embed:     embed(*g),
		EventTime: internal.NewOptionalDateTime(g.EventTime),
	}
	return json.Marshal(marshaler)
}

func (g *GeneralEvents) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type HasVcardTransactions = *bool

type HeaderElement struct {
	Enabled *Enabled `json:"enabled,omitempty" url:"enabled,omitempty"`
	// Header text for section
	Header *string `json:"header,omitempty" url:"header,omitempty"`
	Order  *Order  `json:"order,omitempty" url:"order,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (h *HeaderElement) GetEnabled() *Enabled {
	if h == nil {
		return nil
	}
	return h.Enabled
}

func (h *HeaderElement) GetHeader() *string {
	if h == nil {
		return nil
	}
	return h.Header
}

func (h *HeaderElement) GetOrder() *Order {
	if h == nil {
		return nil
	}
	return h.Order
}

func (h *HeaderElement) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HeaderElement) UnmarshalJSON(data []byte) error {
	type unmarshaler HeaderElement
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HeaderElement(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	h.rawJSON = json.RawMessage(data)
	return nil
}

func (h *HeaderElement) String() string {
	if len(h.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(h.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// High ticket amount.
type Highticketamt = *float64

// Account holder name for the method.
type Holdername = string

// _Optional but recommended_ A unique ID that you can include to prevent duplicating objects or transactions in the case that a request is sent more than once. This key isn't generated in Payabli, you must generate it yourself. This key persists for 2 minutes. After 2 minutes, you can reuse the key if needed.
type IdempotencyKey = string

// List of fields acting as customer identifiers, to be used instead of CustomerNumber.
type Identifierfields = []*string

// Paypoint ID.
type Idpaypoint = int64

// **Strongly recommended** The cardholder-initiated transaction (CIT) or merchant-initiated transaction (MIT) indicator for the transaction. If you don't specify a value, Payabli defaults to `merchant`.
//
// Available values:
//
//   - `payor`: For cardholder-initiated transactions
//
//   - `merchant`: For merchant-initiated transactions
//
//     See [Understanding CIT and MIT Indicators](/guides/money-in-cit-mit) for more information.
type Initiator = string

type Instrument struct {
	AchAccount     Achaccount              `json:"achAccount" url:"achAccount"`
	AchRouting     Achrouting              `json:"achRouting" url:"achRouting"`
	BillingAddress *BillingAddressNullable `json:"billingAddress,omitempty" url:"billingAddress,omitempty"`
	BillingCity    *BillingCityNullable    `json:"billingCity,omitempty" url:"billingCity,omitempty"`
	BillingCountry *BillingCountryNullable `json:"billingCountry,omitempty" url:"billingCountry,omitempty"`
	BillingState   *BillingStateNullable   `json:"billingState,omitempty" url:"billingState,omitempty"`
	BillingZip     *BillingZip             `json:"billingZip,omitempty" url:"billingZip,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *Instrument) GetAchAccount() Achaccount {
	if i == nil {
		return ""
	}
	return i.AchAccount
}

func (i *Instrument) GetAchRouting() Achrouting {
	if i == nil {
		return ""
	}
	return i.AchRouting
}

func (i *Instrument) GetBillingAddress() *BillingAddressNullable {
	if i == nil {
		return nil
	}
	return i.BillingAddress
}

func (i *Instrument) GetBillingCity() *BillingCityNullable {
	if i == nil {
		return nil
	}
	return i.BillingCity
}

func (i *Instrument) GetBillingCountry() *BillingCountryNullable {
	if i == nil {
		return nil
	}
	return i.BillingCountry
}

func (i *Instrument) GetBillingState() *BillingStateNullable {
	if i == nil {
		return nil
	}
	return i.BillingState
}

func (i *Instrument) GetBillingZip() *BillingZip {
	if i == nil {
		return nil
	}
	return i.BillingZip
}

func (i *Instrument) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *Instrument) UnmarshalJSON(data []byte) error {
	type unmarshaler Instrument
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = Instrument(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *Instrument) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Internal identifier for global vendor account.
type InternalReferenceId = int64

// Invoice total amount.
type InvoiceAmount = float64

type InvoiceElement struct {
	Enabled *Enabled `json:"enabled,omitempty" url:"enabled,omitempty"`
	// Link to invoice
	InvoiceLink *LabelElement `json:"invoiceLink,omitempty" url:"invoiceLink,omitempty"`
	Order       *Order        `json:"order,omitempty" url:"order,omitempty"`
	// Link to view invoice details
	ViewInvoiceDetails *LabelElement `json:"viewInvoiceDetails,omitempty" url:"viewInvoiceDetails,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceElement) GetEnabled() *Enabled {
	if i == nil {
		return nil
	}
	return i.Enabled
}

func (i *InvoiceElement) GetInvoiceLink() *LabelElement {
	if i == nil {
		return nil
	}
	return i.InvoiceLink
}

func (i *InvoiceElement) GetOrder() *Order {
	if i == nil {
		return nil
	}
	return i.Order
}

func (i *InvoiceElement) GetViewInvoiceDetails() *LabelElement {
	if i == nil {
		return nil
	}
	return i.ViewInvoiceDetails
}

func (i *InvoiceElement) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceElement) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceElement
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceElement(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceElement) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Custom number identifying the bill or invoice. Must be unique in paypoint.
type InvoiceNumber = string

// Type of invoice. Only `0` for one-time invoices is currently supported.
type InvoiceType = int

// Status for invoice.
//
// The accepted status values are:
//
//   - 0 draft
//   - 1 active
//   - 2 partially paid
//   - 4 paid/complete
//   - 99 cancelled
type Invoicestatus = int

// *Recommended*. The customer's IP address. This field is used to help prevent fraudulent transactions, and Payabli strongly recommends including this data.
type IpAddress = string

// When `true`, the service is enabled.
type IsEnabled = bool

// When `true`, indicates that this is the organization's root template.
type IsRoot = *bool

// Indicates if the payout transaction is processed as Same Day ACH. This
// is only applicable for ACH transactions.
type IsSameDayAch = *bool

// Boolean indicating whether the operation was successful. A `true` value indicates success. A `false` value indicates failure.
type IsSuccess = bool

// Item or product commodity code. Max length of 250 characters.
type ItemCommodityCode = string

// Item or product description. Max length of 250 characters.
type ItemDescription = string

// Item or product code. Max length of 250 characters.
type ItemProductCode = string

// Item or product name. Max length of 250 characters.
type ItemProductName = string

// Unit of measurement. Max length of 100 characters.
type ItemUnitofMeasure = string

// The cascade process ID.
type JobId = string

// The cascade process status. Available values:
//   - `in_progress`
//   - `completed`
//   - `failed`
type JobStatus = string

type KeyValue struct {
	// Key name.
	Key      *string   `json:"key,omitempty" url:"key,omitempty"`
	ReadOnly *ReadOnly `json:"readOnly,omitempty" url:"readOnly,omitempty"`
	// Key value.
	Value *string `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KeyValue) GetKey() *string {
	if k == nil {
		return nil
	}
	return k.Key
}

func (k *KeyValue) GetReadOnly() *ReadOnly {
	if k == nil {
		return nil
	}
	return k.ReadOnly
}

func (k *KeyValue) GetValue() *string {
	if k == nil {
		return nil
	}
	return k.Value
}

func (k *KeyValue) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KeyValue) UnmarshalJSON(data []byte) error {
	type unmarshaler KeyValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*k = KeyValue(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KeyValue) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

type KeyValueDuo struct {
	// Key name.
	Key *string `json:"key,omitempty" url:"key,omitempty"`
	// Key value.
	Value *string `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KeyValueDuo) GetKey() *string {
	if k == nil {
		return nil
	}
	return k.Key
}

func (k *KeyValueDuo) GetValue() *string {
	if k == nil {
		return nil
	}
	return k.Value
}

func (k *KeyValueDuo) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KeyValueDuo) UnmarshalJSON(data []byte) error {
	type unmarshaler KeyValueDuo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*k = KeyValueDuo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KeyValueDuo) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

type LabelElement struct {
	Enabled *Enabled `json:"enabled,omitempty" url:"enabled,omitempty"`
	// Label to display for section or element
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	Order *Order  `json:"order,omitempty" url:"order,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LabelElement) GetEnabled() *Enabled {
	if l == nil {
		return nil
	}
	return l.Enabled
}

func (l *LabelElement) GetLabel() *string {
	if l == nil {
		return nil
	}
	return l.Label
}

func (l *LabelElement) GetOrder() *Order {
	if l == nil {
		return nil
	}
	return l.Order
}

func (l *LabelElement) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LabelElement) UnmarshalJSON(data []byte) error {
	type unmarshaler LabelElement
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LabelElement(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LabelElement) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The user's locale for PartnerHub and PayHub localization. Supported values:
//   - `en`
//   - `es`
type Language = string

// Timestamp of when record was last updated, in UTC.
type LastModified = *time.Time

// Business legal name.
type Legalname = string

// Business license ID or state ID number.
type License = string

// Business license issuing state or province.
type Licensestate = string

// A location code used to identify the vendor's location.
type LocationCode = string

// The business's mailing address.
type Maddress = string

// Additional line for the business's mailing address.
type Maddress1 = string

// Masked card or bank account used in transaction. In the case of Apple Pay, this is a masked DPAN (device primary account number).
type Maskedaccount = string

// Business Merchant Category Code (MCC). [This resource](https://github.com/greggles/mcc-codes/blob/main/mcc_codes.csv) lists MCC codes.
type Mcc = string

// The business's mail city.
type Mcity = string

// Business mailing country.
type Mcountry = string

type MethodElement struct {
	// Flag indicating if all allowed payment methods will be pre-selected.
	AllMethodsChecked *bool    `json:"allMethodsChecked,omitempty" url:"allMethodsChecked,omitempty"`
	Enabled           *Enabled `json:"enabled,omitempty" url:"enabled,omitempty"`
	// Header text for section
	Header  *string      `json:"header,omitempty" url:"header,omitempty"`
	Methods *MethodsList `json:"methods,omitempty" url:"methods,omitempty"`
	Order   *Order       `json:"order,omitempty" url:"order,omitempty"`
	// Settings for wallet payment methods.
	Settings *MethodElementSettings `json:"settings,omitempty" url:"settings,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MethodElement) GetAllMethodsChecked() *bool {
	if m == nil {
		return nil
	}
	return m.AllMethodsChecked
}

func (m *MethodElement) GetEnabled() *Enabled {
	if m == nil {
		return nil
	}
	return m.Enabled
}

func (m *MethodElement) GetHeader() *string {
	if m == nil {
		return nil
	}
	return m.Header
}

func (m *MethodElement) GetMethods() *MethodsList {
	if m == nil {
		return nil
	}
	return m.Methods
}

func (m *MethodElement) GetOrder() *Order {
	if m == nil {
		return nil
	}
	return m.Order
}

func (m *MethodElement) GetSettings() *MethodElementSettings {
	if m == nil {
		return nil
	}
	return m.Settings
}

func (m *MethodElement) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MethodElement) UnmarshalJSON(data []byte) error {
	type unmarshaler MethodElement
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MethodElement(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MethodElement) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Settings for wallet payment methods.
type MethodElementSettings struct {
	ApplePay *MethodElementSettingsApplePay `json:"applePay,omitempty" url:"applePay,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MethodElementSettings) GetApplePay() *MethodElementSettingsApplePay {
	if m == nil {
		return nil
	}
	return m.ApplePay
}

func (m *MethodElementSettings) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MethodElementSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler MethodElementSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MethodElementSettings(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MethodElementSettings) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MethodElementSettingsApplePay struct {
	// The Apple Pay button style. See [Apple Pay Button Style](/developers/developer-guides/hosted-payment-page-apple-pay#param-applepay-button-style) for more information.
	ButtonStyle *MethodElementSettingsApplePayButtonStyle `json:"buttonStyle,omitempty" url:"buttonStyle,omitempty"`
	// The text on Apple Pay button. See [Apple Pay Button Type](/developers/developer-guides/hosted-payment-page-apple-pay#param-applepay-button-type) for more information.
	ButtonType *MethodElementSettingsApplePayButtonType `json:"buttonType,omitempty" url:"buttonType,omitempty"`
	// The Apple Pay button locale. See [Apple Pay Button Language](/developers/developer-guides/hosted-payment-page-apple-pay#param-applepay-language) for more information.
	Language *MethodElementSettingsApplePayLanguage `json:"language,omitempty" url:"language,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MethodElementSettingsApplePay) GetButtonStyle() *MethodElementSettingsApplePayButtonStyle {
	if m == nil {
		return nil
	}
	return m.ButtonStyle
}

func (m *MethodElementSettingsApplePay) GetButtonType() *MethodElementSettingsApplePayButtonType {
	if m == nil {
		return nil
	}
	return m.ButtonType
}

func (m *MethodElementSettingsApplePay) GetLanguage() *MethodElementSettingsApplePayLanguage {
	if m == nil {
		return nil
	}
	return m.Language
}

func (m *MethodElementSettingsApplePay) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MethodElementSettingsApplePay) UnmarshalJSON(data []byte) error {
	type unmarshaler MethodElementSettingsApplePay
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MethodElementSettingsApplePay(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MethodElementSettingsApplePay) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// The Apple Pay button style. See [Apple Pay Button Style](/developers/developer-guides/hosted-payment-page-apple-pay#param-applepay-button-style) for more information.
type MethodElementSettingsApplePayButtonStyle string

const (
	MethodElementSettingsApplePayButtonStyleBlack        MethodElementSettingsApplePayButtonStyle = "black"
	MethodElementSettingsApplePayButtonStyleWhiteOutline MethodElementSettingsApplePayButtonStyle = "white-outline"
	MethodElementSettingsApplePayButtonStyleWhite        MethodElementSettingsApplePayButtonStyle = "white"
)

func NewMethodElementSettingsApplePayButtonStyleFromString(s string) (MethodElementSettingsApplePayButtonStyle, error) {
	switch s {
	case "black":
		return MethodElementSettingsApplePayButtonStyleBlack, nil
	case "white-outline":
		return MethodElementSettingsApplePayButtonStyleWhiteOutline, nil
	case "white":
		return MethodElementSettingsApplePayButtonStyleWhite, nil
	}
	var t MethodElementSettingsApplePayButtonStyle
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MethodElementSettingsApplePayButtonStyle) Ptr() *MethodElementSettingsApplePayButtonStyle {
	return &m
}

// The text on Apple Pay button. See [Apple Pay Button Type](/developers/developer-guides/hosted-payment-page-apple-pay#param-applepay-button-type) for more information.
type MethodElementSettingsApplePayButtonType string

const (
	MethodElementSettingsApplePayButtonTypePlain      MethodElementSettingsApplePayButtonType = "plain"
	MethodElementSettingsApplePayButtonTypeBuy        MethodElementSettingsApplePayButtonType = "buy"
	MethodElementSettingsApplePayButtonTypeDonate     MethodElementSettingsApplePayButtonType = "donate"
	MethodElementSettingsApplePayButtonTypeCheckOut   MethodElementSettingsApplePayButtonType = "check-out"
	MethodElementSettingsApplePayButtonTypeBook       MethodElementSettingsApplePayButtonType = "book"
	MethodElementSettingsApplePayButtonTypeContinue   MethodElementSettingsApplePayButtonType = "continue"
	MethodElementSettingsApplePayButtonTypeTopUp      MethodElementSettingsApplePayButtonType = "top-up"
	MethodElementSettingsApplePayButtonTypeOrder      MethodElementSettingsApplePayButtonType = "order"
	MethodElementSettingsApplePayButtonTypeRent       MethodElementSettingsApplePayButtonType = "rent"
	MethodElementSettingsApplePayButtonTypeSupport    MethodElementSettingsApplePayButtonType = "support"
	MethodElementSettingsApplePayButtonTypeContribute MethodElementSettingsApplePayButtonType = "contribute"
	MethodElementSettingsApplePayButtonTypeTip        MethodElementSettingsApplePayButtonType = "tip"
	MethodElementSettingsApplePayButtonTypePay        MethodElementSettingsApplePayButtonType = "pay"
)

func NewMethodElementSettingsApplePayButtonTypeFromString(s string) (MethodElementSettingsApplePayButtonType, error) {
	switch s {
	case "plain":
		return MethodElementSettingsApplePayButtonTypePlain, nil
	case "buy":
		return MethodElementSettingsApplePayButtonTypeBuy, nil
	case "donate":
		return MethodElementSettingsApplePayButtonTypeDonate, nil
	case "check-out":
		return MethodElementSettingsApplePayButtonTypeCheckOut, nil
	case "book":
		return MethodElementSettingsApplePayButtonTypeBook, nil
	case "continue":
		return MethodElementSettingsApplePayButtonTypeContinue, nil
	case "top-up":
		return MethodElementSettingsApplePayButtonTypeTopUp, nil
	case "order":
		return MethodElementSettingsApplePayButtonTypeOrder, nil
	case "rent":
		return MethodElementSettingsApplePayButtonTypeRent, nil
	case "support":
		return MethodElementSettingsApplePayButtonTypeSupport, nil
	case "contribute":
		return MethodElementSettingsApplePayButtonTypeContribute, nil
	case "tip":
		return MethodElementSettingsApplePayButtonTypeTip, nil
	case "pay":
		return MethodElementSettingsApplePayButtonTypePay, nil
	}
	var t MethodElementSettingsApplePayButtonType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MethodElementSettingsApplePayButtonType) Ptr() *MethodElementSettingsApplePayButtonType {
	return &m
}

// The Apple Pay button locale. See [Apple Pay Button Language](/developers/developer-guides/hosted-payment-page-apple-pay#param-applepay-language) for more information.
type MethodElementSettingsApplePayLanguage string

const (
	MethodElementSettingsApplePayLanguageEnUs MethodElementSettingsApplePayLanguage = "en-US"
	MethodElementSettingsApplePayLanguageArAb MethodElementSettingsApplePayLanguage = "ar-AB"
	MethodElementSettingsApplePayLanguageCaEs MethodElementSettingsApplePayLanguage = "ca-ES"
	MethodElementSettingsApplePayLanguageZhCn MethodElementSettingsApplePayLanguage = "zh-CN"
	MethodElementSettingsApplePayLanguageZhHk MethodElementSettingsApplePayLanguage = "zh-HK"
	MethodElementSettingsApplePayLanguageZhTw MethodElementSettingsApplePayLanguage = "zh-TW"
	MethodElementSettingsApplePayLanguageHrHr MethodElementSettingsApplePayLanguage = "hr-HR"
	MethodElementSettingsApplePayLanguageCsCz MethodElementSettingsApplePayLanguage = "cs-CZ"
	MethodElementSettingsApplePayLanguageDaDk MethodElementSettingsApplePayLanguage = "da-DK"
	MethodElementSettingsApplePayLanguageDeDe MethodElementSettingsApplePayLanguage = "de-DE"
	MethodElementSettingsApplePayLanguageNlNl MethodElementSettingsApplePayLanguage = "nl-NL"
	MethodElementSettingsApplePayLanguageEnAu MethodElementSettingsApplePayLanguage = "en-AU"
	MethodElementSettingsApplePayLanguageEnGb MethodElementSettingsApplePayLanguage = "en-GB"
	MethodElementSettingsApplePayLanguageFiFi MethodElementSettingsApplePayLanguage = "fi-FI"
	MethodElementSettingsApplePayLanguageFrCa MethodElementSettingsApplePayLanguage = "fr-CA"
	MethodElementSettingsApplePayLanguageFrFr MethodElementSettingsApplePayLanguage = "fr-FR"
	MethodElementSettingsApplePayLanguageElGr MethodElementSettingsApplePayLanguage = "el-GR"
	MethodElementSettingsApplePayLanguageHeIl MethodElementSettingsApplePayLanguage = "he-IL"
	MethodElementSettingsApplePayLanguageHiIn MethodElementSettingsApplePayLanguage = "hi-IN"
	MethodElementSettingsApplePayLanguageHuHu MethodElementSettingsApplePayLanguage = "hu-HU"
	MethodElementSettingsApplePayLanguageIdId MethodElementSettingsApplePayLanguage = "id-ID"
	MethodElementSettingsApplePayLanguageItIt MethodElementSettingsApplePayLanguage = "it-IT"
	MethodElementSettingsApplePayLanguageJaJp MethodElementSettingsApplePayLanguage = "ja-JP"
	MethodElementSettingsApplePayLanguageKoKr MethodElementSettingsApplePayLanguage = "ko-KR"
	MethodElementSettingsApplePayLanguageMsMy MethodElementSettingsApplePayLanguage = "ms-MY"
	MethodElementSettingsApplePayLanguageNbNo MethodElementSettingsApplePayLanguage = "nb-NO"
	MethodElementSettingsApplePayLanguagePlPl MethodElementSettingsApplePayLanguage = "pl-PL"
	MethodElementSettingsApplePayLanguagePtBr MethodElementSettingsApplePayLanguage = "pt-BR"
	MethodElementSettingsApplePayLanguagePtPt MethodElementSettingsApplePayLanguage = "pt-PT"
	MethodElementSettingsApplePayLanguageRoRo MethodElementSettingsApplePayLanguage = "ro-RO"
	MethodElementSettingsApplePayLanguageRuRu MethodElementSettingsApplePayLanguage = "ru-RU"
	MethodElementSettingsApplePayLanguageSkSk MethodElementSettingsApplePayLanguage = "sk-SK"
	MethodElementSettingsApplePayLanguageEsMx MethodElementSettingsApplePayLanguage = "es-MX"
	MethodElementSettingsApplePayLanguageEsEs MethodElementSettingsApplePayLanguage = "es-ES"
	MethodElementSettingsApplePayLanguageSvSe MethodElementSettingsApplePayLanguage = "sv-SE"
	MethodElementSettingsApplePayLanguageThTh MethodElementSettingsApplePayLanguage = "th-TH"
	MethodElementSettingsApplePayLanguageTrTr MethodElementSettingsApplePayLanguage = "tr-TR"
	MethodElementSettingsApplePayLanguageUkUa MethodElementSettingsApplePayLanguage = "uk-UA"
	MethodElementSettingsApplePayLanguageViVn MethodElementSettingsApplePayLanguage = "vi-VN"
)

func NewMethodElementSettingsApplePayLanguageFromString(s string) (MethodElementSettingsApplePayLanguage, error) {
	switch s {
	case "en-US":
		return MethodElementSettingsApplePayLanguageEnUs, nil
	case "ar-AB":
		return MethodElementSettingsApplePayLanguageArAb, nil
	case "ca-ES":
		return MethodElementSettingsApplePayLanguageCaEs, nil
	case "zh-CN":
		return MethodElementSettingsApplePayLanguageZhCn, nil
	case "zh-HK":
		return MethodElementSettingsApplePayLanguageZhHk, nil
	case "zh-TW":
		return MethodElementSettingsApplePayLanguageZhTw, nil
	case "hr-HR":
		return MethodElementSettingsApplePayLanguageHrHr, nil
	case "cs-CZ":
		return MethodElementSettingsApplePayLanguageCsCz, nil
	case "da-DK":
		return MethodElementSettingsApplePayLanguageDaDk, nil
	case "de-DE":
		return MethodElementSettingsApplePayLanguageDeDe, nil
	case "nl-NL":
		return MethodElementSettingsApplePayLanguageNlNl, nil
	case "en-AU":
		return MethodElementSettingsApplePayLanguageEnAu, nil
	case "en-GB":
		return MethodElementSettingsApplePayLanguageEnGb, nil
	case "fi-FI":
		return MethodElementSettingsApplePayLanguageFiFi, nil
	case "fr-CA":
		return MethodElementSettingsApplePayLanguageFrCa, nil
	case "fr-FR":
		return MethodElementSettingsApplePayLanguageFrFr, nil
	case "el-GR":
		return MethodElementSettingsApplePayLanguageElGr, nil
	case "he-IL":
		return MethodElementSettingsApplePayLanguageHeIl, nil
	case "hi-IN":
		return MethodElementSettingsApplePayLanguageHiIn, nil
	case "hu-HU":
		return MethodElementSettingsApplePayLanguageHuHu, nil
	case "id-ID":
		return MethodElementSettingsApplePayLanguageIdId, nil
	case "it-IT":
		return MethodElementSettingsApplePayLanguageItIt, nil
	case "ja-JP":
		return MethodElementSettingsApplePayLanguageJaJp, nil
	case "ko-KR":
		return MethodElementSettingsApplePayLanguageKoKr, nil
	case "ms-MY":
		return MethodElementSettingsApplePayLanguageMsMy, nil
	case "nb-NO":
		return MethodElementSettingsApplePayLanguageNbNo, nil
	case "pl-PL":
		return MethodElementSettingsApplePayLanguagePlPl, nil
	case "pt-BR":
		return MethodElementSettingsApplePayLanguagePtBr, nil
	case "pt-PT":
		return MethodElementSettingsApplePayLanguagePtPt, nil
	case "ro-RO":
		return MethodElementSettingsApplePayLanguageRoRo, nil
	case "ru-RU":
		return MethodElementSettingsApplePayLanguageRuRu, nil
	case "sk-SK":
		return MethodElementSettingsApplePayLanguageSkSk, nil
	case "es-MX":
		return MethodElementSettingsApplePayLanguageEsMx, nil
	case "es-ES":
		return MethodElementSettingsApplePayLanguageEsEs, nil
	case "sv-SE":
		return MethodElementSettingsApplePayLanguageSvSe, nil
	case "th-TH":
		return MethodElementSettingsApplePayLanguageThTh, nil
	case "tr-TR":
		return MethodElementSettingsApplePayLanguageTrTr, nil
	case "uk-UA":
		return MethodElementSettingsApplePayLanguageUkUa, nil
	case "vi-VN":
		return MethodElementSettingsApplePayLanguageViVn, nil
	}
	var t MethodElementSettingsApplePayLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MethodElementSettingsApplePayLanguage) Ptr() *MethodElementSettingsApplePayLanguage {
	return &m
}

type MethodQueryRecords struct {
	// The bank identification number (BIN). Null when method is ACH.
	Bin        *string     `json:"bin,omitempty" url:"bin,omitempty"`
	BinData    *BinData    `json:"binData,omitempty" url:"binData,omitempty"`
	Descriptor *Descriptor `json:"descriptor,omitempty" url:"descriptor,omitempty"`
	// Expiration date associated to the method (only for card) in format MMYY.
	ExpDate    *string     `json:"expDate,omitempty" url:"expDate,omitempty"`
	HolderName *Holdername `json:"holderName,omitempty" url:"holderName,omitempty"`
	// Method internal ID
	IdPmethod *string `json:"idPmethod,omitempty" url:"idPmethod,omitempty"`
	// Date of last update
	LastUpdated   *LastModified  `json:"lastUpdated,omitempty" url:"lastUpdated,omitempty"`
	MaskedAccount *Maskedaccount `json:"maskedAccount,omitempty" url:"maskedAccount,omitempty"`
	// Type of payment vehicle: **ach** or **card**
	Method *string `json:"method,omitempty" url:"method,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MethodQueryRecords) GetBin() *string {
	if m == nil {
		return nil
	}
	return m.Bin
}

func (m *MethodQueryRecords) GetBinData() *BinData {
	if m == nil {
		return nil
	}
	return m.BinData
}

func (m *MethodQueryRecords) GetDescriptor() *Descriptor {
	if m == nil {
		return nil
	}
	return m.Descriptor
}

func (m *MethodQueryRecords) GetExpDate() *string {
	if m == nil {
		return nil
	}
	return m.ExpDate
}

func (m *MethodQueryRecords) GetHolderName() *Holdername {
	if m == nil {
		return nil
	}
	return m.HolderName
}

func (m *MethodQueryRecords) GetIdPmethod() *string {
	if m == nil {
		return nil
	}
	return m.IdPmethod
}

func (m *MethodQueryRecords) GetLastUpdated() *LastModified {
	if m == nil {
		return nil
	}
	return m.LastUpdated
}

func (m *MethodQueryRecords) GetMaskedAccount() *Maskedaccount {
	if m == nil {
		return nil
	}
	return m.MaskedAccount
}

func (m *MethodQueryRecords) GetMethod() *string {
	if m == nil {
		return nil
	}
	return m.Method
}

func (m *MethodQueryRecords) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MethodQueryRecords) UnmarshalJSON(data []byte) error {
	type unmarshaler MethodQueryRecords
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MethodQueryRecords(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MethodQueryRecords) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// The stored method's identifier (sometimes referred to as 'token') in Payabli. When `null`, the method wasn't created, or doesn't exist, depending on the operation performed.
type MethodReferenceId = string

// Method to use to send the notification to the target.
type Methodnotification string

const (
	MethodnotificationEmail       Methodnotification = "email"
	MethodnotificationSms         Methodnotification = "sms"
	MethodnotificationWeb         Methodnotification = "web"
	MethodnotificationReportEmail Methodnotification = "report-email"
	MethodnotificationReportWeb   Methodnotification = "report-web"
)

func NewMethodnotificationFromString(s string) (Methodnotification, error) {
	switch s {
	case "email":
		return MethodnotificationEmail, nil
	case "sms":
		return MethodnotificationSms, nil
	case "web":
		return MethodnotificationWeb, nil
	case "report-email":
		return MethodnotificationReportEmail, nil
	case "report-web":
		return MethodnotificationReportWeb, nil
	}
	var t Methodnotification
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m Methodnotification) Ptr() *Methodnotification {
	return &m
}

type MethodsList struct {
	// When `true`, American Express is accepted.
	Amex *bool `json:"amex,omitempty" url:"amex,omitempty"`
	// When `true`, Apple Pay is accepted.
	ApplePay *bool `json:"applePay,omitempty" url:"applePay,omitempty"`
	// When `true`, Google Pay is accepted.
	GooglePay *bool `json:"googlePay,omitempty" url:"googlePay,omitempty"`
	// When `true`, Discover is accepted.
	Discover *bool `json:"discover,omitempty" url:"discover,omitempty"`
	// When `true`, ACH is accepted.
	ECheck *bool `json:"eCheck,omitempty" url:"eCheck,omitempty"`
	// When `true`, Mastercard is accepted.
	Mastercard *bool `json:"mastercard,omitempty" url:"mastercard,omitempty"`
	// When `true`, Visa is accepted.
	Visa *bool `json:"visa,omitempty" url:"visa,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MethodsList) GetAmex() *bool {
	if m == nil {
		return nil
	}
	return m.Amex
}

func (m *MethodsList) GetApplePay() *bool {
	if m == nil {
		return nil
	}
	return m.ApplePay
}

func (m *MethodsList) GetGooglePay() *bool {
	if m == nil {
		return nil
	}
	return m.GooglePay
}

func (m *MethodsList) GetDiscover() *bool {
	if m == nil {
		return nil
	}
	return m.Discover
}

func (m *MethodsList) GetECheck() *bool {
	if m == nil {
		return nil
	}
	return m.ECheck
}

func (m *MethodsList) GetMastercard() *bool {
	if m == nil {
		return nil
	}
	return m.Mastercard
}

func (m *MethodsList) GetVisa() *bool {
	if m == nil {
		return nil
	}
	return m.Visa
}

func (m *MethodsList) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MethodsList) UnmarshalJSON(data []byte) error {
	type unmarshaler MethodsList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MethodsList(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MethodsList) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// When `true`, multi-factor authentication (MFA) is enabled.
type Mfa = *bool

type MfaMode = int

// The business's mailing address state.
type Mstate = string

// Business mailing ZIP.
type Mzip = string

type NameUser = string

// Net Amount owed in bill. Required when adding a bill.
type NetAmountstring = string

// Net amount.
type Netamountnullable = *float64

type NoteElement struct {
	Enabled *Enabled `json:"enabled,omitempty" url:"enabled,omitempty"`
	// Header text for section
	Header *string `json:"header,omitempty" url:"header,omitempty"`
	Order  *Order  `json:"order,omitempty" url:"order,omitempty"`
	// Placeholder text for input field
	Placeholder *string `json:"placeholder,omitempty" url:"placeholder,omitempty"`
	// Pre-populated value for input field
	Value *string `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NoteElement) GetEnabled() *Enabled {
	if n == nil {
		return nil
	}
	return n.Enabled
}

func (n *NoteElement) GetHeader() *string {
	if n == nil {
		return nil
	}
	return n.Header
}

func (n *NoteElement) GetOrder() *Order {
	if n == nil {
		return nil
	}
	return n.Order
}

func (n *NoteElement) GetPlaceholder() *string {
	if n == nil {
		return nil
	}
	return n.Placeholder
}

func (n *NoteElement) GetValue() *string {
	if n == nil {
		return nil
	}
	return n.Value
}

func (n *NoteElement) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NoteElement) UnmarshalJSON(data []byte) error {
	type unmarshaler NoteElement
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NoteElement(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NoteElement) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NotificationContent struct {
	// The notification's event name.
	EventType *NotificationContentEventType `json:"eventType,omitempty" url:"eventType,omitempty"`
	// Indicate the format of report file to be generated by the engine.
	// Used for `method` = *report-email* and *report-web*.
	FileFormat *NotificationContentFileFormat `json:"fileFormat,omitempty" url:"fileFormat,omitempty"`
	// Array of pairs key:value to insert in request body to target in **method** = *web* or *report-web*.
	InternalData []*KeyValueDuo `json:"internalData,omitempty" url:"internalData,omitempty"`
	// The kind report to generate. For [automated reports](/developers/developer-guides/notifications-and-webhooks-overview#automated-reports) only.
	ReportName *NotificationContentReportName `json:"reportName,omitempty" url:"reportName,omitempty"`
	TimeZone   *Timezone                      `json:"timeZone,omitempty" url:"timeZone,omitempty"`
	// Used internally to reference the entity or object generating the event.
	TransactionId *string `json:"transactionId,omitempty" url:"transactionId,omitempty"`
	// Array of pairs key:value to insert in header of request to target in **method** = *web* or *report-web*.
	WebHeaderParameters []*KeyValueDuo `json:"webHeaderParameters,omitempty" url:"webHeaderParameters,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NotificationContent) GetEventType() *NotificationContentEventType {
	if n == nil {
		return nil
	}
	return n.EventType
}

func (n *NotificationContent) GetFileFormat() *NotificationContentFileFormat {
	if n == nil {
		return nil
	}
	return n.FileFormat
}

func (n *NotificationContent) GetInternalData() []*KeyValueDuo {
	if n == nil {
		return nil
	}
	return n.InternalData
}

func (n *NotificationContent) GetReportName() *NotificationContentReportName {
	if n == nil {
		return nil
	}
	return n.ReportName
}

func (n *NotificationContent) GetTimeZone() *Timezone {
	if n == nil {
		return nil
	}
	return n.TimeZone
}

func (n *NotificationContent) GetTransactionId() *string {
	if n == nil {
		return nil
	}
	return n.TransactionId
}

func (n *NotificationContent) GetWebHeaderParameters() []*KeyValueDuo {
	if n == nil {
		return nil
	}
	return n.WebHeaderParameters
}

func (n *NotificationContent) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NotificationContent) UnmarshalJSON(data []byte) error {
	type unmarshaler NotificationContent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotificationContent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NotificationContent) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// The notification's event name.
type NotificationContentEventType string

const (
	NotificationContentEventTypeApprovedPayment             NotificationContentEventType = "ApprovedPayment"
	NotificationContentEventTypeAuthorizedPayment           NotificationContentEventType = "AuthorizedPayment"
	NotificationContentEventTypeDeclinedPayment             NotificationContentEventType = "DeclinedPayment"
	NotificationContentEventTypeOriginatedPayment           NotificationContentEventType = "OriginatedPayment"
	NotificationContentEventTypeSettledPayment              NotificationContentEventType = "SettledPayment"
	NotificationContentEventTypeSubscriptionCreated         NotificationContentEventType = "SubscriptionCreated"
	NotificationContentEventTypeSubscriptionUpdated         NotificationContentEventType = "SubscriptionUpdated"
	NotificationContentEventTypeSubscriptionCanceled        NotificationContentEventType = "SubscriptionCanceled"
	NotificationContentEventTypeSubscriptionCompleted       NotificationContentEventType = "SubscriptionCompleted"
	NotificationContentEventTypeFundedPayment               NotificationContentEventType = "FundedPayment"
	NotificationContentEventTypeVoidedPayment               NotificationContentEventType = "VoidedPayment"
	NotificationContentEventTypeRefundedPayment             NotificationContentEventType = "RefundedPayment"
	NotificationContentEventTypeHoldTransaction             NotificationContentEventType = "HoldTransaction"
	NotificationContentEventTypeReleasedTransaction         NotificationContentEventType = "ReleasedTransaction"
	NotificationContentEventTypeHoldBatch                   NotificationContentEventType = "HoldBatch"
	NotificationContentEventTypeReleasedBatch               NotificationContentEventType = "ReleasedBatch"
	NotificationContentEventTypeTransferDisabledCreditFund  NotificationContentEventType = "TransferDisabledCreditFund"
	NotificationContentEventTypeTransferDisabledDebitFund   NotificationContentEventType = "TransferDisabledDebitFund"
	NotificationContentEventTypeTransferNotAvailableBalance NotificationContentEventType = "TransferNotAvailableBalance"
	NotificationContentEventTypeTransferReturn              NotificationContentEventType = "TransferReturn"
	NotificationContentEventTypeTransferSuccess             NotificationContentEventType = "TransferSuccess"
	NotificationContentEventTypeTransferSuspended           NotificationContentEventType = "TransferSuspended"
	NotificationContentEventTypeTransferError               NotificationContentEventType = "TransferError"
	NotificationContentEventTypeSendReceipt                 NotificationContentEventType = "SendReceipt"
	NotificationContentEventTypeRecoveredTransaction        NotificationContentEventType = "RecoveredTransaction"
	NotificationContentEventTypeCreatedApplication          NotificationContentEventType = "CreatedApplication"
	NotificationContentEventTypeApprovedApplication         NotificationContentEventType = "ApprovedApplication"
	NotificationContentEventTypeFailedBoardingApplication   NotificationContentEventType = "FailedBoardingApplication"
	NotificationContentEventTypeSubmittedApplication        NotificationContentEventType = "SubmittedApplication"
	NotificationContentEventTypeActivatedMerchant           NotificationContentEventType = "ActivatedMerchant"
	NotificationContentEventTypeReceivedChargeBack          NotificationContentEventType = "ReceivedChargeBack"
	NotificationContentEventTypeChargebackUpdated           NotificationContentEventType = "ChargebackUpdated"
	NotificationContentEventTypeReceivedRetrieval           NotificationContentEventType = "ReceivedRetrieval"
	NotificationContentEventTypeRetrievalUpdated            NotificationContentEventType = "RetrievalUpdated"
	NotificationContentEventTypeReceivedAchReturn           NotificationContentEventType = "ReceivedAchReturn"
	NotificationContentEventTypeHoldingApplication          NotificationContentEventType = "HoldingApplication"
	NotificationContentEventTypeDeclinedApplication         NotificationContentEventType = "DeclinedApplication"
	NotificationContentEventTypeBoardingApplication         NotificationContentEventType = "BoardingApplication"
	NotificationContentEventTypeFraudAlert                  NotificationContentEventType = "FraudAlert"
	NotificationContentEventTypeInvoiceSent                 NotificationContentEventType = "InvoiceSent"
	NotificationContentEventTypeInvoicePaid                 NotificationContentEventType = "InvoicePaid"
	NotificationContentEventTypeInvoiceCreated              NotificationContentEventType = "InvoiceCreated"
	NotificationContentEventTypeBillPaid                    NotificationContentEventType = "BillPaid"
	NotificationContentEventTypeBillApproved                NotificationContentEventType = "BillApproved"
	NotificationContentEventTypeBillDisApproved             NotificationContentEventType = "BillDisApproved"
	NotificationContentEventTypeBillCanceled                NotificationContentEventType = "BillCanceled"
	NotificationContentEventTypeBillProcessing              NotificationContentEventType = "BillProcessing"
	NotificationContentEventTypeCardCreated                 NotificationContentEventType = "CardCreated"
	NotificationContentEventTypeCardActivated               NotificationContentEventType = "CardActivated"
	NotificationContentEventTypeCardDeactivated             NotificationContentEventType = "CardDeactivated"
	NotificationContentEventTypeCardExpired                 NotificationContentEventType = "CardExpired"
	NotificationContentEventTypeCardExpiring                NotificationContentEventType = "CardExpiring"
	NotificationContentEventTypeCardLimitUpdated            NotificationContentEventType = "CardLimitUpdated"
	NotificationContentEventTypeBatchClosed                 NotificationContentEventType = "BatchClosed"
	NotificationContentEventTypeBatchNotClosed              NotificationContentEventType = "BatchNotClosed"
	NotificationContentEventTypePayOutFunded                NotificationContentEventType = "PayOutFunded"
	NotificationContentEventTypePayOutProcessed             NotificationContentEventType = "PayOutProcessed"
	NotificationContentEventTypePayOutCanceled              NotificationContentEventType = "PayOutCanceled"
	NotificationContentEventTypePayOutPaid                  NotificationContentEventType = "PayOutPaid"
	NotificationContentEventTypePayOutReturned              NotificationContentEventType = "PayOutReturned"
	NotificationContentEventTypePayoutSubscriptionCreated   NotificationContentEventType = "PayoutSubscriptionCreated"
	NotificationContentEventTypePayoutSubscriptionUpdated   NotificationContentEventType = "PayoutSubscriptionUpdated"
	NotificationContentEventTypePayoutSubscriptionCanceled  NotificationContentEventType = "PayoutSubscriptionCanceled"
	NotificationContentEventTypePayoutSubscriptionCompleted NotificationContentEventType = "PayoutSubscriptionCompleted"
	NotificationContentEventTypePayoutSubscriptionReminder  NotificationContentEventType = "PayoutSubscriptionReminder"
	NotificationContentEventTypeImportFileReceived          NotificationContentEventType = "importFileReceived"
	NotificationContentEventTypeImportFileProcessed         NotificationContentEventType = "importFileProcessed"
	NotificationContentEventTypeImportFileError             NotificationContentEventType = "importFileError"
	NotificationContentEventTypeExportFileSent              NotificationContentEventType = "exportFileSent"
	NotificationContentEventTypeExportFileError             NotificationContentEventType = "exportFileError"
	NotificationContentEventTypeFailedEmailNotification     NotificationContentEventType = "FailedEmailNotification"
	NotificationContentEventTypeFailedWebNotification       NotificationContentEventType = "FailedWebNotification"
	NotificationContentEventTypeFailedSmsNotification       NotificationContentEventType = "FailedSMSNotification"
	NotificationContentEventTypeUserPasswordExpiring        NotificationContentEventType = "UserPasswordExpiring"
	NotificationContentEventTypeUserPasswordExpired         NotificationContentEventType = "UserPasswordExpired"
	NotificationContentEventTypeTransactionNotFound         NotificationContentEventType = "TransactionNotFound"
	NotificationContentEventTypeSystemAlert                 NotificationContentEventType = "SystemAlert"
	NotificationContentEventTypeReport                      NotificationContentEventType = "Report"
)

func NewNotificationContentEventTypeFromString(s string) (NotificationContentEventType, error) {
	switch s {
	case "ApprovedPayment":
		return NotificationContentEventTypeApprovedPayment, nil
	case "AuthorizedPayment":
		return NotificationContentEventTypeAuthorizedPayment, nil
	case "DeclinedPayment":
		return NotificationContentEventTypeDeclinedPayment, nil
	case "OriginatedPayment":
		return NotificationContentEventTypeOriginatedPayment, nil
	case "SettledPayment":
		return NotificationContentEventTypeSettledPayment, nil
	case "SubscriptionCreated":
		return NotificationContentEventTypeSubscriptionCreated, nil
	case "SubscriptionUpdated":
		return NotificationContentEventTypeSubscriptionUpdated, nil
	case "SubscriptionCanceled":
		return NotificationContentEventTypeSubscriptionCanceled, nil
	case "SubscriptionCompleted":
		return NotificationContentEventTypeSubscriptionCompleted, nil
	case "FundedPayment":
		return NotificationContentEventTypeFundedPayment, nil
	case "VoidedPayment":
		return NotificationContentEventTypeVoidedPayment, nil
	case "RefundedPayment":
		return NotificationContentEventTypeRefundedPayment, nil
	case "HoldTransaction":
		return NotificationContentEventTypeHoldTransaction, nil
	case "ReleasedTransaction":
		return NotificationContentEventTypeReleasedTransaction, nil
	case "HoldBatch":
		return NotificationContentEventTypeHoldBatch, nil
	case "ReleasedBatch":
		return NotificationContentEventTypeReleasedBatch, nil
	case "TransferDisabledCreditFund":
		return NotificationContentEventTypeTransferDisabledCreditFund, nil
	case "TransferDisabledDebitFund":
		return NotificationContentEventTypeTransferDisabledDebitFund, nil
	case "TransferNotAvailableBalance":
		return NotificationContentEventTypeTransferNotAvailableBalance, nil
	case "TransferReturn":
		return NotificationContentEventTypeTransferReturn, nil
	case "TransferSuccess":
		return NotificationContentEventTypeTransferSuccess, nil
	case "TransferSuspended":
		return NotificationContentEventTypeTransferSuspended, nil
	case "TransferError":
		return NotificationContentEventTypeTransferError, nil
	case "SendReceipt":
		return NotificationContentEventTypeSendReceipt, nil
	case "RecoveredTransaction":
		return NotificationContentEventTypeRecoveredTransaction, nil
	case "CreatedApplication":
		return NotificationContentEventTypeCreatedApplication, nil
	case "ApprovedApplication":
		return NotificationContentEventTypeApprovedApplication, nil
	case "FailedBoardingApplication":
		return NotificationContentEventTypeFailedBoardingApplication, nil
	case "SubmittedApplication":
		return NotificationContentEventTypeSubmittedApplication, nil
	case "ActivatedMerchant":
		return NotificationContentEventTypeActivatedMerchant, nil
	case "ReceivedChargeBack":
		return NotificationContentEventTypeReceivedChargeBack, nil
	case "ChargebackUpdated":
		return NotificationContentEventTypeChargebackUpdated, nil
	case "ReceivedRetrieval":
		return NotificationContentEventTypeReceivedRetrieval, nil
	case "RetrievalUpdated":
		return NotificationContentEventTypeRetrievalUpdated, nil
	case "ReceivedAchReturn":
		return NotificationContentEventTypeReceivedAchReturn, nil
	case "HoldingApplication":
		return NotificationContentEventTypeHoldingApplication, nil
	case "DeclinedApplication":
		return NotificationContentEventTypeDeclinedApplication, nil
	case "BoardingApplication":
		return NotificationContentEventTypeBoardingApplication, nil
	case "FraudAlert":
		return NotificationContentEventTypeFraudAlert, nil
	case "InvoiceSent":
		return NotificationContentEventTypeInvoiceSent, nil
	case "InvoicePaid":
		return NotificationContentEventTypeInvoicePaid, nil
	case "InvoiceCreated":
		return NotificationContentEventTypeInvoiceCreated, nil
	case "BillPaid":
		return NotificationContentEventTypeBillPaid, nil
	case "BillApproved":
		return NotificationContentEventTypeBillApproved, nil
	case "BillDisApproved":
		return NotificationContentEventTypeBillDisApproved, nil
	case "BillCanceled":
		return NotificationContentEventTypeBillCanceled, nil
	case "BillProcessing":
		return NotificationContentEventTypeBillProcessing, nil
	case "CardCreated":
		return NotificationContentEventTypeCardCreated, nil
	case "CardActivated":
		return NotificationContentEventTypeCardActivated, nil
	case "CardDeactivated":
		return NotificationContentEventTypeCardDeactivated, nil
	case "CardExpired":
		return NotificationContentEventTypeCardExpired, nil
	case "CardExpiring":
		return NotificationContentEventTypeCardExpiring, nil
	case "CardLimitUpdated":
		return NotificationContentEventTypeCardLimitUpdated, nil
	case "BatchClosed":
		return NotificationContentEventTypeBatchClosed, nil
	case "BatchNotClosed":
		return NotificationContentEventTypeBatchNotClosed, nil
	case "PayOutFunded":
		return NotificationContentEventTypePayOutFunded, nil
	case "PayOutProcessed":
		return NotificationContentEventTypePayOutProcessed, nil
	case "PayOutCanceled":
		return NotificationContentEventTypePayOutCanceled, nil
	case "PayOutPaid":
		return NotificationContentEventTypePayOutPaid, nil
	case "PayOutReturned":
		return NotificationContentEventTypePayOutReturned, nil
	case "PayoutSubscriptionCreated":
		return NotificationContentEventTypePayoutSubscriptionCreated, nil
	case "PayoutSubscriptionUpdated":
		return NotificationContentEventTypePayoutSubscriptionUpdated, nil
	case "PayoutSubscriptionCanceled":
		return NotificationContentEventTypePayoutSubscriptionCanceled, nil
	case "PayoutSubscriptionCompleted":
		return NotificationContentEventTypePayoutSubscriptionCompleted, nil
	case "PayoutSubscriptionReminder":
		return NotificationContentEventTypePayoutSubscriptionReminder, nil
	case "importFileReceived":
		return NotificationContentEventTypeImportFileReceived, nil
	case "importFileProcessed":
		return NotificationContentEventTypeImportFileProcessed, nil
	case "importFileError":
		return NotificationContentEventTypeImportFileError, nil
	case "exportFileSent":
		return NotificationContentEventTypeExportFileSent, nil
	case "exportFileError":
		return NotificationContentEventTypeExportFileError, nil
	case "FailedEmailNotification":
		return NotificationContentEventTypeFailedEmailNotification, nil
	case "FailedWebNotification":
		return NotificationContentEventTypeFailedWebNotification, nil
	case "FailedSMSNotification":
		return NotificationContentEventTypeFailedSmsNotification, nil
	case "UserPasswordExpiring":
		return NotificationContentEventTypeUserPasswordExpiring, nil
	case "UserPasswordExpired":
		return NotificationContentEventTypeUserPasswordExpired, nil
	case "TransactionNotFound":
		return NotificationContentEventTypeTransactionNotFound, nil
	case "SystemAlert":
		return NotificationContentEventTypeSystemAlert, nil
	case "Report":
		return NotificationContentEventTypeReport, nil
	}
	var t NotificationContentEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (n NotificationContentEventType) Ptr() *NotificationContentEventType {
	return &n
}

// Indicate the format of report file to be generated by the engine.
// Used for `method` = *report-email* and *report-web*.
type NotificationContentFileFormat string

const (
	NotificationContentFileFormatJson NotificationContentFileFormat = "json"
	NotificationContentFileFormatCsv  NotificationContentFileFormat = "csv"
	NotificationContentFileFormatXlsx NotificationContentFileFormat = "xlsx"
)

func NewNotificationContentFileFormatFromString(s string) (NotificationContentFileFormat, error) {
	switch s {
	case "json":
		return NotificationContentFileFormatJson, nil
	case "csv":
		return NotificationContentFileFormatCsv, nil
	case "xlsx":
		return NotificationContentFileFormatXlsx, nil
	}
	var t NotificationContentFileFormat
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (n NotificationContentFileFormat) Ptr() *NotificationContentFileFormat {
	return &n
}

// The kind report to generate. For [automated reports](/developers/developer-guides/notifications-and-webhooks-overview#automated-reports) only.
type NotificationContentReportName string

const (
	NotificationContentReportNameTransaction NotificationContentReportName = "Transaction"
	NotificationContentReportNameSettlement  NotificationContentReportName = "Settlement"
	NotificationContentReportNameBoarding    NotificationContentReportName = "Boarding"
	NotificationContentReportNameReturned    NotificationContentReportName = "Returned"
)

func NewNotificationContentReportNameFromString(s string) (NotificationContentReportName, error) {
	switch s {
	case "Transaction":
		return NotificationContentReportNameTransaction, nil
	case "Settlement":
		return NotificationContentReportNameSettlement, nil
	case "Boarding":
		return NotificationContentReportNameBoarding, nil
	case "Returned":
		return NotificationContentReportNameReturned, nil
	}
	var t NotificationContentReportName
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (n NotificationContentReportName) Ptr() *NotificationContentReportName {
	return &n
}

// The notification's Payabli identifier. This is the ID used to manage the notification.
type NotificationId = int64

type OdpSetup struct {
	// Enables or disables ACH payout functionality
	AllowAch *bool `json:"allowAch,omitempty" url:"allowAch,omitempty"`
	// Enables or disables check printing payout functionality
	AllowChecks *bool `json:"allowChecks,omitempty" url:"allowChecks,omitempty"`
	// Enables or disables vCard payout functionality
	AllowVCard *bool `json:"allowVCard,omitempty" url:"allowVCard,omitempty"`
	// Region where payment processing occurs
	ProcessingRegion *OdpSetupProcessingRegion `json:"processing_region,omitempty" url:"processing_region,omitempty"`
	// Payment processor identifier
	Processor *string `json:"processor,omitempty" url:"processor,omitempty"`
	// Reference ID for the program enabled for ODP issuance
	IssuerNetworkSettingsId *string `json:"issuerNetworkSettingsId,omitempty" url:"issuerNetworkSettingsId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OdpSetup) GetAllowAch() *bool {
	if o == nil {
		return nil
	}
	return o.AllowAch
}

func (o *OdpSetup) GetAllowChecks() *bool {
	if o == nil {
		return nil
	}
	return o.AllowChecks
}

func (o *OdpSetup) GetAllowVCard() *bool {
	if o == nil {
		return nil
	}
	return o.AllowVCard
}

func (o *OdpSetup) GetProcessingRegion() *OdpSetupProcessingRegion {
	if o == nil {
		return nil
	}
	return o.ProcessingRegion
}

func (o *OdpSetup) GetProcessor() *string {
	if o == nil {
		return nil
	}
	return o.Processor
}

func (o *OdpSetup) GetIssuerNetworkSettingsId() *string {
	if o == nil {
		return nil
	}
	return o.IssuerNetworkSettingsId
}

func (o *OdpSetup) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OdpSetup) UnmarshalJSON(data []byte) error {
	type unmarshaler OdpSetup
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OdpSetup(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OdpSetup) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Region where payment processing occurs
type OdpSetupProcessingRegion string

const (
	OdpSetupProcessingRegionUs OdpSetupProcessingRegion = "US"
	OdpSetupProcessingRegionCa OdpSetupProcessingRegion = "CA"
)

func NewOdpSetupProcessingRegionFromString(s string) (OdpSetupProcessingRegion, error) {
	switch s {
	case "US":
		return OdpSetupProcessingRegionUs, nil
	case "CA":
		return OdpSetupProcessingRegionCa, nil
	}
	var t OdpSetupProcessingRegion
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OdpSetupProcessingRegion) Ptr() *OdpSetupProcessingRegion {
	return &o
}

// The transaction's operation.
type Operation = string

// Customer's consent status.
// Allowed status:
//
//   - 0: Customer hasn't opted in to communications
//
//   - -1: Customer opt in pending
//
//   - 1: Customer has opted in to communications
type OptinStatus = int

// Order of element or section in container.
type Order = int

// Custom identifier for the transaction.
type OrderId = string

// Text description of the transaction.
type Orderdescription = string

type OrgData struct {
	IdOrg      *Orgid       `json:"idOrg,omitempty" url:"idOrg,omitempty"`
	OrgAddress *Orgaddress  `json:"orgAddress,omitempty" url:"orgAddress,omitempty"`
	OrgLogo    *FileContent `json:"orgLogo,omitempty" url:"orgLogo,omitempty"`
	OrgName    *Orgname     `json:"orgName,omitempty" url:"orgName,omitempty"`
	// The paypoint's status.
	//
	// Active - `1`
	//
	// Inactive - 0
	OrgStatus *int     `json:"orgStatus,omitempty" url:"orgStatus,omitempty"`
	OrgType   *Orgtype `json:"orgType,omitempty" url:"orgType,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrgData) GetIdOrg() *Orgid {
	if o == nil {
		return nil
	}
	return o.IdOrg
}

func (o *OrgData) GetOrgAddress() *Orgaddress {
	if o == nil {
		return nil
	}
	return o.OrgAddress
}

func (o *OrgData) GetOrgLogo() *FileContent {
	if o == nil {
		return nil
	}
	return o.OrgLogo
}

func (o *OrgData) GetOrgName() *Orgname {
	if o == nil {
		return nil
	}
	return o.OrgName
}

func (o *OrgData) GetOrgStatus() *int {
	if o == nil {
		return nil
	}
	return o.OrgStatus
}

func (o *OrgData) GetOrgType() *Orgtype {
	if o == nil {
		return nil
	}
	return o.OrgType
}

func (o *OrgData) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrgData) UnmarshalJSON(data []byte) error {
	type unmarshaler OrgData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrgData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrgData) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The ID of the org's parent organization.
type OrgParentId = int64

// The name of the parent organization.
type OrgParentName = string

type OrgXScope struct {
	OrgEntry *Orgentryname `json:"orgEntry,omitempty" url:"orgEntry,omitempty"`
	OrgId    *Orgid        `json:"orgId,omitempty" url:"orgId,omitempty"`
	OrgType  *Orgtype      `json:"orgType,omitempty" url:"orgType,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrgXScope) GetOrgEntry() *Orgentryname {
	if o == nil {
		return nil
	}
	return o.OrgEntry
}

func (o *OrgXScope) GetOrgId() *Orgid {
	if o == nil {
		return nil
	}
	return o.OrgId
}

func (o *OrgXScope) GetOrgType() *Orgtype {
	if o == nil {
		return nil
	}
	return o.OrgType
}

func (o *OrgXScope) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrgXScope) UnmarshalJSON(data []byte) error {
	type unmarshaler OrgXScope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrgXScope(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrgXScope) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The organization's address.
type Orgaddress = string

type OrganizationQueryRecord struct {
	Services                   []*OrganizationQueryRecordServicesItem `json:"services,omitempty" url:"services,omitempty"`
	BillingInfo                *Instrument                            `json:"billingInfo,omitempty" url:"billingInfo,omitempty"`
	Contacts                   *ContactsField                         `json:"contacts,omitempty" url:"contacts,omitempty"`
	CreatedAt                  *CreatedAt                             `json:"createdAt,omitempty" url:"createdAt,omitempty"`
	HasBilling                 *bool                                  `json:"hasBilling,omitempty" url:"hasBilling,omitempty"`
	HasResidual                *bool                                  `json:"hasResidual,omitempty" url:"hasResidual,omitempty"`
	IdOrg                      *Orgid                                 `json:"idOrg,omitempty" url:"idOrg,omitempty"`
	IsRoot                     *IsRoot                                `json:"isRoot,omitempty" url:"isRoot,omitempty"`
	OrgAddress                 *Orgaddress                            `json:"orgAddress,omitempty" url:"orgAddress,omitempty"`
	OrgCity                    *Orgcity                               `json:"orgCity,omitempty" url:"orgCity,omitempty"`
	OrgCountry                 *Orgcountry                            `json:"orgCountry,omitempty" url:"orgCountry,omitempty"`
	OrgEntryName               *Orgentryname                          `json:"orgEntryName,omitempty" url:"orgEntryName,omitempty"`
	OrgId                      *Orgidstring                           `json:"orgId,omitempty" url:"orgId,omitempty"`
	OrgLogo                    *FileContent                           `json:"orgLogo,omitempty" url:"orgLogo,omitempty"`
	OrgName                    *Orgname                               `json:"orgName,omitempty" url:"orgName,omitempty"`
	OrgParentId                *OrgParentId                           `json:"orgParentId,omitempty" url:"orgParentId,omitempty"`
	OrgParentName              *OrgParentName                         `json:"orgParentName,omitempty" url:"orgParentName,omitempty"`
	OrgState                   *Orgstate                              `json:"orgState,omitempty" url:"orgState,omitempty"`
	OrgTimezone                *Orgtimezone                           `json:"orgTimezone,omitempty" url:"orgTimezone,omitempty"`
	OrgType                    *Orgtype                               `json:"orgType,omitempty" url:"orgType,omitempty"`
	OrgWebsite                 *Orgwebsite                            `json:"orgWebsite,omitempty" url:"orgWebsite,omitempty"`
	OrgZip                     *Orgzip                                `json:"orgZip,omitempty" url:"orgZip,omitempty"`
	RecipientEmailNotification *RecipientEmailNotification            `json:"recipientEmailNotification,omitempty" url:"recipientEmailNotification,omitempty"`
	ReplyToEmail               *ReplyToEmail                          `json:"replyToEmail,omitempty" url:"replyToEmail,omitempty"`
	Resumable                  *Resumable                             `json:"resumable,omitempty" url:"resumable,omitempty"`
	Summary                    *SummaryOrg                            `json:"summary,omitempty" url:"summary,omitempty"`
	Users                      []*UserQueryRecord                     `json:"users,omitempty" url:"users,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrganizationQueryRecord) GetServices() []*OrganizationQueryRecordServicesItem {
	if o == nil {
		return nil
	}
	return o.Services
}

func (o *OrganizationQueryRecord) GetBillingInfo() *Instrument {
	if o == nil {
		return nil
	}
	return o.BillingInfo
}

func (o *OrganizationQueryRecord) GetContacts() *ContactsField {
	if o == nil {
		return nil
	}
	return o.Contacts
}

func (o *OrganizationQueryRecord) GetCreatedAt() *CreatedAt {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *OrganizationQueryRecord) GetHasBilling() *bool {
	if o == nil {
		return nil
	}
	return o.HasBilling
}

func (o *OrganizationQueryRecord) GetHasResidual() *bool {
	if o == nil {
		return nil
	}
	return o.HasResidual
}

func (o *OrganizationQueryRecord) GetIdOrg() *Orgid {
	if o == nil {
		return nil
	}
	return o.IdOrg
}

func (o *OrganizationQueryRecord) GetIsRoot() *IsRoot {
	if o == nil {
		return nil
	}
	return o.IsRoot
}

func (o *OrganizationQueryRecord) GetOrgAddress() *Orgaddress {
	if o == nil {
		return nil
	}
	return o.OrgAddress
}

func (o *OrganizationQueryRecord) GetOrgCity() *Orgcity {
	if o == nil {
		return nil
	}
	return o.OrgCity
}

func (o *OrganizationQueryRecord) GetOrgCountry() *Orgcountry {
	if o == nil {
		return nil
	}
	return o.OrgCountry
}

func (o *OrganizationQueryRecord) GetOrgEntryName() *Orgentryname {
	if o == nil {
		return nil
	}
	return o.OrgEntryName
}

func (o *OrganizationQueryRecord) GetOrgId() *Orgidstring {
	if o == nil {
		return nil
	}
	return o.OrgId
}

func (o *OrganizationQueryRecord) GetOrgLogo() *FileContent {
	if o == nil {
		return nil
	}
	return o.OrgLogo
}

func (o *OrganizationQueryRecord) GetOrgName() *Orgname {
	if o == nil {
		return nil
	}
	return o.OrgName
}

func (o *OrganizationQueryRecord) GetOrgParentId() *OrgParentId {
	if o == nil {
		return nil
	}
	return o.OrgParentId
}

func (o *OrganizationQueryRecord) GetOrgParentName() *OrgParentName {
	if o == nil {
		return nil
	}
	return o.OrgParentName
}

func (o *OrganizationQueryRecord) GetOrgState() *Orgstate {
	if o == nil {
		return nil
	}
	return o.OrgState
}

func (o *OrganizationQueryRecord) GetOrgTimezone() *Orgtimezone {
	if o == nil {
		return nil
	}
	return o.OrgTimezone
}

func (o *OrganizationQueryRecord) GetOrgType() *Orgtype {
	if o == nil {
		return nil
	}
	return o.OrgType
}

func (o *OrganizationQueryRecord) GetOrgWebsite() *Orgwebsite {
	if o == nil {
		return nil
	}
	return o.OrgWebsite
}

func (o *OrganizationQueryRecord) GetOrgZip() *Orgzip {
	if o == nil {
		return nil
	}
	return o.OrgZip
}

func (o *OrganizationQueryRecord) GetRecipientEmailNotification() *RecipientEmailNotification {
	if o == nil {
		return nil
	}
	return o.RecipientEmailNotification
}

func (o *OrganizationQueryRecord) GetReplyToEmail() *ReplyToEmail {
	if o == nil {
		return nil
	}
	return o.ReplyToEmail
}

func (o *OrganizationQueryRecord) GetResumable() *Resumable {
	if o == nil {
		return nil
	}
	return o.Resumable
}

func (o *OrganizationQueryRecord) GetSummary() *SummaryOrg {
	if o == nil {
		return nil
	}
	return o.Summary
}

func (o *OrganizationQueryRecord) GetUsers() []*UserQueryRecord {
	if o == nil {
		return nil
	}
	return o.Users
}

func (o *OrganizationQueryRecord) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrganizationQueryRecord) UnmarshalJSON(data []byte) error {
	type unmarshaler OrganizationQueryRecord
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrganizationQueryRecord(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrganizationQueryRecord) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrganizationQueryRecordServicesItem struct {
	Description   *string  `json:"description,omitempty" url:"description,omitempty"`
	Enabled       *bool    `json:"enabled,omitempty" url:"enabled,omitempty"`
	MonthlyCost   *float64 `json:"monthlyCost,omitempty" url:"monthlyCost,omitempty"`
	Name          *string  `json:"name,omitempty" url:"name,omitempty"`
	Reseller      *bool    `json:"reseller,omitempty" url:"reseller,omitempty"`
	SetupCost     *float64 `json:"setupCost,omitempty" url:"setupCost,omitempty"`
	TxCost        *float64 `json:"txCost,omitempty" url:"txCost,omitempty"`
	TxPercentCost *float64 `json:"txPercentCost,omitempty" url:"txPercentCost,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrganizationQueryRecordServicesItem) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *OrganizationQueryRecordServicesItem) GetEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.Enabled
}

func (o *OrganizationQueryRecordServicesItem) GetMonthlyCost() *float64 {
	if o == nil {
		return nil
	}
	return o.MonthlyCost
}

func (o *OrganizationQueryRecordServicesItem) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *OrganizationQueryRecordServicesItem) GetReseller() *bool {
	if o == nil {
		return nil
	}
	return o.Reseller
}

func (o *OrganizationQueryRecordServicesItem) GetSetupCost() *float64 {
	if o == nil {
		return nil
	}
	return o.SetupCost
}

func (o *OrganizationQueryRecordServicesItem) GetTxCost() *float64 {
	if o == nil {
		return nil
	}
	return o.TxCost
}

func (o *OrganizationQueryRecordServicesItem) GetTxPercentCost() *float64 {
	if o == nil {
		return nil
	}
	return o.TxPercentCost
}

func (o *OrganizationQueryRecordServicesItem) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrganizationQueryRecordServicesItem) UnmarshalJSON(data []byte) error {
	type unmarshaler OrganizationQueryRecordServicesItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrganizationQueryRecordServicesItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrganizationQueryRecordServicesItem) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The organization's city.
type Orgcity = string

// The organization's country.
type Orgcountry = string

// The entryname for the org, in string format. If you leave this blank, Payabli uses the DBA name.
type Orgentryname = string

// Organization ID. Unique identifier assigned to an org by Payabli.
type Orgid = int64

// An alternate ID for the organization, in string format. This can be your internal identifier for an org, and is typically a name, like "My Suborganization".
type Orgidstring = string

// The name of the organization.
type Orgname = string

// The organization's state.
type Orgstate = string

// The org's timezone, in UTC offset. For example, -5 is Eastern time.
type Orgtimezone = int

// The organization type. Currently, this must be `0`.
type Orgtype = int

// The organization's website.
type Orgwebsite = string

// The organization's ZIP code.
type Orgzip = string

// The business ownership type.
type OwnType string

const (
	OwnTypeLimitedLiabilityCompany OwnType = "Limited Liability Company"
	OwnTypeNonProfitOrg            OwnType = "Non-Profit Org"
	OwnTypePartnership             OwnType = "Partnership"
	OwnTypePrivateCorp             OwnType = "Private Corp"
	OwnTypePublicCorp              OwnType = "Public Corp"
	OwnTypeTaxExempt               OwnType = "Tax Exempt"
	OwnTypeGovernment              OwnType = "Government"
	OwnTypeSoleProprietor          OwnType = "Sole Proprietor"
)

func NewOwnTypeFromString(s string) (OwnType, error) {
	switch s {
	case "Limited Liability Company":
		return OwnTypeLimitedLiabilityCompany, nil
	case "Non-Profit Org":
		return OwnTypeNonProfitOrg, nil
	case "Partnership":
		return OwnTypePartnership, nil
	case "Private Corp":
		return OwnTypePrivateCorp, nil
	case "Public Corp":
		return OwnTypePublicCorp, nil
	case "Tax Exempt":
		return OwnTypeTaxExempt, nil
	case "Government":
		return OwnTypeGovernment, nil
	case "Sole Proprietor":
		return OwnTypeSoleProprietor, nil
	}
	var t OwnType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OwnType) Ptr() *OwnType {
	return &o
}

// ID for the paypoint or organization that owns the notification.
type Ownerid = string

type Owners struct {
	// Person who is registered as the beneficial owner of the business. This is a combination of first and last name.
	Ownername *string `json:"ownername,omitempty" url:"ownername,omitempty"`
	// The job title of the person such as CEO or director.
	Ownertitle *string `json:"ownertitle,omitempty" url:"ownertitle,omitempty"`
	// Percentage of ownership the person holds, in integer format.
	Ownerpercent *int `json:"ownerpercent,omitempty" url:"ownerpercent,omitempty"`
	// The relevant identifier for the person such as a Social Security Number.
	Ownerssn *string `json:"ownerssn,omitempty" url:"ownerssn,omitempty"`
	// Owner's date of birth.
	Ownerdob *string `json:"ownerdob,omitempty" url:"ownerdob,omitempty"`
	// Owner phone 1.
	Ownerphone1 *string `json:"ownerphone1,omitempty" url:"ownerphone1,omitempty"`
	// Owner phone 2.
	Ownerphone2 *string `json:"ownerphone2,omitempty" url:"ownerphone2,omitempty"`
	// Owner email.
	Owneremail *Email `json:"owneremail,omitempty" url:"owneremail,omitempty"`
	// Owner driver's license ID number. Payabli strongly recommends including this.
	Ownerdriver *string `json:"ownerdriver,omitempty" url:"ownerdriver,omitempty"`
	// Owner street address. This must be the physical address of the owner, not a P.O. box.
	Oaddress *string `json:"oaddress,omitempty" url:"oaddress,omitempty"`
	// Owner address city.
	Ocity *string `json:"ocity,omitempty" url:"ocity,omitempty"`
	// Owner address country in ISO-3166-1 alpha 2 format. Check out https://en.wikipedia.org/wiki/ISO_3166-1 for reference.
	Ocountry *string `json:"ocountry,omitempty" url:"ocountry,omitempty"`
	// Owner driver's license State. Payabli strongly recommends including this.
	Odriverstate *string `json:"odriverstate,omitempty" url:"odriverstate,omitempty"`
	// Owner address state.
	Ostate *string `json:"ostate,omitempty" url:"ostate,omitempty"`
	// Owner address ZIP.
	Ozip           *string               `json:"ozip,omitempty" url:"ozip,omitempty"`
	AdditionalData *AdditionalDataString `json:"additionalData,omitempty" url:"additionalData,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *Owners) GetOwnername() *string {
	if o == nil {
		return nil
	}
	return o.Ownername
}

func (o *Owners) GetOwnertitle() *string {
	if o == nil {
		return nil
	}
	return o.Ownertitle
}

func (o *Owners) GetOwnerpercent() *int {
	if o == nil {
		return nil
	}
	return o.Ownerpercent
}

func (o *Owners) GetOwnerssn() *string {
	if o == nil {
		return nil
	}
	return o.Ownerssn
}

func (o *Owners) GetOwnerdob() *string {
	if o == nil {
		return nil
	}
	return o.Ownerdob
}

func (o *Owners) GetOwnerphone1() *string {
	if o == nil {
		return nil
	}
	return o.Ownerphone1
}

func (o *Owners) GetOwnerphone2() *string {
	if o == nil {
		return nil
	}
	return o.Ownerphone2
}

func (o *Owners) GetOwneremail() *Email {
	if o == nil {
		return nil
	}
	return o.Owneremail
}

func (o *Owners) GetOwnerdriver() *string {
	if o == nil {
		return nil
	}
	return o.Ownerdriver
}

func (o *Owners) GetOaddress() *string {
	if o == nil {
		return nil
	}
	return o.Oaddress
}

func (o *Owners) GetOcity() *string {
	if o == nil {
		return nil
	}
	return o.Ocity
}

func (o *Owners) GetOcountry() *string {
	if o == nil {
		return nil
	}
	return o.Ocountry
}

func (o *Owners) GetOdriverstate() *string {
	if o == nil {
		return nil
	}
	return o.Odriverstate
}

func (o *Owners) GetOstate() *string {
	if o == nil {
		return nil
	}
	return o.Ostate
}

func (o *Owners) GetOzip() *string {
	if o == nil {
		return nil
	}
	return o.Ozip
}

func (o *Owners) GetAdditionalData() *AdditionalDataString {
	if o == nil {
		return nil
	}
	return o.AdditionalData
}

func (o *Owners) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Owners) UnmarshalJSON(data []byte) error {
	type unmarshaler Owners
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = Owners(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *Owners) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// List of Owners with at least a 25% ownership.
type Ownership = []*Owners

// Entity owner type. Accepted values:
//
//   - `0`: Organization/partner
//   - `2`: Paypoint
type Ownertype = int

type PageContent struct {
	// Amount section of payment page
	Amount *AmountElement `json:"amount,omitempty" url:"amount,omitempty"`
	// Autopay section of payment page
	Autopay *AutoElement `json:"autopay,omitempty" url:"autopay,omitempty"`
	// ContactUs section of payment page
	ContactUs *ContactElement `json:"contactUs,omitempty" url:"contactUs,omitempty"`
	// Identifier of entry point owner of page
	Entry *string `json:"entry,omitempty" url:"entry,omitempty"`
	// Invoices section of payment page
	Invoices *InvoiceElement `json:"invoices,omitempty" url:"invoices,omitempty"`
	// Logo section of payment page
	Logo *Element `json:"logo,omitempty" url:"logo,omitempty"`
	// Message section of payment page
	MessageBeforePaying *LabelElement `json:"messageBeforePaying,omitempty" url:"messageBeforePaying,omitempty"`
	// Descriptor of page
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Notes section of payment page
	Notes *NoteElement `json:"notes,omitempty" url:"notes,omitempty"`
	// Page header section of payment page
	Page *PageElement `json:"page,omitempty" url:"page,omitempty"`
	// Payment button section of payment page
	PaymentButton *LabelElement `json:"paymentButton,omitempty" url:"paymentButton,omitempty"`
	// Payment methods section of payment page
	PaymentMethods *MethodElement `json:"paymentMethods,omitempty" url:"paymentMethods,omitempty"`
	// Customer/Payor section of payment page
	Payor *PayorElement `json:"payor,omitempty" url:"payor,omitempty"`
	// Review section of payment page
	Review *HeaderElement `json:"review,omitempty" url:"review,omitempty"`
	// Unique identifier assigned to the page.
	Subdomain *Subdomain `json:"subdomain,omitempty" url:"subdomain,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PageContent) GetAmount() *AmountElement {
	if p == nil {
		return nil
	}
	return p.Amount
}

func (p *PageContent) GetAutopay() *AutoElement {
	if p == nil {
		return nil
	}
	return p.Autopay
}

func (p *PageContent) GetContactUs() *ContactElement {
	if p == nil {
		return nil
	}
	return p.ContactUs
}

func (p *PageContent) GetEntry() *string {
	if p == nil {
		return nil
	}
	return p.Entry
}

func (p *PageContent) GetInvoices() *InvoiceElement {
	if p == nil {
		return nil
	}
	return p.Invoices
}

func (p *PageContent) GetLogo() *Element {
	if p == nil {
		return nil
	}
	return p.Logo
}

func (p *PageContent) GetMessageBeforePaying() *LabelElement {
	if p == nil {
		return nil
	}
	return p.MessageBeforePaying
}

func (p *PageContent) GetName() *string {
	if p == nil {
		return nil
	}
	return p.Name
}

func (p *PageContent) GetNotes() *NoteElement {
	if p == nil {
		return nil
	}
	return p.Notes
}

func (p *PageContent) GetPage() *PageElement {
	if p == nil {
		return nil
	}
	return p.Page
}

func (p *PageContent) GetPaymentButton() *LabelElement {
	if p == nil {
		return nil
	}
	return p.PaymentButton
}

func (p *PageContent) GetPaymentMethods() *MethodElement {
	if p == nil {
		return nil
	}
	return p.PaymentMethods
}

func (p *PageContent) GetPayor() *PayorElement {
	if p == nil {
		return nil
	}
	return p.Payor
}

func (p *PageContent) GetReview() *HeaderElement {
	if p == nil {
		return nil
	}
	return p.Review
}

func (p *PageContent) GetSubdomain() *Subdomain {
	if p == nil {
		return nil
	}
	return p.Subdomain
}

func (p *PageContent) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PageContent) UnmarshalJSON(data []byte) error {
	type unmarshaler PageContent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PageContent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PageContent) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PageElement struct {
	// Page description in header
	Description *string  `json:"description,omitempty" url:"description,omitempty"`
	Enabled     *Enabled `json:"enabled,omitempty" url:"enabled,omitempty"`
	// Page header
	Header *string `json:"header,omitempty" url:"header,omitempty"`
	Order  *Order  `json:"order,omitempty" url:"order,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PageElement) GetDescription() *string {
	if p == nil {
		return nil
	}
	return p.Description
}

func (p *PageElement) GetEnabled() *Enabled {
	if p == nil {
		return nil
	}
	return p.Enabled
}

func (p *PageElement) GetHeader() *string {
	if p == nil {
		return nil
	}
	return p.Header
}

func (p *PageElement) GetOrder() *Order {
	if p == nil {
		return nil
	}
	return p.Order
}

func (p *PageElement) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PageElement) UnmarshalJSON(data []byte) error {
	type unmarshaler PageElement
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PageElement(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PageElement) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Auxiliary validation used internally by payment pages and components.
type PageIdentifier = string

type PageSetting struct {
	// An HTML color code in format #RRGGBB
	Color *string `json:"color,omitempty" url:"color,omitempty"`
	// Complete URL to a custom CSS file to be loaded with the page
	CustomCssUrl *string `json:"customCssUrl,omitempty" url:"customCssUrl,omitempty"`
	// Two-letter code following ISO 639-1
	Language *string `json:"language,omitempty" url:"language,omitempty"`
	// Object containing logo file to upload/ use in page
	PageLogo      *FileContent   `json:"pageLogo,omitempty" url:"pageLogo,omitempty"`
	PaymentButton *ButtonElement `json:"paymentButton,omitempty" url:"paymentButton,omitempty"`
	// Flag indicating if the capability for redirection in the page will be activated
	RedirectAfterApprove *bool `json:"redirectAfterApprove,omitempty" url:"redirectAfterApprove,omitempty"`
	// Complete URL where the page will be redirected after completion
	RedirectAfterApproveUrl *string `json:"redirectAfterApproveUrl,omitempty" url:"redirectAfterApproveUrl,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PageSetting) GetColor() *string {
	if p == nil {
		return nil
	}
	return p.Color
}

func (p *PageSetting) GetCustomCssUrl() *string {
	if p == nil {
		return nil
	}
	return p.CustomCssUrl
}

func (p *PageSetting) GetLanguage() *string {
	if p == nil {
		return nil
	}
	return p.Language
}

func (p *PageSetting) GetPageLogo() *FileContent {
	if p == nil {
		return nil
	}
	return p.PageLogo
}

func (p *PageSetting) GetPaymentButton() *ButtonElement {
	if p == nil {
		return nil
	}
	return p.PaymentButton
}

func (p *PageSetting) GetRedirectAfterApprove() *bool {
	if p == nil {
		return nil
	}
	return p.RedirectAfterApprove
}

func (p *PageSetting) GetRedirectAfterApproveUrl() *string {
	if p == nil {
		return nil
	}
	return p.RedirectAfterApproveUrl
}

func (p *PageSetting) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PageSetting) UnmarshalJSON(data []byte) error {
	type unmarshaler PageSetting
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PageSetting(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PageSetting) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Number of records on each response page.
type Pagesize = int

type PairFiles struct {
	// Original filename
	OriginalName *string `json:"originalName,omitempty" url:"originalName,omitempty"`
	// Filename assigned to zipped file. This is the name to use for reference in the API functions to get files in attachments.
	ZipName *string `json:"zipName,omitempty" url:"zipName,omitempty"`
	// Descriptor of the file.
	Descriptor *string `json:"descriptor,omitempty" url:"descriptor,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PairFiles) GetOriginalName() *string {
	if p == nil {
		return nil
	}
	return p.OriginalName
}

func (p *PairFiles) GetZipName() *string {
	if p == nil {
		return nil
	}
	return p.ZipName
}

func (p *PairFiles) GetDescriptor() *string {
	if p == nil {
		return nil
	}
	return p.Descriptor
}

func (p *PairFiles) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PairFiles) UnmarshalJSON(data []byte) error {
	type unmarshaler PairFiles
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PairFiles(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PairFiles) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayCategory struct {
	Description     *string `json:"description,omitempty" url:"description,omitempty"`
	Label           *string `json:"label,omitempty" url:"label,omitempty"`
	Name            *string `json:"name,omitempty" url:"name,omitempty"`
	OptionalPay     *bool   `json:"optionalPay,omitempty" url:"optionalPay,omitempty"`
	Order           *Order  `json:"order,omitempty" url:"order,omitempty"`
	Quantity        *int    `json:"quantity,omitempty" url:"quantity,omitempty"`
	ShowDescription *bool   `json:"showDescription,omitempty" url:"showDescription,omitempty"`
	Type            *string `json:"type,omitempty" url:"type,omitempty"`
	Value           *string `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayCategory) GetDescription() *string {
	if p == nil {
		return nil
	}
	return p.Description
}

func (p *PayCategory) GetLabel() *string {
	if p == nil {
		return nil
	}
	return p.Label
}

func (p *PayCategory) GetName() *string {
	if p == nil {
		return nil
	}
	return p.Name
}

func (p *PayCategory) GetOptionalPay() *bool {
	if p == nil {
		return nil
	}
	return p.OptionalPay
}

func (p *PayCategory) GetOrder() *Order {
	if p == nil {
		return nil
	}
	return p.Order
}

func (p *PayCategory) GetQuantity() *int {
	if p == nil {
		return nil
	}
	return p.Quantity
}

func (p *PayCategory) GetShowDescription() *bool {
	if p == nil {
		return nil
	}
	return p.ShowDescription
}

func (p *PayCategory) GetType() *string {
	if p == nil {
		return nil
	}
	return p.Type
}

func (p *PayCategory) GetValue() *string {
	if p == nil {
		return nil
	}
	return p.Value
}

func (p *PayCategory) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayCategory) UnmarshalJSON(data []byte) error {
	type unmarshaler PayCategory
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayCategory(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayCategory) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayMethodAch struct {
	// Bank account number. This field is **required** when method = 'ach'.
	AchAccount Achaccount `json:"achAccount" url:"achAccount"`
	// Bank account type. This field is **required** when method = 'ach'.
	AchAccountType *Achaccounttype `json:"achAccountType,omitempty" url:"achAccountType,omitempty"`
	AchCode        *AchSecCode     `json:"achCode,omitempty" url:"achCode,omitempty"`
	AchHolder      AchHolder       `json:"achHolder" url:"achHolder"`
	AchHolderType  *AchHolderType  `json:"achHolderType,omitempty" url:"achHolderType,omitempty"`
	// ABA/routing number of bank account. This field is **required** when method = 'ach'.
	AchRouting Achrouting `json:"achRouting" url:"achRouting"`
	Device     *Device    `json:"device,omitempty" url:"device,omitempty"`
	method     string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayMethodAch) GetAchAccount() Achaccount {
	if p == nil {
		return ""
	}
	return p.AchAccount
}

func (p *PayMethodAch) GetAchAccountType() *Achaccounttype {
	if p == nil {
		return nil
	}
	return p.AchAccountType
}

func (p *PayMethodAch) GetAchCode() *AchSecCode {
	if p == nil {
		return nil
	}
	return p.AchCode
}

func (p *PayMethodAch) GetAchHolder() AchHolder {
	if p == nil {
		return ""
	}
	return p.AchHolder
}

func (p *PayMethodAch) GetAchHolderType() *AchHolderType {
	if p == nil {
		return nil
	}
	return p.AchHolderType
}

func (p *PayMethodAch) GetAchRouting() Achrouting {
	if p == nil {
		return ""
	}
	return p.AchRouting
}

func (p *PayMethodAch) GetDevice() *Device {
	if p == nil {
		return nil
	}
	return p.Device
}

func (p *PayMethodAch) Method() string {
	return p.method
}

func (p *PayMethodAch) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayMethodAch) UnmarshalJSON(data []byte) error {
	type embed PayMethodAch
	var unmarshaler = struct {
		embed
		Method string `json:"method"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PayMethodAch(unmarshaler.embed)
	if unmarshaler.Method != "ach" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "ach", unmarshaler.Method)
	}
	p.method = unmarshaler.Method
	extraProperties, err := internal.ExtractExtraProperties(data, *p, "method")
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayMethodAch) MarshalJSON() ([]byte, error) {
	type embed PayMethodAch
	var marshaler = struct {
		embed
		Method string `json:"method"`
	}{
		embed:  embed(*p),
		Method: "ach",
	}
	return json.Marshal(marshaler)
}

func (p *PayMethodAch) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayMethodCredit struct {
	Cardcvv    *Cardcvv    `json:"cardcvv,omitempty" url:"cardcvv,omitempty"`
	Cardexp    Cardexp     `json:"cardexp" url:"cardexp"`
	CardHolder *Cardholder `json:"cardHolder,omitempty" url:"cardHolder,omitempty"`
	Cardnumber Cardnumber  `json:"cardnumber" url:"cardnumber"`
	Cardzip    *Cardzip    `json:"cardzip,omitempty" url:"cardzip,omitempty"`
	Initiator  *Initiator  `json:"initiator,omitempty" url:"initiator,omitempty"`
	// Method to use for the transaction. For transactions with a credit or debit card, or a tokenized card, use `card`.
	SaveIfSuccess *SaveIfSuccess `json:"saveIfSuccess,omitempty" url:"saveIfSuccess,omitempty"`
	method        string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayMethodCredit) GetCardcvv() *Cardcvv {
	if p == nil {
		return nil
	}
	return p.Cardcvv
}

func (p *PayMethodCredit) GetCardexp() Cardexp {
	if p == nil {
		return ""
	}
	return p.Cardexp
}

func (p *PayMethodCredit) GetCardHolder() *Cardholder {
	if p == nil {
		return nil
	}
	return p.CardHolder
}

func (p *PayMethodCredit) GetCardnumber() Cardnumber {
	if p == nil {
		return ""
	}
	return p.Cardnumber
}

func (p *PayMethodCredit) GetCardzip() *Cardzip {
	if p == nil {
		return nil
	}
	return p.Cardzip
}

func (p *PayMethodCredit) GetInitiator() *Initiator {
	if p == nil {
		return nil
	}
	return p.Initiator
}

func (p *PayMethodCredit) GetSaveIfSuccess() *SaveIfSuccess {
	if p == nil {
		return nil
	}
	return p.SaveIfSuccess
}

func (p *PayMethodCredit) Method() string {
	return p.method
}

func (p *PayMethodCredit) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayMethodCredit) UnmarshalJSON(data []byte) error {
	type embed PayMethodCredit
	var unmarshaler = struct {
		embed
		Method string `json:"method"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PayMethodCredit(unmarshaler.embed)
	if unmarshaler.Method != "card" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", p, "card", unmarshaler.Method)
	}
	p.method = unmarshaler.Method
	extraProperties, err := internal.ExtractExtraProperties(data, *p, "method")
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayMethodCredit) MarshalJSON() ([]byte, error) {
	type embed PayMethodCredit
	var marshaler = struct {
		embed
		Method string `json:"method"`
	}{
		embed:  embed(*p),
		Method: "card",
	}
	return json.Marshal(marshaler)
}

func (p *PayMethodCredit) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayabliApiResponse struct {
	IsSuccess    *IsSuccess    `json:"isSuccess,omitempty" url:"isSuccess,omitempty"`
	ResponseData *Responsedata `json:"responseData,omitempty" url:"responseData,omitempty"`
	ResponseText *ResponseText `json:"responseText,omitempty" url:"responseText,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayabliApiResponse) GetIsSuccess() *IsSuccess {
	if p == nil {
		return nil
	}
	return p.IsSuccess
}

func (p *PayabliApiResponse) GetResponseData() *Responsedata {
	if p == nil {
		return nil
	}
	return p.ResponseData
}

func (p *PayabliApiResponse) GetResponseText() *ResponseText {
	if p == nil {
		return nil
	}
	return p.ResponseText
}

func (p *PayabliApiResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayabliApiResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PayabliApiResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayabliApiResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayabliApiResponse) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayabliApiResponse00Responsedatanonobject struct {
	ResponseCode   *Responsecode   `json:"responseCode,omitempty" url:"responseCode,omitempty"`
	PageIdentifier *PageIdentifier `json:"pageIdentifier,omitempty" url:"pageIdentifier,omitempty"`
	// Describes the room ID. Only in use on Boarding endpoints, returns `0` when not applicable.
	RoomId       *int64                 `json:"roomId,omitempty" url:"roomId,omitempty"`
	IsSuccess    *IsSuccess             `json:"isSuccess,omitempty" url:"isSuccess,omitempty"`
	ResponseText *ResponseText          `json:"responseText,omitempty" url:"responseText,omitempty"`
	ResponseData *Responsedatanonobject `json:"responseData,omitempty" url:"responseData,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayabliApiResponse00Responsedatanonobject) GetResponseCode() *Responsecode {
	if p == nil {
		return nil
	}
	return p.ResponseCode
}

func (p *PayabliApiResponse00Responsedatanonobject) GetPageIdentifier() *PageIdentifier {
	if p == nil {
		return nil
	}
	return p.PageIdentifier
}

func (p *PayabliApiResponse00Responsedatanonobject) GetRoomId() *int64 {
	if p == nil {
		return nil
	}
	return p.RoomId
}

func (p *PayabliApiResponse00Responsedatanonobject) GetIsSuccess() *IsSuccess {
	if p == nil {
		return nil
	}
	return p.IsSuccess
}

func (p *PayabliApiResponse00Responsedatanonobject) GetResponseText() *ResponseText {
	if p == nil {
		return nil
	}
	return p.ResponseText
}

func (p *PayabliApiResponse00Responsedatanonobject) GetResponseData() *Responsedatanonobject {
	if p == nil {
		return nil
	}
	return p.ResponseData
}

func (p *PayabliApiResponse00Responsedatanonobject) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayabliApiResponse00Responsedatanonobject) UnmarshalJSON(data []byte) error {
	type unmarshaler PayabliApiResponse00Responsedatanonobject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayabliApiResponse00Responsedatanonobject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayabliApiResponse00Responsedatanonobject) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayabliApiResponse0ResponseData struct {
	AuthCode          *Authcode          `json:"AuthCode,omitempty" url:"AuthCode,omitempty"`
	AvsResponseText   *Avsresponsetext   `json:"avsResponseText,omitempty" url:"avsResponseText,omitempty"`
	CustomerId        *Customeridtrans   `json:"CustomerId,omitempty" url:"CustomerId,omitempty"`
	CvvResponseText   *Cvvresponsetext   `json:"cvvResponseText,omitempty" url:"cvvResponseText,omitempty"`
	MethodReferenceId *MethodReferenceId `json:"methodReferenceId,omitempty" url:"methodReferenceId,omitempty"`
	ReferenceId       *Referenceidtrans  `json:"ReferenceId,omitempty" url:"ReferenceId,omitempty"`
	ResultCode        *ResultCode        `json:"ResultCode,omitempty" url:"ResultCode,omitempty"`
	ResultText        *Resulttext        `json:"ResultText,omitempty" url:"ResultText,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayabliApiResponse0ResponseData) GetAuthCode() *Authcode {
	if p == nil {
		return nil
	}
	return p.AuthCode
}

func (p *PayabliApiResponse0ResponseData) GetAvsResponseText() *Avsresponsetext {
	if p == nil {
		return nil
	}
	return p.AvsResponseText
}

func (p *PayabliApiResponse0ResponseData) GetCustomerId() *Customeridtrans {
	if p == nil {
		return nil
	}
	return p.CustomerId
}

func (p *PayabliApiResponse0ResponseData) GetCvvResponseText() *Cvvresponsetext {
	if p == nil {
		return nil
	}
	return p.CvvResponseText
}

func (p *PayabliApiResponse0ResponseData) GetMethodReferenceId() *MethodReferenceId {
	if p == nil {
		return nil
	}
	return p.MethodReferenceId
}

func (p *PayabliApiResponse0ResponseData) GetReferenceId() *Referenceidtrans {
	if p == nil {
		return nil
	}
	return p.ReferenceId
}

func (p *PayabliApiResponse0ResponseData) GetResultCode() *ResultCode {
	if p == nil {
		return nil
	}
	return p.ResultCode
}

func (p *PayabliApiResponse0ResponseData) GetResultText() *Resulttext {
	if p == nil {
		return nil
	}
	return p.ResultText
}

func (p *PayabliApiResponse0ResponseData) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayabliApiResponse0ResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PayabliApiResponse0ResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayabliApiResponse0ResponseData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayabliApiResponse0ResponseData) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayabliApiResponseError400 struct {
	// Boolean indicating whether the operation was successful. A `true` value indicates success. A `false` value indicates failure.
	IsSuccess      *bool           `json:"isSuccess,omitempty" url:"isSuccess,omitempty"`
	Pageidentifier *PageIdentifier `json:"pageidentifier,omitempty" url:"pageidentifier,omitempty"`
	// A code that indicates the operation's failure reason. See [API Response Codes](https://docs.payabli.com/api-reference/api-responses) for a full reference.
	ResponseCode *int `json:"responseCode,omitempty" url:"responseCode,omitempty"`
	// Describes the reason for a failed operation and how to resolve it.
	ResponseData *PayabliApiResponseError400ResponseData `json:"responseData,omitempty" url:"responseData,omitempty"`
	// Response text for operation: 'Success' or 'Declined'.
	ResponseText *string `json:"responseText,omitempty" url:"responseText,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayabliApiResponseError400) GetIsSuccess() *bool {
	if p == nil {
		return nil
	}
	return p.IsSuccess
}

func (p *PayabliApiResponseError400) GetPageidentifier() *PageIdentifier {
	if p == nil {
		return nil
	}
	return p.Pageidentifier
}

func (p *PayabliApiResponseError400) GetResponseCode() *int {
	if p == nil {
		return nil
	}
	return p.ResponseCode
}

func (p *PayabliApiResponseError400) GetResponseData() *PayabliApiResponseError400ResponseData {
	if p == nil {
		return nil
	}
	return p.ResponseData
}

func (p *PayabliApiResponseError400) GetResponseText() *string {
	if p == nil {
		return nil
	}
	return p.ResponseText
}

func (p *PayabliApiResponseError400) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayabliApiResponseError400) UnmarshalJSON(data []byte) error {
	type unmarshaler PayabliApiResponseError400
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayabliApiResponseError400(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayabliApiResponseError400) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Describes the reason for a failed operation and how to resolve it.
type PayabliApiResponseError400ResponseData struct {
	// Describes the reason the operation failed.
	Explanation *string `json:"explanation,omitempty" url:"explanation,omitempty"`
	// Describes how to resolve the error.
	TodoAction *string `json:"todoAction,omitempty" url:"todoAction,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayabliApiResponseError400ResponseData) GetExplanation() *string {
	if p == nil {
		return nil
	}
	return p.Explanation
}

func (p *PayabliApiResponseError400ResponseData) GetTodoAction() *string {
	if p == nil {
		return nil
	}
	return p.TodoAction
}

func (p *PayabliApiResponseError400ResponseData) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayabliApiResponseError400ResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PayabliApiResponseError400ResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayabliApiResponseError400ResponseData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayabliApiResponseError400ResponseData) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayabliApiResponseGeneric2Part struct {
	IsSuccess    *IsSuccess    `json:"isSuccess,omitempty" url:"isSuccess,omitempty"`
	ResponseText *ResponseText `json:"responseText,omitempty" url:"responseText,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayabliApiResponseGeneric2Part) GetIsSuccess() *IsSuccess {
	if p == nil {
		return nil
	}
	return p.IsSuccess
}

func (p *PayabliApiResponseGeneric2Part) GetResponseText() *ResponseText {
	if p == nil {
		return nil
	}
	return p.ResponseText
}

func (p *PayabliApiResponseGeneric2Part) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayabliApiResponseGeneric2Part) UnmarshalJSON(data []byte) error {
	type unmarshaler PayabliApiResponseGeneric2Part
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayabliApiResponseGeneric2Part(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayabliApiResponseGeneric2Part) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayabliApiResponsePaylinks struct {
	IsSuccess      IsSuccess       `json:"isSuccess" url:"isSuccess"`
	PageIdentifier *PageIdentifier `json:"pageIdentifier,omitempty" url:"pageIdentifier,omitempty"`
	ResponseCode   Responsecode    `json:"responseCode" url:"responseCode"`
	// The paylink ID or error details.
	ResponseData Responsedata `json:"responseData" url:"responseData"`
	ResponseText ResponseText `json:"responseText" url:"responseText"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayabliApiResponsePaylinks) GetIsSuccess() IsSuccess {
	if p == nil {
		return false
	}
	return p.IsSuccess
}

func (p *PayabliApiResponsePaylinks) GetPageIdentifier() *PageIdentifier {
	if p == nil {
		return nil
	}
	return p.PageIdentifier
}

func (p *PayabliApiResponsePaylinks) GetResponseCode() Responsecode {
	if p == nil {
		return 0
	}
	return p.ResponseCode
}

func (p *PayabliApiResponsePaylinks) GetResponseData() Responsedata {
	if p == nil {
		return nil
	}
	return p.ResponseData
}

func (p *PayabliApiResponsePaylinks) GetResponseText() ResponseText {
	if p == nil {
		return ""
	}
	return p.ResponseText
}

func (p *PayabliApiResponsePaylinks) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayabliApiResponsePaylinks) UnmarshalJSON(data []byte) error {
	type unmarshaler PayabliApiResponsePaylinks
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayabliApiResponsePaylinks(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayabliApiResponsePaylinks) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayabliCredentials struct {
	AccountId   *string  `json:"accountId,omitempty" url:"accountId,omitempty"`
	CfeeFix     *float64 `json:"cfeeFix,omitempty" url:"cfeeFix,omitempty"`
	CfeeFloat   *float64 `json:"cfeeFloat,omitempty" url:"cfeeFloat,omitempty"`
	CfeeMax     *float64 `json:"cfeeMax,omitempty" url:"cfeeMax,omitempty"`
	CfeeMin     *float64 `json:"cfeeMin,omitempty" url:"cfeeMin,omitempty"`
	Maxticket   *float64 `json:"maxticket,omitempty" url:"maxticket,omitempty"`
	Minticket   *float64 `json:"minticket,omitempty" url:"minticket,omitempty"`
	Mode        *int     `json:"mode,omitempty" url:"mode,omitempty"`
	ReferenceId *int64   `json:"referenceId,omitempty" url:"referenceId,omitempty"`
	Service     *string  `json:"service,omitempty" url:"service,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayabliCredentials) GetAccountId() *string {
	if p == nil {
		return nil
	}
	return p.AccountId
}

func (p *PayabliCredentials) GetCfeeFix() *float64 {
	if p == nil {
		return nil
	}
	return p.CfeeFix
}

func (p *PayabliCredentials) GetCfeeFloat() *float64 {
	if p == nil {
		return nil
	}
	return p.CfeeFloat
}

func (p *PayabliCredentials) GetCfeeMax() *float64 {
	if p == nil {
		return nil
	}
	return p.CfeeMax
}

func (p *PayabliCredentials) GetCfeeMin() *float64 {
	if p == nil {
		return nil
	}
	return p.CfeeMin
}

func (p *PayabliCredentials) GetMaxticket() *float64 {
	if p == nil {
		return nil
	}
	return p.Maxticket
}

func (p *PayabliCredentials) GetMinticket() *float64 {
	if p == nil {
		return nil
	}
	return p.Minticket
}

func (p *PayabliCredentials) GetMode() *int {
	if p == nil {
		return nil
	}
	return p.Mode
}

func (p *PayabliCredentials) GetReferenceId() *int64 {
	if p == nil {
		return nil
	}
	return p.ReferenceId
}

func (p *PayabliCredentials) GetService() *string {
	if p == nil {
		return nil
	}
	return p.Service
}

func (p *PayabliCredentials) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayabliCredentials) UnmarshalJSON(data []byte) error {
	type unmarshaler PayabliCredentials
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayabliCredentials(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayabliCredentials) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayabliCredentialsPascal struct {
	Service          *string  `json:"Service,omitempty" url:"Service,omitempty"`
	Mode             *int     `json:"Mode,omitempty" url:"Mode,omitempty"`
	MinTicket        *float64 `json:"MinTicket,omitempty" url:"MinTicket,omitempty"`
	MaxTicket        *float64 `json:"MaxTicket,omitempty" url:"MaxTicket,omitempty"`
	CfeeFix          *float64 `json:"CfeeFix,omitempty" url:"CfeeFix,omitempty"`
	CfeeFloat        *float64 `json:"CfeeFloat,omitempty" url:"CfeeFloat,omitempty"`
	CfeeMin          *float64 `json:"CfeeMin,omitempty" url:"CfeeMin,omitempty"`
	CfeeMax          *float64 `json:"CfeeMax,omitempty" url:"CfeeMax,omitempty"`
	AccountId        *string  `json:"AccountId,omitempty" url:"AccountId,omitempty"`
	ReferenceId      *int64   `json:"ReferenceId,omitempty" url:"ReferenceId,omitempty"`
	AcceptSameDayAch *bool    `json:"acceptSameDayACH,omitempty" url:"acceptSameDayACH,omitempty"`
	// The default currency for the paypoint, either `USD` or `CAD`.
	Currency *string `json:"Currency,omitempty" url:"Currency,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayabliCredentialsPascal) GetService() *string {
	if p == nil {
		return nil
	}
	return p.Service
}

func (p *PayabliCredentialsPascal) GetMode() *int {
	if p == nil {
		return nil
	}
	return p.Mode
}

func (p *PayabliCredentialsPascal) GetMinTicket() *float64 {
	if p == nil {
		return nil
	}
	return p.MinTicket
}

func (p *PayabliCredentialsPascal) GetMaxTicket() *float64 {
	if p == nil {
		return nil
	}
	return p.MaxTicket
}

func (p *PayabliCredentialsPascal) GetCfeeFix() *float64 {
	if p == nil {
		return nil
	}
	return p.CfeeFix
}

func (p *PayabliCredentialsPascal) GetCfeeFloat() *float64 {
	if p == nil {
		return nil
	}
	return p.CfeeFloat
}

func (p *PayabliCredentialsPascal) GetCfeeMin() *float64 {
	if p == nil {
		return nil
	}
	return p.CfeeMin
}

func (p *PayabliCredentialsPascal) GetCfeeMax() *float64 {
	if p == nil {
		return nil
	}
	return p.CfeeMax
}

func (p *PayabliCredentialsPascal) GetAccountId() *string {
	if p == nil {
		return nil
	}
	return p.AccountId
}

func (p *PayabliCredentialsPascal) GetReferenceId() *int64 {
	if p == nil {
		return nil
	}
	return p.ReferenceId
}

func (p *PayabliCredentialsPascal) GetAcceptSameDayAch() *bool {
	if p == nil {
		return nil
	}
	return p.AcceptSameDayAch
}

func (p *PayabliCredentialsPascal) GetCurrency() *string {
	if p == nil {
		return nil
	}
	return p.Currency
}

func (p *PayabliCredentialsPascal) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayabliCredentialsPascal) UnmarshalJSON(data []byte) error {
	type unmarshaler PayabliCredentialsPascal
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayabliCredentialsPascal(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayabliCredentialsPascal) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayabliPages struct {
	AdditionalData *AdditionalData `json:"AdditionalData,omitempty" url:"AdditionalData,omitempty"`
	// Array of credential objects with active services for the page
	Credentials []*PayabliCredentials `json:"credentials,omitempty" url:"credentials,omitempty"`
	// Timestamp of last access to page structure
	LastAccess *time.Time `json:"lastAccess,omitempty" url:"lastAccess,omitempty"`
	// Sections of page
	PageContent    *PageContent    `json:"pageContent,omitempty" url:"pageContent,omitempty"`
	PageIdentifier *PageIdentifier `json:"pageIdentifier,omitempty" url:"pageIdentifier,omitempty"`
	// Settings of page
	PageSettings *PageSetting `json:"pageSettings,omitempty" url:"pageSettings,omitempty"`
	// Flag indicating if page is active to accept payments. `0` for false, `1` for true.
	Published *int `json:"published,omitempty" url:"published,omitempty"`
	// Sections of payment receipt
	ReceiptContent *ReceiptContent `json:"receiptContent,omitempty" url:"receiptContent,omitempty"`
	// Page identifier. Must be unique in platform.
	Subdomain *Subdomain `json:"subdomain,omitempty" url:"subdomain,omitempty"`
	// Total amount to pay in this page
	TotalAmount *float64 `json:"totalAmount,omitempty" url:"totalAmount,omitempty"`
	// Base64 encoded image of CAPTCHA associated to this page load
	ValidationCode *string `json:"validationCode,omitempty" url:"validationCode,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayabliPages) GetAdditionalData() *AdditionalData {
	if p == nil {
		return nil
	}
	return p.AdditionalData
}

func (p *PayabliPages) GetCredentials() []*PayabliCredentials {
	if p == nil {
		return nil
	}
	return p.Credentials
}

func (p *PayabliPages) GetLastAccess() *time.Time {
	if p == nil {
		return nil
	}
	return p.LastAccess
}

func (p *PayabliPages) GetPageContent() *PageContent {
	if p == nil {
		return nil
	}
	return p.PageContent
}

func (p *PayabliPages) GetPageIdentifier() *PageIdentifier {
	if p == nil {
		return nil
	}
	return p.PageIdentifier
}

func (p *PayabliPages) GetPageSettings() *PageSetting {
	if p == nil {
		return nil
	}
	return p.PageSettings
}

func (p *PayabliPages) GetPublished() *int {
	if p == nil {
		return nil
	}
	return p.Published
}

func (p *PayabliPages) GetReceiptContent() *ReceiptContent {
	if p == nil {
		return nil
	}
	return p.ReceiptContent
}

func (p *PayabliPages) GetSubdomain() *Subdomain {
	if p == nil {
		return nil
	}
	return p.Subdomain
}

func (p *PayabliPages) GetTotalAmount() *float64 {
	if p == nil {
		return nil
	}
	return p.TotalAmount
}

func (p *PayabliPages) GetValidationCode() *string {
	if p == nil {
		return nil
	}
	return p.ValidationCode
}

func (p *PayabliPages) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayabliPages) UnmarshalJSON(data []byte) error {
	type embed PayabliPages
	var unmarshaler = struct {
		embed
		LastAccess *internal.DateTime `json:"lastAccess,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PayabliPages(unmarshaler.embed)
	p.LastAccess = unmarshaler.LastAccess.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayabliPages) MarshalJSON() ([]byte, error) {
	type embed PayabliPages
	var marshaler = struct {
		embed
		LastAccess *internal.DateTime `json:"lastAccess,omitempty"`
	}{
		embed:      embed(*p),
		LastAccess: internal.NewOptionalDateTime(p.LastAccess),
	}
	return json.Marshal(marshaler)
}

func (p *PayabliPages) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Alternative name used to receive paper check.
type PayeeName = string

// Identifier of payment link associated to the invoice or bill.
type PaylinkId = string

type PaymentCategories struct {
	// Price/cost per unit of item or category.
	Amount float64 `json:"amount" url:"amount"`
	// Description of item or category
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Name of item or category.
	Label string `json:"label" url:"label"`
	// Quantity of item or category
	Qty *int `json:"qty,omitempty" url:"qty,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentCategories) GetAmount() float64 {
	if p == nil {
		return 0
	}
	return p.Amount
}

func (p *PaymentCategories) GetDescription() *string {
	if p == nil {
		return nil
	}
	return p.Description
}

func (p *PaymentCategories) GetLabel() string {
	if p == nil {
		return ""
	}
	return p.Label
}

func (p *PaymentCategories) GetQty() *int {
	if p == nil {
		return nil
	}
	return p.Qty
}

func (p *PaymentCategories) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentCategories) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentCategories
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentCategories(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentCategories) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Details about the payment.
type PaymentDetail struct {
	// Array of payment categories/line items describing the amount to be paid.
	// **Note**: These categories are for information only and aren't validated against the total amount provided.
	Categories []*PaymentCategories `json:"categories,omitempty" url:"categories,omitempty"`
	// Object containing image of paper check.
	CheckImage map[string]interface{} `json:"checkImage,omitempty" url:"checkImage,omitempty"`
	// A check number to be used in the ach transaction. **Required** for payment method = 'check'.
	CheckNumber *string `json:"checkNumber,omitempty" url:"checkNumber,omitempty"`
	// The currency for the transaction, `USD` or `CAD`. If your paypoint is configured for CAD, you must send the `CAD` value in this field, otherwise it defaults to USD, which will cause the transaction to fail.
	Currency *string `json:"currency,omitempty" url:"currency,omitempty"`
	// Service fee to be deducted from the total amount. This amount must be a number, percentages aren't accepted. If you are using a percentage-based fee schedule, you must calculate the value manually.
	ServiceFee *float64 `json:"serviceFee,omitempty" url:"serviceFee,omitempty"`
	// Split funding instructions for the transaction. See [Split a Transaction](/developers/developer-guides/money-in-split-funding) for more.
	SplitFunding *SplitFunding `json:"splitFunding,omitempty" url:"splitFunding,omitempty"`
	// Total amount to be charged. If a service fee is sent, then this amount should include the service fee."
	TotalAmount float64 `json:"totalAmount" url:"totalAmount"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentDetail) GetCategories() []*PaymentCategories {
	if p == nil {
		return nil
	}
	return p.Categories
}

func (p *PaymentDetail) GetCheckImage() map[string]interface{} {
	if p == nil {
		return nil
	}
	return p.CheckImage
}

func (p *PaymentDetail) GetCheckNumber() *string {
	if p == nil {
		return nil
	}
	return p.CheckNumber
}

func (p *PaymentDetail) GetCurrency() *string {
	if p == nil {
		return nil
	}
	return p.Currency
}

func (p *PaymentDetail) GetServiceFee() *float64 {
	if p == nil {
		return nil
	}
	return p.ServiceFee
}

func (p *PaymentDetail) GetSplitFunding() *SplitFunding {
	if p == nil {
		return nil
	}
	return p.SplitFunding
}

func (p *PaymentDetail) GetTotalAmount() float64 {
	if p == nil {
		return 0
	}
	return p.TotalAmount
}

func (p *PaymentDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentDetail(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentDetail) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The unique transaction ID. This value is a string representation of a long integer.
type PaymentIdString = string

// Description of the payment transaction status. See [the docs](/developers/references/money-in-statuses#money-in-transaction-status) for a full reference.
type PaymentTransStatusDescription = string

// Unique transaction ID.
type Paymentid = int64

// Customer information. May be required, depending on the paypoint's settings. Required for subscriptions.
type PayorDataRequest struct {
	AdditionalData  *AdditionalData              `json:"additionalData,omitempty" url:"additionalData,omitempty"`
	BillingAddress1 *BillingAddressNullable      `json:"billingAddress1,omitempty" url:"billingAddress1,omitempty"`
	BillingAddress2 *BillingAddressAddtlNullable `json:"billingAddress2,omitempty" url:"billingAddress2,omitempty"`
	BillingCity     *BillingCityNullable         `json:"billingCity,omitempty" url:"billingCity,omitempty"`
	BillingCountry  *BillingCountryNullable      `json:"billingCountry,omitempty" url:"billingCountry,omitempty"`
	BillingEmail    *Email                       `json:"billingEmail,omitempty" url:"billingEmail,omitempty"`
	BillingPhone    *PhoneNumber                 `json:"billingPhone,omitempty" url:"billingPhone,omitempty"`
	BillingState    *BillingStateNullable        `json:"billingState,omitempty" url:"billingState,omitempty"`
	// Customer's billing ZIP code. For Pay In functions, this field supports 5-digit and 9-digit ZIP codes and alphanumeric Canadian postal codes. For example: "37615-1234" or "37615".
	BillingZip *BillingZip `json:"billingZip,omitempty" url:"billingZip,omitempty"`
	// Customer's company name.
	Company        *string                 `json:"company,omitempty" url:"company,omitempty"`
	CustomerId     *CustomerId             `json:"customerId,omitempty" url:"customerId,omitempty"`
	CustomerNumber *CustomerNumberNullable `json:"customerNumber,omitempty" url:"customerNumber,omitempty"`
	// Customer/Payor first name.
	FirstName        *string           `json:"firstName,omitempty" url:"firstName,omitempty"`
	IdentifierFields *Identifierfields `json:"identifierFields,omitempty" url:"identifierFields,omitempty"`
	// Customer/Payor last name.
	LastName         *string                    `json:"lastName,omitempty" url:"lastName,omitempty"`
	ShippingAddress1 *Shippingaddress           `json:"shippingAddress1,omitempty" url:"shippingAddress1,omitempty"`
	ShippingAddress2 *Shippingaddressadditional `json:"shippingAddress2,omitempty" url:"shippingAddress2,omitempty"`
	ShippingCity     *Shippingcity              `json:"shippingCity,omitempty" url:"shippingCity,omitempty"`
	ShippingCountry  *Shippingcountry           `json:"shippingCountry,omitempty" url:"shippingCountry,omitempty"`
	ShippingState    *Shippingstate             `json:"shippingState,omitempty" url:"shippingState,omitempty"`
	ShippingZip      *Shippingzip               `json:"shippingZip,omitempty" url:"shippingZip,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayorDataRequest) GetAdditionalData() *AdditionalData {
	if p == nil {
		return nil
	}
	return p.AdditionalData
}

func (p *PayorDataRequest) GetBillingAddress1() *BillingAddressNullable {
	if p == nil {
		return nil
	}
	return p.BillingAddress1
}

func (p *PayorDataRequest) GetBillingAddress2() *BillingAddressAddtlNullable {
	if p == nil {
		return nil
	}
	return p.BillingAddress2
}

func (p *PayorDataRequest) GetBillingCity() *BillingCityNullable {
	if p == nil {
		return nil
	}
	return p.BillingCity
}

func (p *PayorDataRequest) GetBillingCountry() *BillingCountryNullable {
	if p == nil {
		return nil
	}
	return p.BillingCountry
}

func (p *PayorDataRequest) GetBillingEmail() *Email {
	if p == nil {
		return nil
	}
	return p.BillingEmail
}

func (p *PayorDataRequest) GetBillingPhone() *PhoneNumber {
	if p == nil {
		return nil
	}
	return p.BillingPhone
}

func (p *PayorDataRequest) GetBillingState() *BillingStateNullable {
	if p == nil {
		return nil
	}
	return p.BillingState
}

func (p *PayorDataRequest) GetBillingZip() *BillingZip {
	if p == nil {
		return nil
	}
	return p.BillingZip
}

func (p *PayorDataRequest) GetCompany() *string {
	if p == nil {
		return nil
	}
	return p.Company
}

func (p *PayorDataRequest) GetCustomerId() *CustomerId {
	if p == nil {
		return nil
	}
	return p.CustomerId
}

func (p *PayorDataRequest) GetCustomerNumber() *CustomerNumberNullable {
	if p == nil {
		return nil
	}
	return p.CustomerNumber
}

func (p *PayorDataRequest) GetFirstName() *string {
	if p == nil {
		return nil
	}
	return p.FirstName
}

func (p *PayorDataRequest) GetIdentifierFields() *Identifierfields {
	if p == nil {
		return nil
	}
	return p.IdentifierFields
}

func (p *PayorDataRequest) GetLastName() *string {
	if p == nil {
		return nil
	}
	return p.LastName
}

func (p *PayorDataRequest) GetShippingAddress1() *Shippingaddress {
	if p == nil {
		return nil
	}
	return p.ShippingAddress1
}

func (p *PayorDataRequest) GetShippingAddress2() *Shippingaddressadditional {
	if p == nil {
		return nil
	}
	return p.ShippingAddress2
}

func (p *PayorDataRequest) GetShippingCity() *Shippingcity {
	if p == nil {
		return nil
	}
	return p.ShippingCity
}

func (p *PayorDataRequest) GetShippingCountry() *Shippingcountry {
	if p == nil {
		return nil
	}
	return p.ShippingCountry
}

func (p *PayorDataRequest) GetShippingState() *Shippingstate {
	if p == nil {
		return nil
	}
	return p.ShippingState
}

func (p *PayorDataRequest) GetShippingZip() *Shippingzip {
	if p == nil {
		return nil
	}
	return p.ShippingZip
}

func (p *PayorDataRequest) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayorDataRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler PayorDataRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayorDataRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayorDataRequest) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayorElement struct {
	Enabled *Enabled `json:"enabled,omitempty" url:"enabled,omitempty"`
	// Array of Customer/Payor fields to show in section
	Fields []*PayorFields `json:"fields,omitempty" url:"fields,omitempty"`
	// Custom header text for section
	Header *string `json:"header,omitempty" url:"header,omitempty"`
	Order  *Order  `json:"order,omitempty" url:"order,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayorElement) GetEnabled() *Enabled {
	if p == nil {
		return nil
	}
	return p.Enabled
}

func (p *PayorElement) GetFields() []*PayorFields {
	if p == nil {
		return nil
	}
	return p.Fields
}

func (p *PayorElement) GetHeader() *string {
	if p == nil {
		return nil
	}
	return p.Header
}

func (p *PayorElement) GetOrder() *Order {
	if p == nil {
		return nil
	}
	return p.Order
}

func (p *PayorElement) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayorElement) UnmarshalJSON(data []byte) error {
	type unmarshaler PayorElement
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayorElement(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayorElement) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayorFields struct {
	// Flag indicating if the input field will show in container
	Display *bool `json:"display,omitempty" url:"display,omitempty"`
	// Flag indicating if the value in input field is read-only or not.
	Fixed *bool `json:"fixed,omitempty" url:"fixed,omitempty"`
	// Flag indicating if the input field is a customer identifier
	Identifier *bool `json:"identifier,omitempty" url:"identifier,omitempty"`
	// Label to display for field
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// Name of field to show. Should be one of the standard customer fields or a custom field name
	Name  *string `json:"name,omitempty" url:"name,omitempty"`
	Order *Order  `json:"order,omitempty" url:"order,omitempty"`
	// Flag indicating if the input field is required for validation
	Required *bool `json:"required,omitempty" url:"required,omitempty"`
	// Type of validation to apply to the input field Accepted values:
	//
	//   - alpha for alphabetical
	//
	//   - numbers for numeric
	//
	//   - text for alphanumeric
	//
	//   - email for masked email address input
	//
	//   - phone for US phone numbers
	Validation *string `json:"validation,omitempty" url:"validation,omitempty"`
	// Pre-populated value for field
	Value *string `json:"value,omitempty" url:"value,omitempty"`
	// Numeric value indicating the size of input relative to the container. Accepted values:
	//
	//   - 4 = 1/3
	//
	//   - 6 = 1/2
	//
	//   - 8 = 2/3
	//
	//   - 12 = 3/3
	Width *int `json:"width,omitempty" url:"width,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayorFields) GetDisplay() *bool {
	if p == nil {
		return nil
	}
	return p.Display
}

func (p *PayorFields) GetFixed() *bool {
	if p == nil {
		return nil
	}
	return p.Fixed
}

func (p *PayorFields) GetIdentifier() *bool {
	if p == nil {
		return nil
	}
	return p.Identifier
}

func (p *PayorFields) GetLabel() *string {
	if p == nil {
		return nil
	}
	return p.Label
}

func (p *PayorFields) GetName() *string {
	if p == nil {
		return nil
	}
	return p.Name
}

func (p *PayorFields) GetOrder() *Order {
	if p == nil {
		return nil
	}
	return p.Order
}

func (p *PayorFields) GetRequired() *bool {
	if p == nil {
		return nil
	}
	return p.Required
}

func (p *PayorFields) GetValidation() *string {
	if p == nil {
		return nil
	}
	return p.Validation
}

func (p *PayorFields) GetValue() *string {
	if p == nil {
		return nil
	}
	return p.Value
}

func (p *PayorFields) GetWidth() *int {
	if p == nil {
		return nil
	}
	return p.Width
}

func (p *PayorFields) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayorFields) UnmarshalJSON(data []byte) error {
	type unmarshaler PayorFields
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayorFields(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayorFields) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Unique ID for customer linked to the transaction.
type PayorId = int64

// The payout program associated with the transaction: managed or on-demand.
type PayoutProgram = string

type PaypointData struct {
	Address1           *AddressNullable            `json:"address1,omitempty" url:"address1,omitempty"`
	Address2           *AddressAddtlNullable       `json:"address2,omitempty" url:"address2,omitempty"`
	BankData           *BankData                   `json:"bankData,omitempty" url:"bankData,omitempty"`
	BoardingId         *BoardingId                 `json:"boardingId,omitempty" url:"boardingId,omitempty"`
	City               *CityNullable               `json:"city,omitempty" url:"city,omitempty"`
	Contacts           *ContactsField              `json:"contacts,omitempty" url:"contacts,omitempty"`
	Country            *CountryNullable            `json:"country,omitempty" url:"country,omitempty"`
	Credentials        []*PayabliCredentialsPascal `json:"credentials,omitempty" url:"credentials,omitempty"`
	DbaName            *Dbaname                    `json:"dbaName,omitempty" url:"dbaName,omitempty"`
	ExternalPaypointId *ExternalPaypointId         `json:"externalPaypointID,omitempty" url:"externalPaypointID,omitempty"`
	// Fax number
	Fax            *PhoneNumber     `json:"fax,omitempty" url:"fax,omitempty"`
	IdPaypoint     *Idpaypoint      `json:"idPaypoint,omitempty" url:"idPaypoint,omitempty"`
	LegalName      *Legalname       `json:"legalName,omitempty" url:"legalName,omitempty"`
	ParentOrg      *OrgData         `json:"parentOrg,omitempty" url:"parentOrg,omitempty"`
	PaypointStatus *Paypointstatus  `json:"paypointStatus,omitempty" url:"paypointStatus,omitempty"`
	Phone          *PhoneNumber     `json:"phone,omitempty" url:"phone,omitempty"`
	ServiceData    *Services        `json:"serviceData,omitempty" url:"serviceData,omitempty"`
	State          *StateNullable   `json:"state,omitempty" url:"state,omitempty"`
	Summary        *PaypointSummary `json:"summary,omitempty" url:"summary,omitempty"`
	TimeZone       *Timezone        `json:"timeZone,omitempty" url:"timeZone,omitempty"`
	WebsiteAddress *Website         `json:"websiteAddress,omitempty" url:"websiteAddress,omitempty"`
	Zip            *Zip             `json:"zip,omitempty" url:"zip,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaypointData) GetAddress1() *AddressNullable {
	if p == nil {
		return nil
	}
	return p.Address1
}

func (p *PaypointData) GetAddress2() *AddressAddtlNullable {
	if p == nil {
		return nil
	}
	return p.Address2
}

func (p *PaypointData) GetBankData() *BankData {
	if p == nil {
		return nil
	}
	return p.BankData
}

func (p *PaypointData) GetBoardingId() *BoardingId {
	if p == nil {
		return nil
	}
	return p.BoardingId
}

func (p *PaypointData) GetCity() *CityNullable {
	if p == nil {
		return nil
	}
	return p.City
}

func (p *PaypointData) GetContacts() *ContactsField {
	if p == nil {
		return nil
	}
	return p.Contacts
}

func (p *PaypointData) GetCountry() *CountryNullable {
	if p == nil {
		return nil
	}
	return p.Country
}

func (p *PaypointData) GetCredentials() []*PayabliCredentialsPascal {
	if p == nil {
		return nil
	}
	return p.Credentials
}

func (p *PaypointData) GetDbaName() *Dbaname {
	if p == nil {
		return nil
	}
	return p.DbaName
}

func (p *PaypointData) GetExternalPaypointId() *ExternalPaypointId {
	if p == nil {
		return nil
	}
	return p.ExternalPaypointId
}

func (p *PaypointData) GetFax() *PhoneNumber {
	if p == nil {
		return nil
	}
	return p.Fax
}

func (p *PaypointData) GetIdPaypoint() *Idpaypoint {
	if p == nil {
		return nil
	}
	return p.IdPaypoint
}

func (p *PaypointData) GetLegalName() *Legalname {
	if p == nil {
		return nil
	}
	return p.LegalName
}

func (p *PaypointData) GetParentOrg() *OrgData {
	if p == nil {
		return nil
	}
	return p.ParentOrg
}

func (p *PaypointData) GetPaypointStatus() *Paypointstatus {
	if p == nil {
		return nil
	}
	return p.PaypointStatus
}

func (p *PaypointData) GetPhone() *PhoneNumber {
	if p == nil {
		return nil
	}
	return p.Phone
}

func (p *PaypointData) GetServiceData() *Services {
	if p == nil {
		return nil
	}
	return p.ServiceData
}

func (p *PaypointData) GetState() *StateNullable {
	if p == nil {
		return nil
	}
	return p.State
}

func (p *PaypointData) GetSummary() *PaypointSummary {
	if p == nil {
		return nil
	}
	return p.Summary
}

func (p *PaypointData) GetTimeZone() *Timezone {
	if p == nil {
		return nil
	}
	return p.TimeZone
}

func (p *PaypointData) GetWebsiteAddress() *Website {
	if p == nil {
		return nil
	}
	return p.WebsiteAddress
}

func (p *PaypointData) GetZip() *Zip {
	if p == nil {
		return nil
	}
	return p.Zip
}

func (p *PaypointData) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaypointData) UnmarshalJSON(data []byte) error {
	type unmarshaler PaypointData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaypointData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaypointData) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaypointEntryConfig struct {
	EntryComment  *string         `json:"EntryComment,omitempty" url:"EntryComment,omitempty"`
	EntryLogo     *string         `json:"EntryLogo,omitempty" url:"EntryLogo,omitempty"`
	EntryName     *string         `json:"EntryName,omitempty" url:"EntryName,omitempty"`
	EntryPages    []*PayabliPages `json:"EntryPages,omitempty" url:"EntryPages,omitempty"`
	EntrySubtitle *string         `json:"EntrySubtitle,omitempty" url:"EntrySubtitle,omitempty"`
	EntryTitle    *string         `json:"EntryTitle,omitempty" url:"EntryTitle,omitempty"`
	IdEntry       *int64          `json:"IdEntry,omitempty" url:"IdEntry,omitempty"`
	Paypoint      *PaypointData   `json:"Paypoint,omitempty" url:"Paypoint,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaypointEntryConfig) GetEntryComment() *string {
	if p == nil {
		return nil
	}
	return p.EntryComment
}

func (p *PaypointEntryConfig) GetEntryLogo() *string {
	if p == nil {
		return nil
	}
	return p.EntryLogo
}

func (p *PaypointEntryConfig) GetEntryName() *string {
	if p == nil {
		return nil
	}
	return p.EntryName
}

func (p *PaypointEntryConfig) GetEntryPages() []*PayabliPages {
	if p == nil {
		return nil
	}
	return p.EntryPages
}

func (p *PaypointEntryConfig) GetEntrySubtitle() *string {
	if p == nil {
		return nil
	}
	return p.EntrySubtitle
}

func (p *PaypointEntryConfig) GetEntryTitle() *string {
	if p == nil {
		return nil
	}
	return p.EntryTitle
}

func (p *PaypointEntryConfig) GetIdEntry() *int64 {
	if p == nil {
		return nil
	}
	return p.IdEntry
}

func (p *PaypointEntryConfig) GetPaypoint() *PaypointData {
	if p == nil {
		return nil
	}
	return p.Paypoint
}

func (p *PaypointEntryConfig) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaypointEntryConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler PaypointEntryConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaypointEntryConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaypointEntryConfig) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The paypoint's ID. Note that this is different than the entryname.
type PaypointId = int64

// The paypoint name.
type PaypointName = string

type PaypointSummary struct {
	AmountSubs *float64 `json:"amountSubs,omitempty" url:"amountSubs,omitempty"`
	AmountTx   *float64 `json:"amountTx,omitempty" url:"amountTx,omitempty"`
	CountSubs  *int     `json:"countSubs,omitempty" url:"countSubs,omitempty"`
	CountTx    *int     `json:"countTx,omitempty" url:"countTx,omitempty"`
	Customers  *int     `json:"customers,omitempty" url:"customers,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaypointSummary) GetAmountSubs() *float64 {
	if p == nil {
		return nil
	}
	return p.AmountSubs
}

func (p *PaypointSummary) GetAmountTx() *float64 {
	if p == nil {
		return nil
	}
	return p.AmountTx
}

func (p *PaypointSummary) GetCountSubs() *int {
	if p == nil {
		return nil
	}
	return p.CountSubs
}

func (p *PaypointSummary) GetCountTx() *int {
	if p == nil {
		return nil
	}
	return p.CountTx
}

func (p *PaypointSummary) GetCustomers() *int {
	if p == nil {
		return nil
	}
	return p.Customers
}

func (p *PaypointSummary) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaypointSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler PaypointSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaypointSummary(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaypointSummary) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The paypoint's status.
//
// Active - `1`
//
// Inactive - 0
type Paypointstatus = int

// The difference between the configured pass-through fee and the fee amount sent in the request. When transferring funds, Payabli uses this field to deduct the fee difference and transfer the correct amount to the merchant.
//
// When a paypoint is set up to absorb fees, and the pass-through fee sent with the request is less than the configured amount, the difference must be covered by the merchant. See [Fee Configuration](/guides/passthrough-fees#fee-configuration) to learn more about pass-through fee settings.
type PendingFeeAmount = *float64

// Phone number.
type PhoneNumber = string

// Purchase order number.
type PurchaseOrder = string

type QueryCFeeTransaction struct {
	CFeeTransid      *string                `json:"cFeeTransid,omitempty" url:"cFeeTransid,omitempty"`
	FeeAmount        *float64               `json:"feeAmount,omitempty" url:"feeAmount,omitempty"`
	Operation        *string                `json:"operation,omitempty" url:"operation,omitempty"`
	RefundId         *int64                 `json:"refundId,omitempty" url:"refundId,omitempty"`
	ResponseData     map[string]interface{} `json:"responseData,omitempty" url:"responseData,omitempty"`
	SettlementStatus *int                   `json:"settlementStatus,omitempty" url:"settlementStatus,omitempty"`
	TransactionTime  *TransactionTime       `json:"transactionTime,omitempty" url:"transactionTime,omitempty"`
	TransStatus      *int                   `json:"transStatus,omitempty" url:"transStatus,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (q *QueryCFeeTransaction) GetCFeeTransid() *string {
	if q == nil {
		return nil
	}
	return q.CFeeTransid
}

func (q *QueryCFeeTransaction) GetFeeAmount() *float64 {
	if q == nil {
		return nil
	}
	return q.FeeAmount
}

func (q *QueryCFeeTransaction) GetOperation() *string {
	if q == nil {
		return nil
	}
	return q.Operation
}

func (q *QueryCFeeTransaction) GetRefundId() *int64 {
	if q == nil {
		return nil
	}
	return q.RefundId
}

func (q *QueryCFeeTransaction) GetResponseData() map[string]interface{} {
	if q == nil {
		return nil
	}
	return q.ResponseData
}

func (q *QueryCFeeTransaction) GetSettlementStatus() *int {
	if q == nil {
		return nil
	}
	return q.SettlementStatus
}

func (q *QueryCFeeTransaction) GetTransactionTime() *TransactionTime {
	if q == nil {
		return nil
	}
	return q.TransactionTime
}

func (q *QueryCFeeTransaction) GetTransStatus() *int {
	if q == nil {
		return nil
	}
	return q.TransStatus
}

func (q *QueryCFeeTransaction) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryCFeeTransaction) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryCFeeTransaction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QueryCFeeTransaction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties
	q.rawJSON = json.RawMessage(data)
	return nil
}

func (q *QueryCFeeTransaction) String() string {
	if len(q.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(q.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type QueryPaymentData struct {
	AccountExp       *Accountexp       `json:"AccountExp,omitempty" url:"AccountExp,omitempty"`
	AccountId        *Accountid        `json:"accountId,omitempty" url:"accountId,omitempty"`
	AccountType      *Accounttype      `json:"AccountType,omitempty" url:"AccountType,omitempty"`
	AccountZip       *Accountzip       `json:"AccountZip,omitempty" url:"AccountZip,omitempty"`
	BinData          *BinData          `json:"binData,omitempty" url:"binData,omitempty"`
	HolderName       *Holdername       `json:"HolderName,omitempty" url:"HolderName,omitempty"`
	Initiator        *Initiator        `json:"Initiator,omitempty" url:"Initiator,omitempty"`
	MaskedAccount    *Maskedaccount    `json:"MaskedAccount,omitempty" url:"MaskedAccount,omitempty"`
	OrderDescription *Orderdescription `json:"orderDescription,omitempty" url:"orderDescription,omitempty"`
	PaymentDetails   *PaymentDetail    `json:"paymentDetails,omitempty" url:"paymentDetails,omitempty"`
	Sequence         *Sequence         `json:"Sequence,omitempty" url:"Sequence,omitempty"`
	SignatureData    *Signaturedata    `json:"SignatureData,omitempty" url:"SignatureData,omitempty"`
	// Identifier of stored payment method used in transaction.
	StoredId              *Storedmethodid        `json:"StoredId,omitempty" url:"StoredId,omitempty"`
	StoredMethodUsageType *StoredMethodUsageType `json:"StoredMethodUsageType,omitempty" url:"StoredMethodUsageType,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (q *QueryPaymentData) GetAccountExp() *Accountexp {
	if q == nil {
		return nil
	}
	return q.AccountExp
}

func (q *QueryPaymentData) GetAccountId() *Accountid {
	if q == nil {
		return nil
	}
	return q.AccountId
}

func (q *QueryPaymentData) GetAccountType() *Accounttype {
	if q == nil {
		return nil
	}
	return q.AccountType
}

func (q *QueryPaymentData) GetAccountZip() *Accountzip {
	if q == nil {
		return nil
	}
	return q.AccountZip
}

func (q *QueryPaymentData) GetBinData() *BinData {
	if q == nil {
		return nil
	}
	return q.BinData
}

func (q *QueryPaymentData) GetHolderName() *Holdername {
	if q == nil {
		return nil
	}
	return q.HolderName
}

func (q *QueryPaymentData) GetInitiator() *Initiator {
	if q == nil {
		return nil
	}
	return q.Initiator
}

func (q *QueryPaymentData) GetMaskedAccount() *Maskedaccount {
	if q == nil {
		return nil
	}
	return q.MaskedAccount
}

func (q *QueryPaymentData) GetOrderDescription() *Orderdescription {
	if q == nil {
		return nil
	}
	return q.OrderDescription
}

func (q *QueryPaymentData) GetPaymentDetails() *PaymentDetail {
	if q == nil {
		return nil
	}
	return q.PaymentDetails
}

func (q *QueryPaymentData) GetSequence() *Sequence {
	if q == nil {
		return nil
	}
	return q.Sequence
}

func (q *QueryPaymentData) GetSignatureData() *Signaturedata {
	if q == nil {
		return nil
	}
	return q.SignatureData
}

func (q *QueryPaymentData) GetStoredId() *Storedmethodid {
	if q == nil {
		return nil
	}
	return q.StoredId
}

func (q *QueryPaymentData) GetStoredMethodUsageType() *StoredMethodUsageType {
	if q == nil {
		return nil
	}
	return q.StoredMethodUsageType
}

func (q *QueryPaymentData) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryPaymentData) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryPaymentData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QueryPaymentData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties
	q.rawJSON = json.RawMessage(data)
	return nil
}

func (q *QueryPaymentData) String() string {
	if len(q.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(q.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type QueryResponse struct {
	Records []interface{} `json:"records,omitempty" url:"records,omitempty"`
	Summary *string       `json:"summary,omitempty" url:"summary,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (q *QueryResponse) GetRecords() []interface{} {
	if q == nil {
		return nil
	}
	return q.Records
}

func (q *QueryResponse) GetSummary() *string {
	if q == nil {
		return nil
	}
	return q.Summary
}

func (q *QueryResponse) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QueryResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties
	q.rawJSON = json.RawMessage(data)
	return nil
}

func (q *QueryResponse) String() string {
	if len(q.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(q.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

// The transaction's response data.
type QueryResponseData struct {
	Authcode *Authcode `json:"authcode,omitempty" url:"authcode,omitempty"`
	// Text code describing the result for address validation (applies only for card transactions).
	Avsresponse *string `json:"avsresponse,omitempty" url:"avsresponse,omitempty"`
	// Text code describing the result for address validation (applies only for card transactions).
	AvsresponseText *string `json:"avsresponse_text,omitempty" url:"avsresponse_text,omitempty"`
	// Text code describing the result for CVV validation (applies only for card transactions).
	Cvvresponse *string `json:"cvvresponse,omitempty" url:"cvvresponse,omitempty"`
	// Text code describing the result for CVV validation (applies only for card transactions).
	CvvresponseText *string `json:"cvvresponse_text,omitempty" url:"cvvresponse_text,omitempty"`
	// EMV authorization response data, applicable for card transactions.
	EmvAuthResponseData *string  `json:"emv_auth_response_data,omitempty" url:"emv_auth_response_data,omitempty"`
	Orderid             *OrderId `json:"orderid,omitempty" url:"orderid,omitempty"`
	// Response text for operation: 'Success' or 'Declined'.
	Response *string `json:"response,omitempty" url:"response,omitempty"`
	// Internal result code processing the transaction. Value 1 indicates successful operation, values 2 and 3 indicate errors.
	ResponseCode *string `json:"response_code,omitempty" url:"response_code,omitempty"`
	// Text describing the result. If resultCode = 1, will return 'Approved' or a general success message. If resultCode = 2 or 3, will contain the cause of the decline.
	ResponseCodeText *string `json:"response_code_text,omitempty" url:"response_code_text,omitempty"`
	// Text describing the result. If resultCode = 1, will return 'Approved' or a general success message. If resultCode = 2 or 3, will contain the cause of the decline.
	Responsetext *string `json:"responsetext,omitempty" url:"responsetext,omitempty"`
	// The transaction identifier in Payabli.
	Transactionid *string `json:"transactionid,omitempty" url:"transactionid,omitempty"`
	// Type of transaction or operation.
	Type *string `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (q *QueryResponseData) GetAuthcode() *Authcode {
	if q == nil {
		return nil
	}
	return q.Authcode
}

func (q *QueryResponseData) GetAvsresponse() *string {
	if q == nil {
		return nil
	}
	return q.Avsresponse
}

func (q *QueryResponseData) GetAvsresponseText() *string {
	if q == nil {
		return nil
	}
	return q.AvsresponseText
}

func (q *QueryResponseData) GetCvvresponse() *string {
	if q == nil {
		return nil
	}
	return q.Cvvresponse
}

func (q *QueryResponseData) GetCvvresponseText() *string {
	if q == nil {
		return nil
	}
	return q.CvvresponseText
}

func (q *QueryResponseData) GetEmvAuthResponseData() *string {
	if q == nil {
		return nil
	}
	return q.EmvAuthResponseData
}

func (q *QueryResponseData) GetOrderid() *OrderId {
	if q == nil {
		return nil
	}
	return q.Orderid
}

func (q *QueryResponseData) GetResponse() *string {
	if q == nil {
		return nil
	}
	return q.Response
}

func (q *QueryResponseData) GetResponseCode() *string {
	if q == nil {
		return nil
	}
	return q.ResponseCode
}

func (q *QueryResponseData) GetResponseCodeText() *string {
	if q == nil {
		return nil
	}
	return q.ResponseCodeText
}

func (q *QueryResponseData) GetResponsetext() *string {
	if q == nil {
		return nil
	}
	return q.Responsetext
}

func (q *QueryResponseData) GetTransactionid() *string {
	if q == nil {
		return nil
	}
	return q.Transactionid
}

func (q *QueryResponseData) GetType() *string {
	if q == nil {
		return nil
	}
	return q.Type
}

func (q *QueryResponseData) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QueryResponseData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties
	q.rawJSON = json.RawMessage(data)
	return nil
}

func (q *QueryResponseData) String() string {
	if len(q.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(q.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type QuerySummary struct {
	PageIdentifier *PageIdentifier `json:"pageIdentifier,omitempty" url:"pageIdentifier,omitempty"`
	PageSize       *Pagesize       `json:"pageSize,omitempty" url:"pageSize,omitempty"`
	// Total amount for the records.
	TotalAmount *float64 `json:"totalAmount,omitempty" url:"totalAmount,omitempty"`
	// Total net amount for the records.
	TotalNetAmount *float64      `json:"totalNetAmount,omitempty" url:"totalNetAmount,omitempty"`
	TotalPages     *Totalrecords `json:"totalPages,omitempty" url:"totalPages,omitempty"`
	TotalRecords   *Totalrecords `json:"totalRecords,omitempty" url:"totalRecords,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (q *QuerySummary) GetPageIdentifier() *PageIdentifier {
	if q == nil {
		return nil
	}
	return q.PageIdentifier
}

func (q *QuerySummary) GetPageSize() *Pagesize {
	if q == nil {
		return nil
	}
	return q.PageSize
}

func (q *QuerySummary) GetTotalAmount() *float64 {
	if q == nil {
		return nil
	}
	return q.TotalAmount
}

func (q *QuerySummary) GetTotalNetAmount() *float64 {
	if q == nil {
		return nil
	}
	return q.TotalNetAmount
}

func (q *QuerySummary) GetTotalPages() *Totalrecords {
	if q == nil {
		return nil
	}
	return q.TotalPages
}

func (q *QuerySummary) GetTotalRecords() *Totalrecords {
	if q == nil {
		return nil
	}
	return q.TotalRecords
}

func (q *QuerySummary) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QuerySummary) UnmarshalJSON(data []byte) error {
	type unmarshaler QuerySummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QuerySummary(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties
	q.rawJSON = json.RawMessage(data)
	return nil
}

func (q *QuerySummary) String() string {
	if len(q.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(q.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type QueryTransactionEvents struct {
	// Any data associated to the event received from processor. Contents vary by event type.
	EventData *QueryTransactionEventsEventData `json:"EventData,omitempty" url:"EventData,omitempty"`
	// Date and time of event.
	EventTime *time.Time `json:"EventTime,omitempty" url:"EventTime,omitempty"`
	// Event descriptor. See [TransEvent Reference](/developers/references/transevents) for more details.
	TransEvent *string `json:"TransEvent,omitempty" url:"TransEvent,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (q *QueryTransactionEvents) GetEventData() *QueryTransactionEventsEventData {
	if q == nil {
		return nil
	}
	return q.EventData
}

func (q *QueryTransactionEvents) GetEventTime() *time.Time {
	if q == nil {
		return nil
	}
	return q.EventTime
}

func (q *QueryTransactionEvents) GetTransEvent() *string {
	if q == nil {
		return nil
	}
	return q.TransEvent
}

func (q *QueryTransactionEvents) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryTransactionEvents) UnmarshalJSON(data []byte) error {
	type embed QueryTransactionEvents
	var unmarshaler = struct {
		embed
		EventTime *internal.DateTime `json:"EventTime,omitempty"`
	}{
		embed: embed(*q),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*q = QueryTransactionEvents(unmarshaler.embed)
	q.EventTime = unmarshaler.EventTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties
	q.rawJSON = json.RawMessage(data)
	return nil
}

func (q *QueryTransactionEvents) MarshalJSON() ([]byte, error) {
	type embed QueryTransactionEvents
	var marshaler = struct {
		embed
		EventTime *internal.DateTime `json:"EventTime,omitempty"`
	}{
		embed:     embed(*q),
		EventTime: internal.NewOptionalDateTime(q.EventTime),
	}
	return json.Marshal(marshaler)
}

func (q *QueryTransactionEvents) String() string {
	if len(q.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(q.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

// Any data associated to the event received from processor. Contents vary by event type.
type QueryTransactionEventsEventData struct {
	StringUnknownMap map[string]interface{}
	String           string

	typ string
}

func (q *QueryTransactionEventsEventData) GetStringUnknownMap() map[string]interface{} {
	if q == nil {
		return nil
	}
	return q.StringUnknownMap
}

func (q *QueryTransactionEventsEventData) GetString() string {
	if q == nil {
		return ""
	}
	return q.String
}

func (q *QueryTransactionEventsEventData) UnmarshalJSON(data []byte) error {
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		q.typ = "StringUnknownMap"
		q.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		q.typ = "String"
		q.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, q)
}

func (q QueryTransactionEventsEventData) MarshalJSON() ([]byte, error) {
	if q.typ == "StringUnknownMap" || q.StringUnknownMap != nil {
		return json.Marshal(q.StringUnknownMap)
	}
	if q.typ == "String" || q.String != "" {
		return json.Marshal(q.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", q)
}

type QueryTransactionEventsEventDataVisitor interface {
	VisitStringUnknownMap(map[string]interface{}) error
	VisitString(string) error
}

func (q *QueryTransactionEventsEventData) Accept(visitor QueryTransactionEventsEventDataVisitor) error {
	if q.typ == "StringUnknownMap" || q.StringUnknownMap != nil {
		return visitor.VisitStringUnknownMap(q.StringUnknownMap)
	}
	if q.typ == "String" || q.String != "" {
		return visitor.VisitString(q.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", q)
}

type QueryTransactionPayorData struct {
	// Array of field names to be used as identifiers.
	Identifiers []interface{} `json:"Identifiers,omitempty" url:"Identifiers,omitempty"`
	// Customer/Payor first name.
	FirstName *string `json:"FirstName,omitempty" url:"FirstName,omitempty"`
	// Customer/Payor last name.
	LastName *string `json:"LastName,omitempty" url:"LastName,omitempty"`
	// Customer's company name.
	CompanyName *string `json:"CompanyName,omitempty" url:"CompanyName,omitempty"`
	// Customer's billing address.
	BillingAddress1 *string `json:"BillingAddress1,omitempty" url:"BillingAddress1,omitempty"`
	// Additional line for Customer's billing address.
	BillingAddress2 *string `json:"BillingAddress2,omitempty" url:"BillingAddress2,omitempty"`
	// Customer's billing city.
	BillingCity *string `json:"BillingCity,omitempty" url:"BillingCity,omitempty"`
	// Customer's billing state. Must be 2-letter state code for address in US.
	BillingState *string `json:"BillingState,omitempty" url:"BillingState,omitempty"`
	// Customer's billing ZIP code.
	BillingZip *BillingZip `json:"BillingZip,omitempty" url:"BillingZip,omitempty"`
	// Customer's billing country.
	BillingCountry *string `json:"BillingCountry,omitempty" url:"BillingCountry,omitempty"`
	// Customer's phone number.
	BillingPhone *string `json:"BillingPhone,omitempty" url:"BillingPhone,omitempty"`
	// Customer's email address.
	BillingEmail     *Email                     `json:"BillingEmail,omitempty" url:"BillingEmail,omitempty"`
	CustomerNumber   *CustomerNumberNullable    `json:"CustomerNumber,omitempty" url:"CustomerNumber,omitempty"`
	ShippingAddress1 *Shippingaddress           `json:"ShippingAddress1,omitempty" url:"ShippingAddress1,omitempty"`
	ShippingAddress2 *Shippingaddressadditional `json:"ShippingAddress2,omitempty" url:"ShippingAddress2,omitempty"`
	ShippingCity     *Shippingcity              `json:"ShippingCity,omitempty" url:"ShippingCity,omitempty"`
	ShippingState    *Shippingstate             `json:"ShippingState,omitempty" url:"ShippingState,omitempty"`
	ShippingZip      *Shippingzip               `json:"ShippingZip,omitempty" url:"ShippingZip,omitempty"`
	ShippingCountry  *Shippingcountry           `json:"ShippingCountry,omitempty" url:"ShippingCountry,omitempty"`
	CustomerId       *CustomerId                `json:"customerId,omitempty" url:"customerId,omitempty"`
	CustomerStatus   *CustomerStatus            `json:"customerStatus,omitempty" url:"customerStatus,omitempty"`
	AdditionalData   *AdditionalDataString      `json:"AdditionalData,omitempty" url:"AdditionalData,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (q *QueryTransactionPayorData) GetIdentifiers() []interface{} {
	if q == nil {
		return nil
	}
	return q.Identifiers
}

func (q *QueryTransactionPayorData) GetFirstName() *string {
	if q == nil {
		return nil
	}
	return q.FirstName
}

func (q *QueryTransactionPayorData) GetLastName() *string {
	if q == nil {
		return nil
	}
	return q.LastName
}

func (q *QueryTransactionPayorData) GetCompanyName() *string {
	if q == nil {
		return nil
	}
	return q.CompanyName
}

func (q *QueryTransactionPayorData) GetBillingAddress1() *string {
	if q == nil {
		return nil
	}
	return q.BillingAddress1
}

func (q *QueryTransactionPayorData) GetBillingAddress2() *string {
	if q == nil {
		return nil
	}
	return q.BillingAddress2
}

func (q *QueryTransactionPayorData) GetBillingCity() *string {
	if q == nil {
		return nil
	}
	return q.BillingCity
}

func (q *QueryTransactionPayorData) GetBillingState() *string {
	if q == nil {
		return nil
	}
	return q.BillingState
}

func (q *QueryTransactionPayorData) GetBillingZip() *BillingZip {
	if q == nil {
		return nil
	}
	return q.BillingZip
}

func (q *QueryTransactionPayorData) GetBillingCountry() *string {
	if q == nil {
		return nil
	}
	return q.BillingCountry
}

func (q *QueryTransactionPayorData) GetBillingPhone() *string {
	if q == nil {
		return nil
	}
	return q.BillingPhone
}

func (q *QueryTransactionPayorData) GetBillingEmail() *Email {
	if q == nil {
		return nil
	}
	return q.BillingEmail
}

func (q *QueryTransactionPayorData) GetCustomerNumber() *CustomerNumberNullable {
	if q == nil {
		return nil
	}
	return q.CustomerNumber
}

func (q *QueryTransactionPayorData) GetShippingAddress1() *Shippingaddress {
	if q == nil {
		return nil
	}
	return q.ShippingAddress1
}

func (q *QueryTransactionPayorData) GetShippingAddress2() *Shippingaddressadditional {
	if q == nil {
		return nil
	}
	return q.ShippingAddress2
}

func (q *QueryTransactionPayorData) GetShippingCity() *Shippingcity {
	if q == nil {
		return nil
	}
	return q.ShippingCity
}

func (q *QueryTransactionPayorData) GetShippingState() *Shippingstate {
	if q == nil {
		return nil
	}
	return q.ShippingState
}

func (q *QueryTransactionPayorData) GetShippingZip() *Shippingzip {
	if q == nil {
		return nil
	}
	return q.ShippingZip
}

func (q *QueryTransactionPayorData) GetShippingCountry() *Shippingcountry {
	if q == nil {
		return nil
	}
	return q.ShippingCountry
}

func (q *QueryTransactionPayorData) GetCustomerId() *CustomerId {
	if q == nil {
		return nil
	}
	return q.CustomerId
}

func (q *QueryTransactionPayorData) GetCustomerStatus() *CustomerStatus {
	if q == nil {
		return nil
	}
	return q.CustomerStatus
}

func (q *QueryTransactionPayorData) GetAdditionalData() *AdditionalDataString {
	if q == nil {
		return nil
	}
	return q.AdditionalData
}

func (q *QueryTransactionPayorData) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryTransactionPayorData) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryTransactionPayorData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QueryTransactionPayorData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties
	q.rawJSON = json.RawMessage(data)
	return nil
}

func (q *QueryTransactionPayorData) String() string {
	if len(q.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(q.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

// When `true`, the element is read-only.
type ReadOnly = *bool

// Object containing receipt body configuration
type ReceiptContent struct {
	// Section amount of payment receipt
	Amount *Element `json:"amount,omitempty" url:"amount,omitempty"`
	// Section contactUs of payment receipt
	ContactUs *Element `json:"contactUs,omitempty" url:"contactUs,omitempty"`
	// Section payment details of payment receipt
	Details *Element `json:"details,omitempty" url:"details,omitempty"`
	// Section logo of payment receipt
	Logo *Element `json:"logo,omitempty" url:"logo,omitempty"`
	// Section message of payment receipt
	MessageBeforeButton *LabelElement `json:"messageBeforeButton,omitempty" url:"messageBeforeButton,omitempty"`
	// Section page of payment receipt
	Page *PageElement `json:"page,omitempty" url:"page,omitempty"`
	// Section payment button of payment receipt
	PaymentButton *LabelElement `json:"paymentButton,omitempty" url:"paymentButton,omitempty"`
	// Section payment information of payment receipt
	PaymentInformation *Element `json:"paymentInformation,omitempty" url:"paymentInformation,omitempty"`
	// The receipt's settings.
	Settings *SettingElement `json:"settings,omitempty" url:"settings,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ReceiptContent) GetAmount() *Element {
	if r == nil {
		return nil
	}
	return r.Amount
}

func (r *ReceiptContent) GetContactUs() *Element {
	if r == nil {
		return nil
	}
	return r.ContactUs
}

func (r *ReceiptContent) GetDetails() *Element {
	if r == nil {
		return nil
	}
	return r.Details
}

func (r *ReceiptContent) GetLogo() *Element {
	if r == nil {
		return nil
	}
	return r.Logo
}

func (r *ReceiptContent) GetMessageBeforeButton() *LabelElement {
	if r == nil {
		return nil
	}
	return r.MessageBeforeButton
}

func (r *ReceiptContent) GetPage() *PageElement {
	if r == nil {
		return nil
	}
	return r.Page
}

func (r *ReceiptContent) GetPaymentButton() *LabelElement {
	if r == nil {
		return nil
	}
	return r.PaymentButton
}

func (r *ReceiptContent) GetPaymentInformation() *Element {
	if r == nil {
		return nil
	}
	return r.PaymentInformation
}

func (r *ReceiptContent) GetSettings() *SettingElement {
	if r == nil {
		return nil
	}
	return r.Settings
}

func (r *ReceiptContent) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReceiptContent) UnmarshalJSON(data []byte) error {
	type unmarshaler ReceiptContent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReceiptContent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReceiptContent) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// When `true`, Payabli will send the applicant a boarding link. Set this value to `false` if you are sending pre-filled applications via the API and don't want Payabli to send the applicant an email to complete the boarding application.
type RecipientEmailNotification = bool

type ReferenceName = string

type ReferenceTemplateId = int64

// The transaction identifier in Payabli.
type Referenceidtrans = string

// Identifier of refund transaction linked to this payment.
type RefundId = int64

// Remittance email address. Used for sending virtual cards and other information about payouts.
type RemitEmail = string

// Remittance address. Used for mailing paper checks.
type Remitaddress1 = string

// Remittance address additional line. Used for mailing paper checks.
type Remitaddress2 = string

// Remittance address city. Used for mailing paper checks.
type Remitcity = string

// Remittance address country. Used for mailing paper checks.
type Remitcountry = string

// Remittance address state. Used for mailing paper checks.
type Remitstate = string

// Remittance address ZIP code. Used for mailing paper checks.
type Remitzip = string

// Email address for organization-level communications, such as messages about why an application was declined. This is required by commerce laws in the US.
type ReplyToEmail = string

// When `true`, the element is required.
type RequiredElement = bool

// Response text for operation: 'Success' or 'Declined'.
type ResponseText = string

// Code for the response. Learn more in [API Response Codes](/api-reference/api-responses).
type Responsecode = int

// The object containing the response data.
type Responsedata = map[string]interface{}

// The response data.
type Responsedatanonobject struct {
	String  string
	Integer int

	typ string
}

func (r *Responsedatanonobject) GetString() string {
	if r == nil {
		return ""
	}
	return r.String
}

func (r *Responsedatanonobject) GetInteger() int {
	if r == nil {
		return 0
	}
	return r.Integer
}

func (r *Responsedatanonobject) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typ = "String"
		r.String = valueString
		return nil
	}
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		r.typ = "Integer"
		r.Integer = valueInteger
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r Responsedatanonobject) MarshalJSON() ([]byte, error) {
	if r.typ == "String" || r.String != "" {
		return json.Marshal(r.String)
	}
	if r.typ == "Integer" || r.Integer != 0 {
		return json.Marshal(r.Integer)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", r)
}

type ResponsedatanonobjectVisitor interface {
	VisitString(string) error
	VisitInteger(int) error
}

func (r *Responsedatanonobject) Accept(visitor ResponsedatanonobjectVisitor) error {
	if r.typ == "String" || r.String != "" {
		return visitor.VisitString(r.String)
	}
	if r.typ == "Integer" || r.Integer != 0 {
		return visitor.VisitInteger(r.Integer)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", r)
}

// Result code for the operation. Value 1 indicates a successful operation,
// values 2 and 3 indicate errors. A value of 10 indicates that an operation
// has been initiated and is pending.
type ResultCode = int

// Text describing the result. If `ResultCode` = 1, will return 'Approved' or a general success message. If `ResultCodeâ€œ = 2 or 3, will contain the cause of the error or decline.
type Resulttext = string

// When `true`, the applicant can save an incomplete application and resume it later. When `false`, the applicant  won't have an option to save their progress, and must complete the application in one session.
type Resumable = bool

// Identifier of return/chargeback transaction linked to this payment.
type ReturnedId = int64

// Action taken due to risk assessment
type RiskAction = string

// Numeric code representing the risk action
type RiskActionCode = *int

// Indicates if the transaction was flagged for risk
type RiskFlagged = *bool

// Timestamp when the transaction was flagged for risk
type RiskFlaggedOn = *time.Time

// Reason for risk flagging
type RiskReason = string

// Current risk status of the transaction
type RiskStatus = string

// Field not in use on this endpoint. It always returns `0`.
type RoomIdNotInUse = int64

// Routing number of bank account.
type RoutingAccount = string

type SalesCode = string

// When `true`, Payabli saves the payment method if the transaction is successful. The payment method ID is returned in the response as `methodReferenceId`. Defaults to `false`.
type SaveIfSuccess = *bool

// ID of the recurring payment schedule associated with the transaction.
type ScheduleId = int64

// The order of the transaction for cardholder-initiated transaction (CIT) and merchant-initiated transaction (MIT) purposes. This field is automatically detected and populated by Payabli.
//
// Available values:
//
//   - `first`: The first use of the payment method. This is almost always a cardholder-initiated transaction.
//
//   - `subsequent`: For merchant-initiated transactions after the first use of the payment method.
//
//     See [Understanding CIT and MIT Indicators](/guides/money-in-cit-mit) for more information.
type Sequence = string

// Controls which services will be enabled for the merchant.
type Services struct {
	Ach  *AchSetup  `json:"ach,omitempty" url:"ach,omitempty"`
	Card *CardSetup `json:"card,omitempty" url:"card,omitempty"`
	Odp  *OdpSetup  `json:"odp,omitempty" url:"odp,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Services) GetAch() *AchSetup {
	if s == nil {
		return nil
	}
	return s.Ach
}

func (s *Services) GetCard() *CardSetup {
	if s == nil {
		return nil
	}
	return s.Card
}

func (s *Services) GetOdp() *OdpSetup {
	if s == nil {
		return nil
	}
	return s.Odp
}

func (s *Services) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Services) UnmarshalJSON(data []byte) error {
	type unmarshaler Services
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Services(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Services) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SettingElement struct {
	Enabled *Enabled `json:"enabled,omitempty" url:"enabled,omitempty"`
	// Fields to display on the reciept.
	Fields []*DisplayProperty `json:"fields,omitempty" url:"fields,omitempty"`
	Order  *Order             `json:"order,omitempty" url:"order,omitempty"`
	// When `true`, Payabli automatically sends the receipt to the payor email address.
	SendAuto *bool `json:"sendAuto,omitempty" url:"sendAuto,omitempty"`
	// When `true`, you must send the reciept to the payor manually using the [/MoneyIn/sendreceipt/\{transId\}](/api-reference/moneyin/send-receipt-for-transaction) endpoint.
	SendManual *bool `json:"sendManual,omitempty" url:"sendManual,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SettingElement) GetEnabled() *Enabled {
	if s == nil {
		return nil
	}
	return s.Enabled
}

func (s *SettingElement) GetFields() []*DisplayProperty {
	if s == nil {
		return nil
	}
	return s.Fields
}

func (s *SettingElement) GetOrder() *Order {
	if s == nil {
		return nil
	}
	return s.Order
}

func (s *SettingElement) GetSendAuto() *bool {
	if s == nil {
		return nil
	}
	return s.SendAuto
}

func (s *SettingElement) GetSendManual() *bool {
	if s == nil {
		return nil
	}
	return s.SendManual
}

func (s *SettingElement) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SettingElement) UnmarshalJSON(data []byte) error {
	type unmarshaler SettingElement
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SettingElement(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SettingElement) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SettingsQueryRecord struct {
	// Any custom fields defined for the org.
	CustomFields []*KeyValue `json:"customFields,omitempty" url:"customFields,omitempty"`
	ForInvoices  []*KeyValue `json:"forInvoices,omitempty" url:"forInvoices,omitempty"`
	ForPayOuts   []*KeyValue `json:"forPayOuts,omitempty" url:"forPayOuts,omitempty"`
	// Information about digital wallet settings for the entity. Available values are `isApplePayEnabled` and `isGooglePayEnabled`.
	ForWallets  []*KeyValue `json:"forWallets,omitempty" url:"forWallets,omitempty"`
	General     []*KeyValue `json:"general,omitempty" url:"general,omitempty"`
	Identifiers []*KeyValue `json:"identifiers,omitempty" url:"identifiers,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SettingsQueryRecord) GetCustomFields() []*KeyValue {
	if s == nil {
		return nil
	}
	return s.CustomFields
}

func (s *SettingsQueryRecord) GetForInvoices() []*KeyValue {
	if s == nil {
		return nil
	}
	return s.ForInvoices
}

func (s *SettingsQueryRecord) GetForPayOuts() []*KeyValue {
	if s == nil {
		return nil
	}
	return s.ForPayOuts
}

func (s *SettingsQueryRecord) GetForWallets() []*KeyValue {
	if s == nil {
		return nil
	}
	return s.ForWallets
}

func (s *SettingsQueryRecord) GetGeneral() []*KeyValue {
	if s == nil {
		return nil
	}
	return s.General
}

func (s *SettingsQueryRecord) GetIdentifiers() []*KeyValue {
	if s == nil {
		return nil
	}
	return s.Identifiers
}

func (s *SettingsQueryRecord) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SettingsQueryRecord) UnmarshalJSON(data []byte) error {
	type unmarshaler SettingsQueryRecord
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SettingsQueryRecord(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SettingsQueryRecord) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Settlement status for transaction. See [the docs](/developers/references/money-in-statuses#payment-funding-status) for a full reference.
type SettlementStatus = int

// The settlement status of the payout transaction. See [Payout Transaction Statuses](guides/money-out-statuses#payout-transaction-statuses) for a full reference.
type SettlementStatusPayout = string

// Sender shipping ZIP code.
type ShippingFromZip = string

// The shipping address.
type Shippingaddress = string

// Additional line for shipping address.
type Shippingaddressadditional = string

// Shipping city.
type Shippingcity = string

// Shipping address country.
type Shippingcountry = string

// Shipping state or province.
type Shippingstate = string

// Shipping ZIP code. For Pay In functions, this field supports 5-digit and 9-digit ZIP codes and alphanumeric Canadian postal codes. For example: "37615-1234" or "37615".
type Shippingzip = string

type Signaturedata = string

// Custom identifier to indicate the transaction or request source.
type Source = string

// Split funding instructions for the transaction. The total amount of the splits must match the total amount of the transaction.
type SplitFunding = []*SplitFundingContent

type SplitFundingContent struct {
	// The accountId for the account the split should be sent to.
	AccountId *string `json:"accountId,omitempty" url:"accountId,omitempty"`
	// Amount from the transaction to sent to this recipient.
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// A description for the split.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The entrypoint the split should be sent to.
	RecipientEntryPoint *string `json:"recipientEntryPoint,omitempty" url:"recipientEntryPoint,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SplitFundingContent) GetAccountId() *string {
	if s == nil {
		return nil
	}
	return s.AccountId
}

func (s *SplitFundingContent) GetAmount() *float64 {
	if s == nil {
		return nil
	}
	return s.Amount
}

func (s *SplitFundingContent) GetDescription() *string {
	if s == nil {
		return nil
	}
	return s.Description
}

func (s *SplitFundingContent) GetRecipientEntryPoint() *string {
	if s == nil {
		return nil
	}
	return s.RecipientEntryPoint
}

func (s *SplitFundingContent) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SplitFundingContent) UnmarshalJSON(data []byte) error {
	type unmarshaler SplitFundingContent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SplitFundingContent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SplitFundingContent) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The state or province.
type StateNullable = string

// Status of notification:
//   - `0`: Inactive
//   - `1`: Active
type Statusnotification = int

// **Strongly recommended** The usage type for the stored method, used for merchant-initiated transactions (MIT). If you don't specify a value, Payabli defaults to `unscheduled`.
// Available values:
//   - `unscheduled`: This type is used for transactions that are one-time or otherwise not pre-scheduled.
//   - `subscription`: This type is used for subscription payments. For example, monthly rental fees or ongoing service subscriptions.
//   - `recurring`: This type is used for recurring payments that occur per a set plan. For example, splitting an HOA special assessment over 6 monthly payments.
//
// See [Understanding CIT and MIT Indicators](/guides/money-in-cit-mit) for more information.
type StoredMethodUsageType = string

// Payabli identifier of a tokenized payment method. If this field is used in a request, the `method` field is overridden and the payment is made using the payment token.
type Storedmethodid = string

// Refers to the payment page identifier. If provided, then the transaction is linked to the payment page.
type Subdomain = string

type SubscriptionQueryRecords struct {
	// Timestamp of when the subscription ws created, in UTC.
	CreatedAt *CreatedAt                 `json:"CreatedAt,omitempty" url:"CreatedAt,omitempty"`
	Customer  *QueryTransactionPayorData `json:"Customer,omitempty" url:"Customer,omitempty"`
	// The subscription's end date.
	EndDate            *DatetimeNullable   `json:"EndDate,omitempty" url:"EndDate,omitempty"`
	EntrypageId        *EntrypageId        `json:"EntrypageId,omitempty" url:"EntrypageId,omitempty"`
	ExternalPaypointId *ExternalPaypointId `json:"ExternalPaypointID,omitempty" url:"ExternalPaypointID,omitempty"`
	// Fee applied to the subscription.
	FeeAmount *float64 `json:"FeeAmount,omitempty" url:"FeeAmount,omitempty"`
	// The subscription's frequency.
	Frequency *string `json:"Frequency,omitempty" url:"Frequency,omitempty"`
	// The subscription's ID.
	IdSub       *int64    `json:"IdSub,omitempty" url:"IdSub,omitempty"`
	InvoiceData *BillData `json:"InvoiceData,omitempty" url:"InvoiceData,omitempty"`
	// The last time the subscription was processed.
	LastRun *DatetimeNullable `json:"LastRun,omitempty" url:"LastRun,omitempty"`
	// The last date and time the subscription was updated.
	LastUpdated *LastModified `json:"LastUpdated,omitempty" url:"LastUpdated,omitempty"`
	// The number of cycles the subscription has left.
	LeftCycles *int `json:"LeftCycles,omitempty" url:"LeftCycles,omitempty"`
	// The subscription's payment method.
	Method *string `json:"Method,omitempty" url:"Method,omitempty"`
	// The subscription amount, minus any fees.
	NetAmount *Netamountnullable `json:"NetAmount,omitempty" url:"NetAmount,omitempty"`
	// The next date the subscription will be processed.
	NextDate      *DatetimeNullable `json:"NextDate,omitempty" url:"NextDate,omitempty"`
	ParentOrgName *OrgParentName    `json:"ParentOrgName,omitempty" url:"ParentOrgName,omitempty"`
	PaymentData   *QueryPaymentData `json:"PaymentData,omitempty" url:"PaymentData,omitempty"`
	// The paypoint's DBA name.
	PaypointDbaname *Dbaname `json:"PaypointDbaname,omitempty" url:"PaypointDbaname,omitempty"`
	// The paypoint's entryname.
	PaypointEntryname *Entrypointfield `json:"PaypointEntryname,omitempty" url:"PaypointEntryname,omitempty"`
	PaypointId        *PaypointId      `json:"PaypointId,omitempty" url:"PaypointId,omitempty"`
	// The paypoint's legal name.
	PaypointLegalname *Legalname `json:"PaypointLegalname,omitempty" url:"PaypointLegalname,omitempty"`
	// Payment plan ID.
	PlanId *int    `json:"PlanId,omitempty" url:"PlanId,omitempty"`
	Source *Source `json:"Source,omitempty" url:"Source,omitempty"`
	// The subscription start date.
	StartDate *DatetimeNullable `json:"StartDate,omitempty" url:"StartDate,omitempty"`
	// Events associated with the subscription.
	SubEvents []*GeneralEvents `json:"SubEvents,omitempty" url:"SubEvents,omitempty"`
	// The subscription's status.
	// - 0: Paused
	// - 1: Active
	SubStatus *int `json:"SubStatus,omitempty" url:"SubStatus,omitempty"`
	// The subscription amount, including any fees.
	TotalAmount *float64 `json:"TotalAmount,omitempty" url:"TotalAmount,omitempty"`
	// The total number of cycles the subscription is set to run.
	TotalCycles *int `json:"TotalCycles,omitempty" url:"TotalCycles,omitempty"`
	// When `true`, the subscription has no explicit end date and will run until canceled.
	UntilCancelled *bool `json:"UntilCancelled,omitempty" url:"UntilCancelled,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubscriptionQueryRecords) GetCreatedAt() *CreatedAt {
	if s == nil {
		return nil
	}
	return s.CreatedAt
}

func (s *SubscriptionQueryRecords) GetCustomer() *QueryTransactionPayorData {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *SubscriptionQueryRecords) GetEndDate() *DatetimeNullable {
	if s == nil {
		return nil
	}
	return s.EndDate
}

func (s *SubscriptionQueryRecords) GetEntrypageId() *EntrypageId {
	if s == nil {
		return nil
	}
	return s.EntrypageId
}

func (s *SubscriptionQueryRecords) GetExternalPaypointId() *ExternalPaypointId {
	if s == nil {
		return nil
	}
	return s.ExternalPaypointId
}

func (s *SubscriptionQueryRecords) GetFeeAmount() *float64 {
	if s == nil {
		return nil
	}
	return s.FeeAmount
}

func (s *SubscriptionQueryRecords) GetFrequency() *string {
	if s == nil {
		return nil
	}
	return s.Frequency
}

func (s *SubscriptionQueryRecords) GetIdSub() *int64 {
	if s == nil {
		return nil
	}
	return s.IdSub
}

func (s *SubscriptionQueryRecords) GetInvoiceData() *BillData {
	if s == nil {
		return nil
	}
	return s.InvoiceData
}

func (s *SubscriptionQueryRecords) GetLastRun() *DatetimeNullable {
	if s == nil {
		return nil
	}
	return s.LastRun
}

func (s *SubscriptionQueryRecords) GetLastUpdated() *LastModified {
	if s == nil {
		return nil
	}
	return s.LastUpdated
}

func (s *SubscriptionQueryRecords) GetLeftCycles() *int {
	if s == nil {
		return nil
	}
	return s.LeftCycles
}

func (s *SubscriptionQueryRecords) GetMethod() *string {
	if s == nil {
		return nil
	}
	return s.Method
}

func (s *SubscriptionQueryRecords) GetNetAmount() *Netamountnullable {
	if s == nil {
		return nil
	}
	return s.NetAmount
}

func (s *SubscriptionQueryRecords) GetNextDate() *DatetimeNullable {
	if s == nil {
		return nil
	}
	return s.NextDate
}

func (s *SubscriptionQueryRecords) GetParentOrgName() *OrgParentName {
	if s == nil {
		return nil
	}
	return s.ParentOrgName
}

func (s *SubscriptionQueryRecords) GetPaymentData() *QueryPaymentData {
	if s == nil {
		return nil
	}
	return s.PaymentData
}

func (s *SubscriptionQueryRecords) GetPaypointDbaname() *Dbaname {
	if s == nil {
		return nil
	}
	return s.PaypointDbaname
}

func (s *SubscriptionQueryRecords) GetPaypointEntryname() *Entrypointfield {
	if s == nil {
		return nil
	}
	return s.PaypointEntryname
}

func (s *SubscriptionQueryRecords) GetPaypointId() *PaypointId {
	if s == nil {
		return nil
	}
	return s.PaypointId
}

func (s *SubscriptionQueryRecords) GetPaypointLegalname() *Legalname {
	if s == nil {
		return nil
	}
	return s.PaypointLegalname
}

func (s *SubscriptionQueryRecords) GetPlanId() *int {
	if s == nil {
		return nil
	}
	return s.PlanId
}

func (s *SubscriptionQueryRecords) GetSource() *Source {
	if s == nil {
		return nil
	}
	return s.Source
}

func (s *SubscriptionQueryRecords) GetStartDate() *DatetimeNullable {
	if s == nil {
		return nil
	}
	return s.StartDate
}

func (s *SubscriptionQueryRecords) GetSubEvents() []*GeneralEvents {
	if s == nil {
		return nil
	}
	return s.SubEvents
}

func (s *SubscriptionQueryRecords) GetSubStatus() *int {
	if s == nil {
		return nil
	}
	return s.SubStatus
}

func (s *SubscriptionQueryRecords) GetTotalAmount() *float64 {
	if s == nil {
		return nil
	}
	return s.TotalAmount
}

func (s *SubscriptionQueryRecords) GetTotalCycles() *int {
	if s == nil {
		return nil
	}
	return s.TotalCycles
}

func (s *SubscriptionQueryRecords) GetUntilCancelled() *bool {
	if s == nil {
		return nil
	}
	return s.UntilCancelled
}

func (s *SubscriptionQueryRecords) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionQueryRecords) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionQueryRecords
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionQueryRecords(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionQueryRecords) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Payabli identifier of the subscription associated with the transaction.
type Subscriptionid = int64

// Commodity code.
type SummaryCommodityCode = string

type SummaryOrg struct {
	AmountSubs     *float64 `json:"amountSubs,omitempty" url:"amountSubs,omitempty"`
	AmountTx       *float64 `json:"amountTx,omitempty" url:"amountTx,omitempty"`
	ChildOrgs      *int     `json:"childOrgs,omitempty" url:"childOrgs,omitempty"`
	ChildPaypoints *int     `json:"childPaypoints,omitempty" url:"childPaypoints,omitempty"`
	CountSubs      *int     `json:"countSubs,omitempty" url:"countSubs,omitempty"`
	CountTx        *int     `json:"countTx,omitempty" url:"countTx,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SummaryOrg) GetAmountSubs() *float64 {
	if s == nil {
		return nil
	}
	return s.AmountSubs
}

func (s *SummaryOrg) GetAmountTx() *float64 {
	if s == nil {
		return nil
	}
	return s.AmountTx
}

func (s *SummaryOrg) GetChildOrgs() *int {
	if s == nil {
		return nil
	}
	return s.ChildOrgs
}

func (s *SummaryOrg) GetChildPaypoints() *int {
	if s == nil {
		return nil
	}
	return s.ChildPaypoints
}

func (s *SummaryOrg) GetCountSubs() *int {
	if s == nil {
		return nil
	}
	return s.CountSubs
}

func (s *SummaryOrg) GetCountTx() *int {
	if s == nil {
		return nil
	}
	return s.CountTx
}

func (s *SummaryOrg) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SummaryOrg) UnmarshalJSON(data []byte) error {
	type unmarshaler SummaryOrg
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SummaryOrg(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SummaryOrg) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Specify the notification target.
//
// For **method**=*email* the expected value is a list of email addresses separated by semicolon.
//
// For **method**=*sms* the expected value is a list of phone numbers separated by semicolon.
//
// For **method**=*web*. the expected value is a valid and complete URL. Webhooks support only standard HTTP ports: 80, 443, 8080, or 4443.
type Target = string

// Tax rate in percent applied to the invoice.
type Tax = *float64

// Business name in tax document. This is only relevant if a government entity has given you an alternative name to file tax documents with.
type Taxfillname = string

// The internal code for the template.
type TemplateCode = *string

// The associated boarding template's ID in Payabli.
type TemplateId = int64

// The template name.
type TemplateName = string

// Payment terms for invoice. If no terms are defined, then response data for this field defaults to `NET30`.
//
// **Available Values:**
//
// - `PIA`: Payment in advance
//
// - `CIA`: Cash in advance
//
// - `UR`: Upon receipt
//
// - `NET10`: 10 days after invoice date
//
// - `NET20`: 20 days after invoice date
//
// - `NET30`: 30 days after invoice date
//
// - `NET45`: 45 days after invoice date
//
// - `NET60`: 60 days after invoice date
//
// - `NET90`: 90 days after invoice date
//
// - `EOM`: Due end of this month
//
// - `MFI`: 1st of the month following the invoice date
//
// - `5MFI`: 5th of the month following the invoice date
//
// - `10MFI`: 10th of the month following the invoice date
//
// - `15MFI`: 15th of the month following the invoice date
//
// - `20MFI`: 20th of the month following the invoice date
//
// - `2/10NET30`: 2% discount if paid within 10 days, otherwise net 30 days
//
// - `UF`: Until further notice
//
// - `10UF`: 10 days until further notice
//
// - `20UF`: 20 days until further notice
//
// - `25UF`: 25 days until further notice
//
// - `50UF`: 50 days until further notice
type Terms = string

// Custom terms and conditions included in the invoice.
type TermsConditions = string

// Timezone, in UTC offset. For example, -5 is Eastern time.
type Timezone = int

// Total number of pages in response.
type Totalpages = int

// Total number of records in response.
type Totalrecords = int

type TransactionQueryRecords struct {
	AchHolderType *AchHolderType `json:"AchHolderType,omitempty" url:"AchHolderType,omitempty"`
	AchSecCode    *AchSecCode    `json:"AchSecCode,omitempty" url:"AchSecCode,omitempty"`
	// Batch amount.
	BatchAmount *float64     `json:"BatchAmount,omitempty" url:"BatchAmount,omitempty"`
	BatchNumber *BatchNumber `json:"BatchNumber,omitempty" url:"BatchNumber,omitempty"`
	// Service Fee or sub-charge transaction associated to the main transaction.
	CfeeTransactions []*QueryCFeeTransaction `json:"CfeeTransactions,omitempty" url:"CfeeTransactions,omitempty"`
	// Connector used for transaction.
	ConnectorName                *string                       `json:"ConnectorName,omitempty" url:"ConnectorName,omitempty"`
	Customer                     *QueryTransactionPayorData    `json:"Customer,omitempty" url:"Customer,omitempty"`
	DeviceId                     *Device                       `json:"DeviceId,omitempty" url:"DeviceId,omitempty"`
	EntrypageId                  *EntrypageId                  `json:"EntrypageId,omitempty" url:"EntrypageId,omitempty"`
	ExternalProcessorInformation *ExternalProcessorInformation `json:"ExternalProcessorInformation,omitempty" url:"ExternalProcessorInformation,omitempty"`
	FeeAmount                    *FeeAmount                    `json:"FeeAmount,omitempty" url:"FeeAmount,omitempty"`
	// Internal identifier used for processing.
	GatewayTransId *string   `json:"GatewayTransId,omitempty" url:"GatewayTransId,omitempty"`
	InvoiceData    *BillData `json:"InvoiceData,omitempty" url:"InvoiceData,omitempty"`
	// Payment method used: card, ach, or wallet.
	Method *string `json:"Method,omitempty" url:"Method,omitempty"`
	// Net amount paid.
	NetAmount *Netamountnullable `json:"NetAmount,omitempty" url:"NetAmount,omitempty"`
	Operation *Operation         `json:"Operation,omitempty" url:"Operation,omitempty"`
	OrderId   *OrderId           `json:"OrderId,omitempty" url:"OrderId,omitempty"`
	// ID of immediate parent organization.
	OrgId         *Orgid            `json:"OrgId,omitempty" url:"OrgId,omitempty"`
	ParentOrgName *OrgParentName    `json:"ParentOrgName,omitempty" url:"ParentOrgName,omitempty"`
	PaymentData   *QueryPaymentData `json:"PaymentData,omitempty" url:"PaymentData,omitempty"`
	// Unique Transaction ID.
	PaymentTransId *string  `json:"PaymentTransId,omitempty" url:"PaymentTransId,omitempty"`
	PayorId        *PayorId `json:"PayorId,omitempty" url:"PayorId,omitempty"`
	// Paypoint's DBA name.
	PaypointDbaname *Dbaname `json:"PaypointDbaname,omitempty" url:"PaypointDbaname,omitempty"`
	// Paypoint's entryname.
	PaypointEntryname *Entrypointfield `json:"PaypointEntryname,omitempty" url:"PaypointEntryname,omitempty"`
	// InternalId for paypoint.
	PaypointId *int64 `json:"PaypointId,omitempty" url:"PaypointId,omitempty"`
	// Paypoint's legal name.
	PaypointLegalname *Legalname         `json:"PaypointLegalname,omitempty" url:"PaypointLegalname,omitempty"`
	PendingFeeAmount  *PendingFeeAmount  `json:"PendingFeeAmount,omitempty" url:"PendingFeeAmount,omitempty"`
	RefundId          *RefundId          `json:"RefundId,omitempty" url:"RefundId,omitempty"`
	ResponseData      *QueryResponseData `json:"ResponseData,omitempty" url:"ResponseData,omitempty"`
	ReturnedId        *ReturnedId        `json:"ReturnedId,omitempty" url:"ReturnedId,omitempty"`
	// Reference to the subscription that originated the transaction.
	ScheduleReference *int64 `json:"ScheduleReference,omitempty" url:"ScheduleReference,omitempty"`
	// Settlement status for transaction. See [the docs](/developers/references/money-in-statuses#payment-funding-status) for a full reference.
	SettlementStatus         *int          `json:"SettlementStatus,omitempty" url:"SettlementStatus,omitempty"`
	Source                   *Source       `json:"Source,omitempty" url:"Source,omitempty"`
	SplitFundingInstructions *SplitFunding `json:"splitFundingInstructions,omitempty" url:"splitFundingInstructions,omitempty"`
	// Transaction total amount (including service fee or sub-charge)
	TotalAmount *float64 `json:"TotalAmount,omitempty" url:"TotalAmount,omitempty"`
	// Events associated with this transaction.
	TransactionEvents []*QueryTransactionEvents `json:"TransactionEvents,omitempty" url:"TransactionEvents,omitempty"`
	// Transaction date and time, in UTC.
	TransactionTime     *DatetimeNullable `json:"TransactionTime,omitempty" url:"TransactionTime,omitempty"`
	TransAdditionalData interface{}       `json:"TransAdditionalData,omitempty" url:"TransAdditionalData,omitempty"`
	// Status of transaction. See [the docs](/developers/references/money-in-statuses#money-in-transaction-status) for a full reference.
	TransStatus *int `json:"TransStatus,omitempty" url:"TransStatus,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransactionQueryRecords) GetAchHolderType() *AchHolderType {
	if t == nil {
		return nil
	}
	return t.AchHolderType
}

func (t *TransactionQueryRecords) GetAchSecCode() *AchSecCode {
	if t == nil {
		return nil
	}
	return t.AchSecCode
}

func (t *TransactionQueryRecords) GetBatchAmount() *float64 {
	if t == nil {
		return nil
	}
	return t.BatchAmount
}

func (t *TransactionQueryRecords) GetBatchNumber() *BatchNumber {
	if t == nil {
		return nil
	}
	return t.BatchNumber
}

func (t *TransactionQueryRecords) GetCfeeTransactions() []*QueryCFeeTransaction {
	if t == nil {
		return nil
	}
	return t.CfeeTransactions
}

func (t *TransactionQueryRecords) GetConnectorName() *string {
	if t == nil {
		return nil
	}
	return t.ConnectorName
}

func (t *TransactionQueryRecords) GetCustomer() *QueryTransactionPayorData {
	if t == nil {
		return nil
	}
	return t.Customer
}

func (t *TransactionQueryRecords) GetDeviceId() *Device {
	if t == nil {
		return nil
	}
	return t.DeviceId
}

func (t *TransactionQueryRecords) GetEntrypageId() *EntrypageId {
	if t == nil {
		return nil
	}
	return t.EntrypageId
}

func (t *TransactionQueryRecords) GetExternalProcessorInformation() *ExternalProcessorInformation {
	if t == nil {
		return nil
	}
	return t.ExternalProcessorInformation
}

func (t *TransactionQueryRecords) GetFeeAmount() *FeeAmount {
	if t == nil {
		return nil
	}
	return t.FeeAmount
}

func (t *TransactionQueryRecords) GetGatewayTransId() *string {
	if t == nil {
		return nil
	}
	return t.GatewayTransId
}

func (t *TransactionQueryRecords) GetInvoiceData() *BillData {
	if t == nil {
		return nil
	}
	return t.InvoiceData
}

func (t *TransactionQueryRecords) GetMethod() *string {
	if t == nil {
		return nil
	}
	return t.Method
}

func (t *TransactionQueryRecords) GetNetAmount() *Netamountnullable {
	if t == nil {
		return nil
	}
	return t.NetAmount
}

func (t *TransactionQueryRecords) GetOperation() *Operation {
	if t == nil {
		return nil
	}
	return t.Operation
}

func (t *TransactionQueryRecords) GetOrderId() *OrderId {
	if t == nil {
		return nil
	}
	return t.OrderId
}

func (t *TransactionQueryRecords) GetOrgId() *Orgid {
	if t == nil {
		return nil
	}
	return t.OrgId
}

func (t *TransactionQueryRecords) GetParentOrgName() *OrgParentName {
	if t == nil {
		return nil
	}
	return t.ParentOrgName
}

func (t *TransactionQueryRecords) GetPaymentData() *QueryPaymentData {
	if t == nil {
		return nil
	}
	return t.PaymentData
}

func (t *TransactionQueryRecords) GetPaymentTransId() *string {
	if t == nil {
		return nil
	}
	return t.PaymentTransId
}

func (t *TransactionQueryRecords) GetPayorId() *PayorId {
	if t == nil {
		return nil
	}
	return t.PayorId
}

func (t *TransactionQueryRecords) GetPaypointDbaname() *Dbaname {
	if t == nil {
		return nil
	}
	return t.PaypointDbaname
}

func (t *TransactionQueryRecords) GetPaypointEntryname() *Entrypointfield {
	if t == nil {
		return nil
	}
	return t.PaypointEntryname
}

func (t *TransactionQueryRecords) GetPaypointId() *int64 {
	if t == nil {
		return nil
	}
	return t.PaypointId
}

func (t *TransactionQueryRecords) GetPaypointLegalname() *Legalname {
	if t == nil {
		return nil
	}
	return t.PaypointLegalname
}

func (t *TransactionQueryRecords) GetPendingFeeAmount() *PendingFeeAmount {
	if t == nil {
		return nil
	}
	return t.PendingFeeAmount
}

func (t *TransactionQueryRecords) GetRefundId() *RefundId {
	if t == nil {
		return nil
	}
	return t.RefundId
}

func (t *TransactionQueryRecords) GetResponseData() *QueryResponseData {
	if t == nil {
		return nil
	}
	return t.ResponseData
}

func (t *TransactionQueryRecords) GetReturnedId() *ReturnedId {
	if t == nil {
		return nil
	}
	return t.ReturnedId
}

func (t *TransactionQueryRecords) GetScheduleReference() *int64 {
	if t == nil {
		return nil
	}
	return t.ScheduleReference
}

func (t *TransactionQueryRecords) GetSettlementStatus() *int {
	if t == nil {
		return nil
	}
	return t.SettlementStatus
}

func (t *TransactionQueryRecords) GetSource() *Source {
	if t == nil {
		return nil
	}
	return t.Source
}

func (t *TransactionQueryRecords) GetSplitFundingInstructions() *SplitFunding {
	if t == nil {
		return nil
	}
	return t.SplitFundingInstructions
}

func (t *TransactionQueryRecords) GetTotalAmount() *float64 {
	if t == nil {
		return nil
	}
	return t.TotalAmount
}

func (t *TransactionQueryRecords) GetTransactionEvents() []*QueryTransactionEvents {
	if t == nil {
		return nil
	}
	return t.TransactionEvents
}

func (t *TransactionQueryRecords) GetTransactionTime() *DatetimeNullable {
	if t == nil {
		return nil
	}
	return t.TransactionTime
}

func (t *TransactionQueryRecords) GetTransAdditionalData() interface{} {
	if t == nil {
		return nil
	}
	return t.TransAdditionalData
}

func (t *TransactionQueryRecords) GetTransStatus() *int {
	if t == nil {
		return nil
	}
	return t.TransStatus
}

func (t *TransactionQueryRecords) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransactionQueryRecords) UnmarshalJSON(data []byte) error {
	type unmarshaler TransactionQueryRecords
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransactionQueryRecords(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransactionQueryRecords) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Timestamp when transaction was submitted, in UTC.
type TransactionTime = time.Time

// Type of bank account: Checking or Savings.
type TypeAccount string

const (
	TypeAccountChecking TypeAccount = "Checking"
	TypeAccountSavings  TypeAccount = "Savings"
)

func NewTypeAccountFromString(s string) (TypeAccount, error) {
	switch s {
	case "Checking":
		return TypeAccountChecking, nil
	case "Savings":
		return TypeAccountSavings, nil
	}
	var t TypeAccount
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TypeAccount) Ptr() *TypeAccount {
	return &t
}

type UserQueryRecord struct {
	Access         []*UsrAccess          `json:"Access,omitempty" url:"Access,omitempty"`
	AdditionalData *AdditionalDataString `json:"AdditionalData,omitempty" url:"AdditionalData,omitempty"`
	// The timestamp for the user's creation, in UTC.
	CreatedAt *CreatedAt `json:"createdAt,omitempty" url:"createdAt,omitempty"`
	// The user's email address.
	Email    *Email    `json:"Email,omitempty" url:"Email,omitempty"`
	Language *Language `json:"language,omitempty" url:"language,omitempty"`
	// The timestamp for the user's last activity, in UTC.
	LastAccess *time.Time `json:"lastAccess,omitempty" url:"lastAccess,omitempty"`
	Name       *NameUser  `json:"Name,omitempty" url:"Name,omitempty"`
	// The user's phone number.
	Phone *PhoneNumber `json:"Phone,omitempty" url:"Phone,omitempty"`
	Scope []*OrgXScope `json:"Scope,omitempty" url:"Scope,omitempty"`
	// Additional data provided by the social network related to the customer.
	SnData *string `json:"snData,omitempty" url:"snData,omitempty"`
	// Identifier or token for customer in linked social network.
	SnIdentifier *string `json:"snIdentifier,omitempty" url:"snIdentifier,omitempty"`
	// Social network linked to customer. Possible values: facebook, google, twitter, microsoft.
	SnProvider *string   `json:"snProvider,omitempty" url:"snProvider,omitempty"`
	TimeZone   *Timezone `json:"timeZone,omitempty" url:"timeZone,omitempty"`
	// The user's ID in Payabli.
	UserId     *int64     `json:"userId,omitempty" url:"userId,omitempty"`
	UsrMfa     *Mfa       `json:"UsrMFA,omitempty" url:"UsrMFA,omitempty"`
	UsrMfaMode *MfaMode   `json:"UsrMFAMode,omitempty" url:"UsrMFAMode,omitempty"`
	UsrStatus  *UsrStatus `json:"UsrStatus,omitempty" url:"UsrStatus,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserQueryRecord) GetAccess() []*UsrAccess {
	if u == nil {
		return nil
	}
	return u.Access
}

func (u *UserQueryRecord) GetAdditionalData() *AdditionalDataString {
	if u == nil {
		return nil
	}
	return u.AdditionalData
}

func (u *UserQueryRecord) GetCreatedAt() *CreatedAt {
	if u == nil {
		return nil
	}
	return u.CreatedAt
}

func (u *UserQueryRecord) GetEmail() *Email {
	if u == nil {
		return nil
	}
	return u.Email
}

func (u *UserQueryRecord) GetLanguage() *Language {
	if u == nil {
		return nil
	}
	return u.Language
}

func (u *UserQueryRecord) GetLastAccess() *time.Time {
	if u == nil {
		return nil
	}
	return u.LastAccess
}

func (u *UserQueryRecord) GetName() *NameUser {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UserQueryRecord) GetPhone() *PhoneNumber {
	if u == nil {
		return nil
	}
	return u.Phone
}

func (u *UserQueryRecord) GetScope() []*OrgXScope {
	if u == nil {
		return nil
	}
	return u.Scope
}

func (u *UserQueryRecord) GetSnData() *string {
	if u == nil {
		return nil
	}
	return u.SnData
}

func (u *UserQueryRecord) GetSnIdentifier() *string {
	if u == nil {
		return nil
	}
	return u.SnIdentifier
}

func (u *UserQueryRecord) GetSnProvider() *string {
	if u == nil {
		return nil
	}
	return u.SnProvider
}

func (u *UserQueryRecord) GetTimeZone() *Timezone {
	if u == nil {
		return nil
	}
	return u.TimeZone
}

func (u *UserQueryRecord) GetUserId() *int64 {
	if u == nil {
		return nil
	}
	return u.UserId
}

func (u *UserQueryRecord) GetUsrMfa() *Mfa {
	if u == nil {
		return nil
	}
	return u.UsrMfa
}

func (u *UserQueryRecord) GetUsrMfaMode() *MfaMode {
	if u == nil {
		return nil
	}
	return u.UsrMfaMode
}

func (u *UserQueryRecord) GetUsrStatus() *UsrStatus {
	if u == nil {
		return nil
	}
	return u.UsrStatus
}

func (u *UserQueryRecord) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserQueryRecord) UnmarshalJSON(data []byte) error {
	type embed UserQueryRecord
	var unmarshaler = struct {
		embed
		LastAccess *internal.DateTime `json:"lastAccess,omitempty"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UserQueryRecord(unmarshaler.embed)
	u.LastAccess = unmarshaler.LastAccess.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserQueryRecord) MarshalJSON() ([]byte, error) {
	type embed UserQueryRecord
	var marshaler = struct {
		embed
		LastAccess *internal.DateTime `json:"lastAccess,omitempty"`
	}{
		embed:      embed(*u),
		LastAccess: internal.NewOptionalDateTime(u.LastAccess),
	}
	return json.Marshal(marshaler)
}

func (u *UserQueryRecord) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UsrAccess struct {
	RoleLabel *string `json:"roleLabel,omitempty" url:"roleLabel,omitempty"`
	RoleValue *bool   `json:"roleValue,omitempty" url:"roleValue,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UsrAccess) GetRoleLabel() *string {
	if u == nil {
		return nil
	}
	return u.RoleLabel
}

func (u *UsrAccess) GetRoleValue() *bool {
	if u == nil {
		return nil
	}
	return u.RoleValue
}

func (u *UsrAccess) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UsrAccess) UnmarshalJSON(data []byte) error {
	type unmarshaler UsrAccess
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UsrAccess(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UsrAccess) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// The user's status:
//   - Inactive:	0
//   - Active:	1
//   - Deleted:	-99
//   - Locked:	85
type UsrStatus = int

type ValueTemplates = string

type VendorData struct {
	VendorNumber   *VendorNumber   `json:"vendorNumber,omitempty" url:"vendorNumber,omitempty"`
	AdditionalData *AdditionalData `json:"AdditionalData,omitempty" url:"AdditionalData,omitempty"`
	// Vendor's address
	Address1 *AddressNullable `json:"address1,omitempty" url:"address1,omitempty"`
	// Additional line for vendor's address.
	Address2 *AddressAddtlNullable `json:"address2,omitempty" url:"address2,omitempty"`
	// Object containing vendor's bank information.
	BillingData *BillingData `json:"billingData,omitempty" url:"billingData,omitempty"`
	// Vendor's city.
	City *string `json:"city,omitempty" url:"city,omitempty"`
	// Array of objects describing the vendor's contacts.
	Contacts *ContactsField `json:"contacts,omitempty" url:"contacts,omitempty"`
	// Vendor's country.
	Country *string `json:"country,omitempty" url:"country,omitempty"`
	// Custom field 1 for vendor
	CustomField1 *string `json:"customField1,omitempty" url:"customField1,omitempty"`
	// Custom field 2 for vendor
	CustomField2 *string `json:"customField2,omitempty" url:"customField2,omitempty"`
	// Account number of paypoint in the vendor side.
	CustomerVendorAccount *string    `json:"customerVendorAccount,omitempty" url:"customerVendorAccount,omitempty"`
	Ein                   *VendorEin `json:"ein,omitempty" url:"ein,omitempty"`
	// Vendor's email address. Required for vCard.
	Email *Email `json:"email,omitempty" url:"email,omitempty"`
	// Internal identifier for global vendor account.
	InternalReferenceId *int64                     `json:"internalReferenceId,omitempty" url:"internalReferenceId,omitempty"`
	LocationCode        *LocationCode              `json:"locationCode,omitempty" url:"locationCode,omitempty"`
	Mcc                 *Mcc                       `json:"mcc,omitempty" url:"mcc,omitempty"`
	Name1               *VendorName1               `json:"name1,omitempty" url:"name1,omitempty"`
	Name2               *VendorName2               `json:"name2,omitempty" url:"name2,omitempty"`
	PayeeName1          *PayeeName                 `json:"payeeName1,omitempty" url:"payeeName1,omitempty"`
	PayeeName2          *PayeeName                 `json:"payeeName2,omitempty" url:"payeeName2,omitempty"`
	PaymentMethod       *VendorPaymentMethodString `json:"paymentMethod,omitempty" url:"paymentMethod,omitempty"`
	Phone               *VendorPhone               `json:"phone,omitempty" url:"phone,omitempty"`
	RemitAddress1       *Remitaddress1             `json:"remitAddress1,omitempty" url:"remitAddress1,omitempty"`
	RemitAddress2       *Remitaddress2             `json:"remitAddress2,omitempty" url:"remitAddress2,omitempty"`
	RemitCity           *Remitcity                 `json:"remitCity,omitempty" url:"remitCity,omitempty"`
	RemitCountry        *Remitcountry              `json:"remitCountry,omitempty" url:"remitCountry,omitempty"`
	RemitEmail          *RemitEmail                `json:"remitEmail,omitempty" url:"remitEmail,omitempty"`
	RemitState          *Remitstate                `json:"remitState,omitempty" url:"remitState,omitempty"`
	RemitZip            *Remitzip                  `json:"remitZip,omitempty" url:"remitZip,omitempty"`
	// Vendor's state. Must be a 2 character state code.
	State        *string       `json:"state,omitempty" url:"state,omitempty"`
	VendorStatus *Vendorstatus `json:"vendorStatus,omitempty" url:"vendorStatus,omitempty"`
	// Vendor's zip code.
	Zip *string `json:"zip,omitempty" url:"zip,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VendorData) GetVendorNumber() *VendorNumber {
	if v == nil {
		return nil
	}
	return v.VendorNumber
}

func (v *VendorData) GetAdditionalData() *AdditionalData {
	if v == nil {
		return nil
	}
	return v.AdditionalData
}

func (v *VendorData) GetAddress1() *AddressNullable {
	if v == nil {
		return nil
	}
	return v.Address1
}

func (v *VendorData) GetAddress2() *AddressAddtlNullable {
	if v == nil {
		return nil
	}
	return v.Address2
}

func (v *VendorData) GetBillingData() *BillingData {
	if v == nil {
		return nil
	}
	return v.BillingData
}

func (v *VendorData) GetCity() *string {
	if v == nil {
		return nil
	}
	return v.City
}

func (v *VendorData) GetContacts() *ContactsField {
	if v == nil {
		return nil
	}
	return v.Contacts
}

func (v *VendorData) GetCountry() *string {
	if v == nil {
		return nil
	}
	return v.Country
}

func (v *VendorData) GetCustomField1() *string {
	if v == nil {
		return nil
	}
	return v.CustomField1
}

func (v *VendorData) GetCustomField2() *string {
	if v == nil {
		return nil
	}
	return v.CustomField2
}

func (v *VendorData) GetCustomerVendorAccount() *string {
	if v == nil {
		return nil
	}
	return v.CustomerVendorAccount
}

func (v *VendorData) GetEin() *VendorEin {
	if v == nil {
		return nil
	}
	return v.Ein
}

func (v *VendorData) GetEmail() *Email {
	if v == nil {
		return nil
	}
	return v.Email
}

func (v *VendorData) GetInternalReferenceId() *int64 {
	if v == nil {
		return nil
	}
	return v.InternalReferenceId
}

func (v *VendorData) GetLocationCode() *LocationCode {
	if v == nil {
		return nil
	}
	return v.LocationCode
}

func (v *VendorData) GetMcc() *Mcc {
	if v == nil {
		return nil
	}
	return v.Mcc
}

func (v *VendorData) GetName1() *VendorName1 {
	if v == nil {
		return nil
	}
	return v.Name1
}

func (v *VendorData) GetName2() *VendorName2 {
	if v == nil {
		return nil
	}
	return v.Name2
}

func (v *VendorData) GetPayeeName1() *PayeeName {
	if v == nil {
		return nil
	}
	return v.PayeeName1
}

func (v *VendorData) GetPayeeName2() *PayeeName {
	if v == nil {
		return nil
	}
	return v.PayeeName2
}

func (v *VendorData) GetPaymentMethod() *VendorPaymentMethodString {
	if v == nil {
		return nil
	}
	return v.PaymentMethod
}

func (v *VendorData) GetPhone() *VendorPhone {
	if v == nil {
		return nil
	}
	return v.Phone
}

func (v *VendorData) GetRemitAddress1() *Remitaddress1 {
	if v == nil {
		return nil
	}
	return v.RemitAddress1
}

func (v *VendorData) GetRemitAddress2() *Remitaddress2 {
	if v == nil {
		return nil
	}
	return v.RemitAddress2
}

func (v *VendorData) GetRemitCity() *Remitcity {
	if v == nil {
		return nil
	}
	return v.RemitCity
}

func (v *VendorData) GetRemitCountry() *Remitcountry {
	if v == nil {
		return nil
	}
	return v.RemitCountry
}

func (v *VendorData) GetRemitEmail() *RemitEmail {
	if v == nil {
		return nil
	}
	return v.RemitEmail
}

func (v *VendorData) GetRemitState() *Remitstate {
	if v == nil {
		return nil
	}
	return v.RemitState
}

func (v *VendorData) GetRemitZip() *Remitzip {
	if v == nil {
		return nil
	}
	return v.RemitZip
}

func (v *VendorData) GetState() *string {
	if v == nil {
		return nil
	}
	return v.State
}

func (v *VendorData) GetVendorStatus() *Vendorstatus {
	if v == nil {
		return nil
	}
	return v.VendorStatus
}

func (v *VendorData) GetZip() *string {
	if v == nil {
		return nil
	}
	return v.Zip
}

func (v *VendorData) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VendorData) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorData) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// EIN/Tax ID for vendor.
type VendorEin = string

// Primary name for vendor. Required for new vendor.
type VendorName1 = string

// Secondary name for vendor.
type VendorName2 = string

// Custom number identifying the vendor. Must be unique in paypoint.
type VendorNumber = string

// Payment method object to use for the payout.
// - `{ method: "managed" }` - Managed payment method
// - `{ method: "vcard" }` - Virtual card payment method
// - `{ method: "check" }` - Check payment method
// - `{ method: "ach", storedMethodId?: "..." }` - ACH payment method with optional stored method ID
type VendorPaymentMethod struct {
	// Payment method type - "managed", "vcard", "check", or "ach"
	Method string `json:"method" url:"method"`
	// ID of the stored ACH payment method. Only applicable when method is "ach". Required when using a previously saved ACH method when the vendor has more than one saved method. See the [Payouts with saved ACH payment methods](/developers/developer-guides/pay-out-manage-payouts) section for more details.
	StoredMethodId *string `json:"storedMethodId,omitempty" url:"storedMethodId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VendorPaymentMethod) GetMethod() string {
	if v == nil {
		return ""
	}
	return v.Method
}

func (v *VendorPaymentMethod) GetStoredMethodId() *string {
	if v == nil {
		return nil
	}
	return v.StoredMethodId
}

func (v *VendorPaymentMethod) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VendorPaymentMethod) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorPaymentMethod
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorPaymentMethod(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorPaymentMethod) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// The vendor's preferred payment method. Can be one of:
// - `"managed"` - Managed payment method
// - `"vcard"` - Virtual card payment method
// - `"check"` - Check payment method
// - `"ach"` - ACH payment method
type VendorPaymentMethodString = string

// Vendor's phone number. Phone number can't contain non-digit characters like hyphens or parentheses.
type VendorPhone = *string

type VendorQueryRecord struct {
	AdditionalData        *AdditionalData               `json:"additionalData,omitempty" url:"additionalData,omitempty"`
	Address1              *AddressNullable              `json:"Address1,omitempty" url:"Address1,omitempty"`
	Address2              *AddressAddtlNullable         `json:"Address2,omitempty" url:"Address2,omitempty"`
	BillingData           *BillingDataResponse          `json:"BillingData,omitempty" url:"BillingData,omitempty"`
	City                  *CityNullable                 `json:"City,omitempty" url:"City,omitempty"`
	Contacts              *ContactsResponse             `json:"Contacts,omitempty" url:"Contacts,omitempty"`
	Country               *string                       `json:"Country,omitempty" url:"Country,omitempty"`
	CreatedDate           *CreatedAt                    `json:"CreatedDate,omitempty" url:"CreatedDate,omitempty"`
	CustomerVendorAccount *string                       `json:"customerVendorAccount,omitempty" url:"customerVendorAccount,omitempty"`
	CustomField1          *string                       `json:"customField1,omitempty" url:"customField1,omitempty"`
	CustomField2          *string                       `json:"customField2,omitempty" url:"customField2,omitempty"`
	Ein                   *Ein                          `json:"EIN,omitempty" url:"EIN,omitempty"`
	Email                 *Email                        `json:"Email,omitempty" url:"Email,omitempty"`
	EnrollmentStatus      *EnrollmentStatus             `json:"EnrollmentStatus,omitempty" url:"EnrollmentStatus,omitempty"`
	ExternalPaypointId    *ExternalPaypointId           `json:"externalPaypointID,omitempty" url:"externalPaypointID,omitempty"`
	InternalReferenceId   *InternalReferenceId          `json:"InternalReferenceId,omitempty" url:"InternalReferenceId,omitempty"`
	LastUpdated           *LastModified                 `json:"LastUpdated,omitempty" url:"LastUpdated,omitempty"`
	LocationCode          *string                       `json:"LocationCode,omitempty" url:"LocationCode,omitempty"`
	Mcc                   *Mcc                          `json:"Mcc,omitempty" url:"Mcc,omitempty"`
	Name1                 *string                       `json:"Name1,omitempty" url:"Name1,omitempty"`
	Name2                 *string                       `json:"Name2,omitempty" url:"Name2,omitempty"`
	ParentOrgName         *OrgParentName                `json:"ParentOrgName,omitempty" url:"ParentOrgName,omitempty"`
	ParentOrgId           *OrgParentId                  `json:"ParentOrgId,omitempty" url:"ParentOrgId,omitempty"`
	PayeeName1            *PayeeName                    `json:"payeeName1,omitempty" url:"payeeName1,omitempty"`
	PayeeName2            *PayeeName                    `json:"payeeName2,omitempty" url:"payeeName2,omitempty"`
	PaymentMethod         *VendorPaymentMethodString    `json:"PaymentMethod,omitempty" url:"PaymentMethod,omitempty"`
	PaypointDbaname       *Dbaname                      `json:"PaypointDbaname,omitempty" url:"PaypointDbaname,omitempty"`
	PaypointEntryname     *Entrypointfield              `json:"PaypointEntryname,omitempty" url:"PaypointEntryname,omitempty"`
	PaypointLegalname     *Legalname                    `json:"PaypointLegalname,omitempty" url:"PaypointLegalname,omitempty"`
	Phone                 *string                       `json:"Phone,omitempty" url:"Phone,omitempty"`
	RemitAddress1         *Remitaddress1                `json:"remitAddress1,omitempty" url:"remitAddress1,omitempty"`
	RemitAddress2         *Remitaddress2                `json:"remitAddress2,omitempty" url:"remitAddress2,omitempty"`
	RemitCity             *Remitcity                    `json:"remitCity,omitempty" url:"remitCity,omitempty"`
	RemitCountry          *Remitcountry                 `json:"remitCountry,omitempty" url:"remitCountry,omitempty"`
	RemitEmail            *RemitEmail                   `json:"RemitEmail,omitempty" url:"RemitEmail,omitempty"`
	RemitState            *Remitstate                   `json:"remitState,omitempty" url:"remitState,omitempty"`
	RemitZip              *Remitzip                     `json:"remitZip,omitempty" url:"remitZip,omitempty"`
	State                 *StateNullable                `json:"State,omitempty" url:"State,omitempty"`
	StoredMethods         []*VendorResponseStoredMethod `json:"StoredMethods,omitempty" url:"StoredMethods,omitempty"`
	Summary               *VendorSummary                `json:"Summary,omitempty" url:"Summary,omitempty"`
	VendorId              *Vendorid                     `json:"VendorId,omitempty" url:"VendorId,omitempty"`
	VendorNumber          *VendorNumber                 `json:"VendorNumber,omitempty" url:"VendorNumber,omitempty"`
	VendorStatus          *Vendorstatus                 `json:"VendorStatus,omitempty" url:"VendorStatus,omitempty"`
	Zip                   *Zip                          `json:"Zip,omitempty" url:"Zip,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VendorQueryRecord) GetAdditionalData() *AdditionalData {
	if v == nil {
		return nil
	}
	return v.AdditionalData
}

func (v *VendorQueryRecord) GetAddress1() *AddressNullable {
	if v == nil {
		return nil
	}
	return v.Address1
}

func (v *VendorQueryRecord) GetAddress2() *AddressAddtlNullable {
	if v == nil {
		return nil
	}
	return v.Address2
}

func (v *VendorQueryRecord) GetBillingData() *BillingDataResponse {
	if v == nil {
		return nil
	}
	return v.BillingData
}

func (v *VendorQueryRecord) GetCity() *CityNullable {
	if v == nil {
		return nil
	}
	return v.City
}

func (v *VendorQueryRecord) GetContacts() *ContactsResponse {
	if v == nil {
		return nil
	}
	return v.Contacts
}

func (v *VendorQueryRecord) GetCountry() *string {
	if v == nil {
		return nil
	}
	return v.Country
}

func (v *VendorQueryRecord) GetCreatedDate() *CreatedAt {
	if v == nil {
		return nil
	}
	return v.CreatedDate
}

func (v *VendorQueryRecord) GetCustomerVendorAccount() *string {
	if v == nil {
		return nil
	}
	return v.CustomerVendorAccount
}

func (v *VendorQueryRecord) GetCustomField1() *string {
	if v == nil {
		return nil
	}
	return v.CustomField1
}

func (v *VendorQueryRecord) GetCustomField2() *string {
	if v == nil {
		return nil
	}
	return v.CustomField2
}

func (v *VendorQueryRecord) GetEin() *Ein {
	if v == nil {
		return nil
	}
	return v.Ein
}

func (v *VendorQueryRecord) GetEmail() *Email {
	if v == nil {
		return nil
	}
	return v.Email
}

func (v *VendorQueryRecord) GetEnrollmentStatus() *EnrollmentStatus {
	if v == nil {
		return nil
	}
	return v.EnrollmentStatus
}

func (v *VendorQueryRecord) GetExternalPaypointId() *ExternalPaypointId {
	if v == nil {
		return nil
	}
	return v.ExternalPaypointId
}

func (v *VendorQueryRecord) GetInternalReferenceId() *InternalReferenceId {
	if v == nil {
		return nil
	}
	return v.InternalReferenceId
}

func (v *VendorQueryRecord) GetLastUpdated() *LastModified {
	if v == nil {
		return nil
	}
	return v.LastUpdated
}

func (v *VendorQueryRecord) GetLocationCode() *string {
	if v == nil {
		return nil
	}
	return v.LocationCode
}

func (v *VendorQueryRecord) GetMcc() *Mcc {
	if v == nil {
		return nil
	}
	return v.Mcc
}

func (v *VendorQueryRecord) GetName1() *string {
	if v == nil {
		return nil
	}
	return v.Name1
}

func (v *VendorQueryRecord) GetName2() *string {
	if v == nil {
		return nil
	}
	return v.Name2
}

func (v *VendorQueryRecord) GetParentOrgName() *OrgParentName {
	if v == nil {
		return nil
	}
	return v.ParentOrgName
}

func (v *VendorQueryRecord) GetParentOrgId() *OrgParentId {
	if v == nil {
		return nil
	}
	return v.ParentOrgId
}

func (v *VendorQueryRecord) GetPayeeName1() *PayeeName {
	if v == nil {
		return nil
	}
	return v.PayeeName1
}

func (v *VendorQueryRecord) GetPayeeName2() *PayeeName {
	if v == nil {
		return nil
	}
	return v.PayeeName2
}

func (v *VendorQueryRecord) GetPaymentMethod() *VendorPaymentMethodString {
	if v == nil {
		return nil
	}
	return v.PaymentMethod
}

func (v *VendorQueryRecord) GetPaypointDbaname() *Dbaname {
	if v == nil {
		return nil
	}
	return v.PaypointDbaname
}

func (v *VendorQueryRecord) GetPaypointEntryname() *Entrypointfield {
	if v == nil {
		return nil
	}
	return v.PaypointEntryname
}

func (v *VendorQueryRecord) GetPaypointLegalname() *Legalname {
	if v == nil {
		return nil
	}
	return v.PaypointLegalname
}

func (v *VendorQueryRecord) GetPhone() *string {
	if v == nil {
		return nil
	}
	return v.Phone
}

func (v *VendorQueryRecord) GetRemitAddress1() *Remitaddress1 {
	if v == nil {
		return nil
	}
	return v.RemitAddress1
}

func (v *VendorQueryRecord) GetRemitAddress2() *Remitaddress2 {
	if v == nil {
		return nil
	}
	return v.RemitAddress2
}

func (v *VendorQueryRecord) GetRemitCity() *Remitcity {
	if v == nil {
		return nil
	}
	return v.RemitCity
}

func (v *VendorQueryRecord) GetRemitCountry() *Remitcountry {
	if v == nil {
		return nil
	}
	return v.RemitCountry
}

func (v *VendorQueryRecord) GetRemitEmail() *RemitEmail {
	if v == nil {
		return nil
	}
	return v.RemitEmail
}

func (v *VendorQueryRecord) GetRemitState() *Remitstate {
	if v == nil {
		return nil
	}
	return v.RemitState
}

func (v *VendorQueryRecord) GetRemitZip() *Remitzip {
	if v == nil {
		return nil
	}
	return v.RemitZip
}

func (v *VendorQueryRecord) GetState() *StateNullable {
	if v == nil {
		return nil
	}
	return v.State
}

func (v *VendorQueryRecord) GetStoredMethods() []*VendorResponseStoredMethod {
	if v == nil {
		return nil
	}
	return v.StoredMethods
}

func (v *VendorQueryRecord) GetSummary() *VendorSummary {
	if v == nil {
		return nil
	}
	return v.Summary
}

func (v *VendorQueryRecord) GetVendorId() *Vendorid {
	if v == nil {
		return nil
	}
	return v.VendorId
}

func (v *VendorQueryRecord) GetVendorNumber() *VendorNumber {
	if v == nil {
		return nil
	}
	return v.VendorNumber
}

func (v *VendorQueryRecord) GetVendorStatus() *Vendorstatus {
	if v == nil {
		return nil
	}
	return v.VendorStatus
}

func (v *VendorQueryRecord) GetZip() *Zip {
	if v == nil {
		return nil
	}
	return v.Zip
}

func (v *VendorQueryRecord) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VendorQueryRecord) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorQueryRecord
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorQueryRecord(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorQueryRecord) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Stored payment method information
type VendorResponseStoredMethod struct {
	IdPmethod      *string    `json:"IdPmethod,omitempty" url:"IdPmethod,omitempty"`
	Method         *string    `json:"Method,omitempty" url:"Method,omitempty"`
	Descriptor     *string    `json:"Descriptor,omitempty" url:"Descriptor,omitempty"`
	MaskedAccount  *string    `json:"MaskedAccount,omitempty" url:"MaskedAccount,omitempty"`
	ExpDate        *string    `json:"ExpDate,omitempty" url:"ExpDate,omitempty"`
	HolderName     *string    `json:"HolderName,omitempty" url:"HolderName,omitempty"`
	AchSecCode     *string    `json:"AchSecCode,omitempty" url:"AchSecCode,omitempty"`
	AchHolderType  *string    `json:"AchHolderType,omitempty" url:"AchHolderType,omitempty"`
	IsValidatedAch *bool      `json:"IsValidatedACH,omitempty" url:"IsValidatedACH,omitempty"`
	Bin            *string    `json:"BIN,omitempty" url:"BIN,omitempty"`
	BinData        *string    `json:"binData,omitempty" url:"binData,omitempty"`
	Aba            *string    `json:"ABA,omitempty" url:"ABA,omitempty"`
	PostalCode     *string    `json:"PostalCode,omitempty" url:"PostalCode,omitempty"`
	MethodType     *string    `json:"MethodType,omitempty" url:"MethodType,omitempty"`
	LastUpdated    *time.Time `json:"LastUpdated,omitempty" url:"LastUpdated,omitempty"`
	CardUpdatedOn  *time.Time `json:"CardUpdatedOn,omitempty" url:"CardUpdatedOn,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VendorResponseStoredMethod) GetIdPmethod() *string {
	if v == nil {
		return nil
	}
	return v.IdPmethod
}

func (v *VendorResponseStoredMethod) GetMethod() *string {
	if v == nil {
		return nil
	}
	return v.Method
}

func (v *VendorResponseStoredMethod) GetDescriptor() *string {
	if v == nil {
		return nil
	}
	return v.Descriptor
}

func (v *VendorResponseStoredMethod) GetMaskedAccount() *string {
	if v == nil {
		return nil
	}
	return v.MaskedAccount
}

func (v *VendorResponseStoredMethod) GetExpDate() *string {
	if v == nil {
		return nil
	}
	return v.ExpDate
}

func (v *VendorResponseStoredMethod) GetHolderName() *string {
	if v == nil {
		return nil
	}
	return v.HolderName
}

func (v *VendorResponseStoredMethod) GetAchSecCode() *string {
	if v == nil {
		return nil
	}
	return v.AchSecCode
}

func (v *VendorResponseStoredMethod) GetAchHolderType() *string {
	if v == nil {
		return nil
	}
	return v.AchHolderType
}

func (v *VendorResponseStoredMethod) GetIsValidatedAch() *bool {
	if v == nil {
		return nil
	}
	return v.IsValidatedAch
}

func (v *VendorResponseStoredMethod) GetBin() *string {
	if v == nil {
		return nil
	}
	return v.Bin
}

func (v *VendorResponseStoredMethod) GetBinData() *string {
	if v == nil {
		return nil
	}
	return v.BinData
}

func (v *VendorResponseStoredMethod) GetAba() *string {
	if v == nil {
		return nil
	}
	return v.Aba
}

func (v *VendorResponseStoredMethod) GetPostalCode() *string {
	if v == nil {
		return nil
	}
	return v.PostalCode
}

func (v *VendorResponseStoredMethod) GetMethodType() *string {
	if v == nil {
		return nil
	}
	return v.MethodType
}

func (v *VendorResponseStoredMethod) GetLastUpdated() *time.Time {
	if v == nil {
		return nil
	}
	return v.LastUpdated
}

func (v *VendorResponseStoredMethod) GetCardUpdatedOn() *time.Time {
	if v == nil {
		return nil
	}
	return v.CardUpdatedOn
}

func (v *VendorResponseStoredMethod) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VendorResponseStoredMethod) UnmarshalJSON(data []byte) error {
	type embed VendorResponseStoredMethod
	var unmarshaler = struct {
		embed
		LastUpdated   *internal.DateTime `json:"LastUpdated,omitempty"`
		CardUpdatedOn *internal.DateTime `json:"CardUpdatedOn,omitempty"`
	}{
		embed: embed(*v),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*v = VendorResponseStoredMethod(unmarshaler.embed)
	v.LastUpdated = unmarshaler.LastUpdated.TimePtr()
	v.CardUpdatedOn = unmarshaler.CardUpdatedOn.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorResponseStoredMethod) MarshalJSON() ([]byte, error) {
	type embed VendorResponseStoredMethod
	var marshaler = struct {
		embed
		LastUpdated   *internal.DateTime `json:"LastUpdated,omitempty"`
		CardUpdatedOn *internal.DateTime `json:"CardUpdatedOn,omitempty"`
	}{
		embed:         embed(*v),
		LastUpdated:   internal.NewOptionalDateTime(v.LastUpdated),
		CardUpdatedOn: internal.NewOptionalDateTime(v.CardUpdatedOn),
	}
	return json.Marshal(marshaler)
}

func (v *VendorResponseStoredMethod) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VendorSummary struct {
	ActiveBills            *int     `json:"ActiveBills,omitempty" url:"ActiveBills,omitempty"`
	PendingBills           *int     `json:"PendingBills,omitempty" url:"PendingBills,omitempty"`
	InTransitBills         *int     `json:"InTransitBills,omitempty" url:"InTransitBills,omitempty"`
	PaidBills              *int     `json:"PaidBills,omitempty" url:"PaidBills,omitempty"`
	OverdueBills           *int     `json:"OverdueBills,omitempty" url:"OverdueBills,omitempty"`
	ApprovedBills          *int     `json:"ApprovedBills,omitempty" url:"ApprovedBills,omitempty"`
	DisapprovedBills       *int     `json:"DisapprovedBills,omitempty" url:"DisapprovedBills,omitempty"`
	TotalBills             *int     `json:"TotalBills,omitempty" url:"TotalBills,omitempty"`
	ActiveBillsAmount      *float64 `json:"ActiveBillsAmount,omitempty" url:"ActiveBillsAmount,omitempty"`
	PendingBillsAmount     *float64 `json:"PendingBillsAmount,omitempty" url:"PendingBillsAmount,omitempty"`
	InTransitBillsAmount   *float64 `json:"InTransitBillsAmount,omitempty" url:"InTransitBillsAmount,omitempty"`
	PaidBillsAmount        *float64 `json:"PaidBillsAmount,omitempty" url:"PaidBillsAmount,omitempty"`
	OverdueBillsAmount     *float64 `json:"OverdueBillsAmount,omitempty" url:"OverdueBillsAmount,omitempty"`
	ApprovedBillsAmount    *float64 `json:"ApprovedBillsAmount,omitempty" url:"ApprovedBillsAmount,omitempty"`
	DisapprovedBillsAmount *float64 `json:"DisapprovedBillsAmount,omitempty" url:"DisapprovedBillsAmount,omitempty"`
	TotalBillsAmount       *float64 `json:"TotalBillsAmount,omitempty" url:"TotalBillsAmount,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VendorSummary) GetActiveBills() *int {
	if v == nil {
		return nil
	}
	return v.ActiveBills
}

func (v *VendorSummary) GetPendingBills() *int {
	if v == nil {
		return nil
	}
	return v.PendingBills
}

func (v *VendorSummary) GetInTransitBills() *int {
	if v == nil {
		return nil
	}
	return v.InTransitBills
}

func (v *VendorSummary) GetPaidBills() *int {
	if v == nil {
		return nil
	}
	return v.PaidBills
}

func (v *VendorSummary) GetOverdueBills() *int {
	if v == nil {
		return nil
	}
	return v.OverdueBills
}

func (v *VendorSummary) GetApprovedBills() *int {
	if v == nil {
		return nil
	}
	return v.ApprovedBills
}

func (v *VendorSummary) GetDisapprovedBills() *int {
	if v == nil {
		return nil
	}
	return v.DisapprovedBills
}

func (v *VendorSummary) GetTotalBills() *int {
	if v == nil {
		return nil
	}
	return v.TotalBills
}

func (v *VendorSummary) GetActiveBillsAmount() *float64 {
	if v == nil {
		return nil
	}
	return v.ActiveBillsAmount
}

func (v *VendorSummary) GetPendingBillsAmount() *float64 {
	if v == nil {
		return nil
	}
	return v.PendingBillsAmount
}

func (v *VendorSummary) GetInTransitBillsAmount() *float64 {
	if v == nil {
		return nil
	}
	return v.InTransitBillsAmount
}

func (v *VendorSummary) GetPaidBillsAmount() *float64 {
	if v == nil {
		return nil
	}
	return v.PaidBillsAmount
}

func (v *VendorSummary) GetOverdueBillsAmount() *float64 {
	if v == nil {
		return nil
	}
	return v.OverdueBillsAmount
}

func (v *VendorSummary) GetApprovedBillsAmount() *float64 {
	if v == nil {
		return nil
	}
	return v.ApprovedBillsAmount
}

func (v *VendorSummary) GetDisapprovedBillsAmount() *float64 {
	if v == nil {
		return nil
	}
	return v.DisapprovedBillsAmount
}

func (v *VendorSummary) GetTotalBillsAmount() *float64 {
	if v == nil {
		return nil
	}
	return v.TotalBillsAmount
}

func (v *VendorSummary) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VendorSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorSummary(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorSummary) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Payabli identifier for vendor record.
type Vendorid = int

// Vendor's status.
// Allowed status:
//
//   - 0 Inactive
//
//   - 1 Active
type Vendorstatus = int

// The business website address. Include only the domain and TLD, do not enter the protocol (http/https). For example: `www.example.com` is acceptable.
type Website = string

// Describes when customers are charged for goods or services. Accepted values:
type Whencharged string

const (
	WhenchargedWhenServiceProvided Whencharged = "When Service Provided"
	WhenchargedInAdvance           Whencharged = "In Advance"
)

func NewWhenchargedFromString(s string) (Whencharged, error) {
	switch s {
	case "When Service Provided":
		return WhenchargedWhenServiceProvided, nil
	case "In Advance":
		return WhenchargedInAdvance, nil
	}
	var t Whencharged
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w Whencharged) Ptr() *Whencharged {
	return &w
}

// When goods and services are delivered.
type Whendelivered string

const (
	WhendeliveredZero7Days     Whendelivered = "0-7 Days"
	WhendeliveredEight14Days   Whendelivered = "8-14 Days"
	WhendeliveredFifteen30Days Whendelivered = "15-30 Days"
	WhendeliveredOver30Days    Whendelivered = "Over 30 Days"
)

func NewWhendeliveredFromString(s string) (Whendelivered, error) {
	switch s {
	case "0-7 Days":
		return WhendeliveredZero7Days, nil
	case "8-14 Days":
		return WhendeliveredEight14Days, nil
	case "15-30 Days":
		return WhendeliveredFifteen30Days, nil
	case "Over 30 Days":
		return WhendeliveredOver30Days, nil
	}
	var t Whendelivered
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w Whendelivered) Ptr() *Whendelivered {
	return &w
}

// Describes when goods or services are provided, from time of transaction.
type Whenprovided string

const (
	WhenprovidedThirtyDaysOrLess  Whenprovided = "30 Days or Less"
	WhenprovidedThirtyOneTo60Days Whenprovided = "31 to 60 Days"
	WhenprovidedSixtyDays         Whenprovided = "60+ Days"
)

func NewWhenprovidedFromString(s string) (Whenprovided, error) {
	switch s {
	case "30 Days or Less":
		return WhenprovidedThirtyDaysOrLess, nil
	case "31 to 60 Days":
		return WhenprovidedThirtyOneTo60Days, nil
	case "60+ Days":
		return WhenprovidedSixtyDays, nil
	}
	var t Whenprovided
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w Whenprovided) Ptr() *Whenprovided {
	return &w
}

// Describes the business refund policy.
type Whenrefunded string

const (
	WhenrefundedExchangeOnly       Whenrefunded = "Exchange Only"
	WhenrefundedNoRefundOrExchange Whenrefunded = "No Refund or Exchange"
	WhenrefundedMoreThan30Days     Whenrefunded = "More than 30 days"
	WhenrefundedThirtyDaysOrLess   Whenrefunded = "30 Days or Less"
)

func NewWhenrefundedFromString(s string) (Whenrefunded, error) {
	switch s {
	case "Exchange Only":
		return WhenrefundedExchangeOnly, nil
	case "No Refund or Exchange":
		return WhenrefundedNoRefundOrExchange, nil
	case "More than 30 days":
		return WhenrefundedMoreThan30Days, nil
	case "30 Days or Less":
		return WhenrefundedThirtyDaysOrLess, nil
	}
	var t Whenrefunded
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w Whenrefunded) Ptr() *Whenrefunded {
	return &w
}

// ZIP code for address.
type Zip = string
